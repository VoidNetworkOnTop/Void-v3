<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>The Void Games - Mines</title>

   <!-- Favicon -->
   <link rel="shortcut icon" href="./assets/favicon.png" type="image/png">

   <style>
       body, html {
           margin: 0;
           padding: 0;
           width: 100%;
           height: 100%;
           background: #000;
           color: #fff;
           font-family: 'Arial', sans-serif;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
       }

       .game-container {
           background: linear-gradient(180deg, #000000, #0c0c1f, #000018);
           border-radius: 10px;
           width: 90%;
           max-width: 800px;
           height: 90vh;
           max-height: 800px;
           display: flex;
           flex-direction: column;
           position: relative;
           padding: 1rem;
           box-shadow: 
               0 0 2px #fff,
               0 0 4px #fff,
               0 0 6px #4d7cff,
               0 0 8px #4d7cff,
               inset 0 0 2px rgba(255, 255, 255, 0.2);
           z-index: 3;
           overflow: hidden;
       }

       .game-header {
           text-align: center;
           padding-bottom: 1rem;
           border-bottom: 1px solid rgba(77, 124, 255, 0.2);
           position: relative;
           background: linear-gradient(90deg, transparent, rgba(77, 124, 255, 0.05), transparent);
           z-index: 10;
       }

       .game-title {
           font-size: 2.2rem;
           margin: 0 0 0.5rem 0;
           background: linear-gradient(45deg, #fff, #4d7cff);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           font-weight: bold;
           text-transform: uppercase;
           letter-spacing: 3px;
           text-shadow: 0 0 10px rgba(77, 124, 255, 0.7);
           animation: titleGlow 2s infinite alternate;
       }

       @keyframes titleGlow {
           0% { text-shadow: 0 0 5px rgba(77, 124, 255, 0.7); }
           100% { text-shadow: 0 0 15px rgba(77, 124, 255, 0.9), 0 0 30px rgba(77, 124, 255, 0.5); }
       }

       .game-subtitle {
           font-size: 1rem;
           color: #aac4ff;
           margin: 0;
           text-transform: uppercase;
           letter-spacing: 2px;
           opacity: 0.8;
       }

       .coin-tracker {
           position: absolute;
           top: 0;
           right: 0;
           background: linear-gradient(135deg, rgba(77, 124, 255, 0.1), rgba(20, 30, 60, 0.5));
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           padding: 0.5rem 1rem;
           display: flex;
           align-items: center;
           gap: 0.5rem;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.3);
           animation: glow 2s infinite;
           backdrop-filter: blur(5px);
           z-index: 10;
       }

       .coin-icon {
           width: 20px;
           height: 20px;
           background: linear-gradient(135deg, #FFD700, #FFA500);
           border-radius: 50%;
           box-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
           position: relative;
           overflow: hidden;
       }

       .coin-icon::after {
           content: '';
           position: absolute;
           top: 3px;
           left: 3px;
           width: 6px;
           height: 6px;
           background: rgba(255, 255, 255, 0.8);
           border-radius: 50%;
       }

       .coin-amount {
           font-weight: bold;
           font-size: 1.1rem;
           color: #FFD700;
           text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
       }

       .earnings-tracker {
           position: absolute;
           top: 0;
           left: 0;
           background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(20, 60, 30, 0.5));
           border: 1px solid rgba(76, 175, 80, 0.4);
           border-radius: 30px;
           padding: 0.5rem 1rem;
           display: flex;
           align-items: center;
           gap: 0.5rem;
           box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
           animation: greenGlow 2s infinite;
           backdrop-filter: blur(5px);
           z-index: 10;
       }

       .earnings-icon {
           width: 20px;
           height: 20px;
           background: linear-gradient(135deg, #4CAF50, #2E7D32);
           border-radius: 50%;
           box-shadow: 0 0 5px rgba(76, 175, 80, 0.8);
           position: relative;
           overflow: hidden;
           display: flex;
           align-items: center;
           justify-content: center;
           font-weight: bold;
           font-size: 12px;
           color: white;
       }

       .earnings-icon::after {
           content: '+';
           position: absolute;
       }

       .earnings-amount {
           font-weight: bold;
           font-size: 1.1rem;
           color: #4CAF50;
           text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
       }

       @keyframes greenGlow {
           0% { filter: drop-shadow(0 0 2px rgba(76, 175, 80, 0.7)); }
           50% { filter: drop-shadow(0 0 10px rgba(76, 175, 80, 0.9)); }
           100% { filter: drop-shadow(0 0 2px rgba(76, 175, 80, 0.7)); }
       }

       .game-board {
           flex-grow: 1;
           position: relative;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           background: #1a1a2e;
           border-radius: 8px;
           margin: 1rem 0;
           min-height: 60vh;
           border: 1px solid rgba(77, 124, 255, 0.2);
           box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
           padding: 20px;
       }

       #game-canvas {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: transparent;
           z-index: 1;
           display: block;
       }

       .game-overlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           background: rgba(0, 8, 30, 0.85);
           z-index: 100; /* Higher z-index to ensure it's above everything */
           opacity: 0;
           pointer-events: none;
           transition: opacity 0.3s ease;
           backdrop-filter: blur(4px);
       }

       .game-overlay.visible {
           opacity: 1;
           pointer-events: all;
           animation: fadeIn 0.5s ease-out;
       }

       @keyframes fadeIn {
           from { opacity: 0; }
           to { opacity: 1; }
       }

       .overlay-content {
           text-align: center;
           padding: 2.5rem;
           background: linear-gradient(135deg, rgba(13, 21, 40, 0.9), rgba(5, 10, 30, 0.9));
           border-radius: 10px;
           border: 1px solid rgba(77, 124, 255, 0.3);
           box-shadow: 0 0 30px rgba(77, 124, 255, 0.2);
           max-width: 80%;
           animation: floatEffect 4s infinite ease-in-out;
       }

       @keyframes floatEffect {
           0%, 100% { transform: translateY(0); }
           50% { transform: translateY(-10px); }
       }

       .overlay-title {
           font-size: 2.5rem;
           margin-bottom: 1rem;
           text-transform: uppercase;
           letter-spacing: 3px;
           font-weight: bold;
       }

       .overlay-title.win {
           background: linear-gradient(45deg, #4CAF50, #8BC34A);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
       }

       .overlay-title.lose {
           background: linear-gradient(45deg, #f44336, #E91E63);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
       }

       .overlay-message {
           font-size: 1.2rem;
           margin-bottom: 2rem;
           color: #aac4ff;
           line-height: 1.6;
       }

       .option-selector {
           display: flex;
           justify-content: center;
           gap: 1rem;
           margin-bottom: 2rem;
       }

       .option-btn {
           padding: 0.75rem 1.5rem;
           font-size: 1.2rem;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           color: #fff;
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           cursor: pointer;
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 1px;
       }

       .option-btn:hover {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: translateY(-2px);
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.3);
       }

       .option-btn.selected {
           background: linear-gradient(135deg, #4a5d94, #2c3e6d);
           border: 1px solid rgba(255, 255, 255, 0.6);
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.5);
       }

       /* Bomb selection styles */
       .bomb-count-selector {
           margin: 1.5rem 0;
       }

       .bomb-count-display {
           font-size: 1.4rem;
           color: #ff9800;
           margin: 0.5rem 0;
           font-weight: bold;
       }

       .reward-display {
           font-size: 1.2rem;
           color: #4caf50;
           margin: 1rem 0;
           font-weight: bold;
       }

       .bomb-slider-container {
           width: 100%;
           padding: 0 1rem;
           max-width: 300px;
           margin: 0 auto;
       }

       .bomb-slider {
           -webkit-appearance: none;
           width: 100%;
           height: 10px;
           background: linear-gradient(90deg, #2E7D32, #f44336);
           border-radius: 5px;
           outline: none;
           cursor: pointer;
       }

       .bomb-slider::-webkit-slider-thumb {
           -webkit-appearance: none;
           appearance: none;
           width: 25px;
           height: 25px;
           background: #fff;
           border-radius: 50%;
           cursor: pointer;
           box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
       }

       .bomb-slider::-moz-range-thumb {
           width: 25px;
           height: 25px;
           background: #fff;
           border-radius: 50%;
           cursor: pointer;
           box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
       }

       .bomb-count-controls {
           display: flex;
           justify-content: space-between;
           max-width: 300px;
           margin: 0.5rem auto;
       }

       .bomb-count-btn {
           width: 40px;
           height: 40px;
           border-radius: 50%;
           font-size: 1.5rem;
           display: flex;
           align-items: center;
           justify-content: center;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           color: #fff;
           border: 1px solid rgba(77, 124, 255, 0.4);
           cursor: pointer;
           box-shadow: 0 0 5px rgba(77, 124, 255, 0.3);
           transition: all 0.2s;
       }

       .bomb-count-btn:hover {
           transform: scale(1.1);
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.5);
       }

       .game-btn {
           padding: 0.75rem 2rem;
           font-size: 1.2rem;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           color: #fff;
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           cursor: pointer;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.2);
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 2px;
           font-weight: bold;
           position: relative;
           overflow: hidden;
       }

       .game-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
           transition: all 0.6s ease;
       }

       .game-btn:hover::before {
           left: 100%;
       }

       .game-btn:hover {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: translateY(-2px);
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.3);
       }

       .game-btn:active {
           transform: translateY(1px);
       }

       .game-btn:disabled {
           opacity: 0.5;
           cursor: not-allowed;
           background: linear-gradient(135deg, #444, #333);
       }

       .game-btn.insufficient {
           background: linear-gradient(135deg, #70283f, #350f1a);
           color: #ffcccc;
           border-color: rgba(244, 67, 54, 0.4);
       }

       /* Improved cashout button for better visibility */
       .cashout-btn {
           padding: 0.75rem 2rem;
           font-size: 1.2rem;
           background: linear-gradient(135deg, #2e7d32, #1b5e20);
           color: #fff;
           border: 1px solid rgba(76, 175, 80, 0.4);
           border-radius: 30px;
           cursor: pointer;
           box-shadow: 0 0 10px rgba(76, 175, 80, 0.2);
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 2px;
           font-weight: bold;
           position: relative;
           overflow: hidden;
           margin-top: 15px;
           margin-bottom: 10px;
           z-index: 20;
           width: 80%;
           max-width: 250px;
           text-align: center;
       }

       .cashout-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
           transition: all 0.6s ease;
       }

       .cashout-btn:hover::before {
           left: 100%;
       }

       .cashout-btn:hover {
           background: linear-gradient(135deg, #388e3c, #2e7d32);
           transform: translateY(-2px);
           box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
       }

       .cashout-btn:active {
           transform: translateY(1px);
       }

       .cashout-btn:disabled {
           background: linear-gradient(135deg, #1b5e20, #0f3013);
           opacity: 0.7;
           cursor: not-allowed;
       }

       .controls {
           display: flex;
           justify-content: center;
           align-items: center;
           padding: 1rem 0;
           gap: 1rem;
           z-index: 10;
       }

       .restart-btn {
           padding: 0.75rem 1.5rem;
           font-size: 1rem;
           background: linear-gradient(135deg, #192238, #0d1526);
           color: #aac4ff;
           border: 1px solid rgba(77, 124, 255, 0.2);
           border-radius: 30px;
           cursor: pointer;
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 1px;
           position: relative;
           overflow: hidden;
       }

       .restart-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
           transition: all 0.6s ease;
       }

       .restart-btn:hover::before {
           left: 100%;
       }

       .restart-btn:hover {
           color: #fff;
           border-color: rgba(77, 124, 255, 0.4);
           background: linear-gradient(135deg, #243252, #131e36);
       }

       .score-display {
           text-align: center;
           margin-top: 1rem;
           font-size: 1.2rem;
           height: 1.5rem;
           color: #aac4ff;
           text-shadow: 0 0 5px rgba(77, 124, 255, 0.5);
           background: linear-gradient(90deg, transparent, rgba(77, 124, 255, 0.05), transparent);
           padding: 0.2rem 0;
           border-radius: 20px;
           z-index: 10;
       }

       .win-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #4caf50;
           text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
       }

       .lose-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #f44336;
           text-shadow: 0 0 5px rgba(244, 67, 54, 0.5);
       }

       /* Mines specific styles */
       .mines-grid {
           display: grid;
           gap: 10px;
           width: 100%;
           max-width: 500px;
           margin: 0 auto;
           z-index: 10;
       }

       .grid-24 {
           grid-template-columns: repeat(6, 1fr);
       }

       .grid-44 {
           grid-template-columns: repeat(8, 1fr);
           gap: 8px;
       }

       .grid-64 {
           grid-template-columns: repeat(8, 1fr);
           gap: 6px;
       }

       /* Improved mine cell style */
       .mine-cell {
           aspect-ratio: 1/1;
           background: linear-gradient(135deg, #2a3656, #161d33);
           border: 2px solid rgba(77, 124, 255, 0.3);
           border-radius: 8px;
           cursor: pointer;
           transition: all 0.3s ease;
           display: flex;
           align-items: center;
           justify-content: center;
           font-size: 1.5rem;
           color: white;
           position: relative;
           z-index: 20;
           user-select: none;
           min-height: 40px;
           min-width: 40px;
       }

       .mine-cell:hover {
           transform: scale(1.05);
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.4);
           border-color: rgba(77, 124, 255, 0.6);
       }

       .mine-cell.revealed-safe {
           background: linear-gradient(135deg, #388e3c, #2e7d32);
           border-color: rgba(76, 175, 80, 0.8);
           box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
           cursor: default;
           animation: revealSafe 0.5s ease-out;
       }

       @keyframes revealSafe {
           0% { transform: scale(1); }
           50% { transform: scale(1.1); }
           100% { transform: scale(1); }
       }

       .mine-cell.revealed-bomb {
           background: linear-gradient(135deg, #d32f2f, #b71c1c);
           border-color: rgba(244, 67, 54, 0.8);
           box-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
           cursor: default;
           animation: revealBomb 0.5s ease-out;
       }

       @keyframes revealBomb {
           0% { transform: scale(1); }
           25% { transform: scale(1.2); }
           50% { transform: scale(0.9); }
           75% { transform: scale(1.1); }
           100% { transform: scale(1); }
       }

       .game-info {
           background: rgba(10, 20, 40, 0.6);
           border-radius: 20px;
           border: 1px solid rgba(77, 124, 255, 0.2);
           padding: 10px 20px;
           color: white;
           font-size: 1.1rem;
           text-align: center;
           margin-bottom: 15px;
           max-width: 90%;
           z-index: 10;
       }

       /* Made game container non-scrollable, compact layout */
       #mines-game-container {
           z-index: 10;
           width: 100%;
           height: 100%;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           overflow: hidden;
           position: relative;
       }

       .game-actions {
           display: flex;
           flex-direction: column;
           align-items: center;
           gap: 10px;
           margin-top: 10px;
           z-index: 20;
           width: 100%;
           position: absolute;
           bottom: 10px;
           left: 0;
           right: 0;
       }

       /* Special Effects */
       @keyframes glow {
           0% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
           50% { filter: drop-shadow(0 0 10px rgba(77, 124, 255, 0.9)); }
           100% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
       }

       .bomb-icon {
           font-size: 24px;
           animation: bombPulse 1s infinite alternate;
       }

       @keyframes bombPulse {
           0% { transform: scale(1); }
           100% { transform: scale(1.2); }
       }

       .coin-icon-cell {
           font-size: 18px;
           color: #FFD700;
       }

       /* Media queries for better responsiveness */
       @media (max-height: 700px) {
           .game-info {
               margin-bottom: 5px;
               font-size: 0.9rem;
               padding: 8px 15px;
           }

           .mines-grid {
               gap: 5px;
               max-width: 400px;
               margin: 5px auto 80px auto; /* Add bottom margin for cashout button */
           }

           .mine-cell {
               min-height: 30px;
               min-width: 30px;
               font-size: 1.2rem;
           }

           .cashout-btn {
               padding: 0.5rem 1.5rem;
               font-size: 1rem;
               margin-top: 5px;
               position: absolute;
               bottom: 10px;
           }

           .game-info {
               font-size: 0.9rem;
               padding: 5px 15px;
           }

           .overlay-content {
               padding: 1.5rem;
           }

           .overlay-title {
               font-size: 2rem;
               margin-bottom: 0.5rem;
           }

           .overlay-message {
               font-size: 1rem;
               margin-bottom: 1rem;
           }

           .bomb-count-display {
               font-size: 1.2rem;
           }

           .reward-display {
               font-size: 1rem;
           }
       }

       @media (max-width: 480px) {
           .option-selector {
               flex-direction: column;
               gap: 0.5rem;
           }

           .option-btn {
               padding: 0.5rem 1rem;
               font-size: 1rem;
           }

           .overlay-title {
               font-size: 1.8rem;
           }

           .overlay-message {
               font-size: 0.9rem;
           }

           .game-title {
               font-size: 1.8rem;
           }

           .cashout-btn {
               width: 80%;
           }

           .mines-grid.grid-24 {
               grid-template-columns: repeat(4, 1fr);
               gap: 8px;
           }

           .mines-grid.grid-44, .mines-grid.grid-64 {
               grid-template-columns: repeat(6, 1fr);
               gap: 5px;
           }

           .mine-cell {
               min-height: 25px;
               min-width: 25px;
           }

           .bomb-slider-container {
               max-width: 250px;
           }

           .bomb-count-btn {
               width: 35px;
               height: 35px;
           }
       }
   </style>
</head>

<body>
   <div class="game-container">
       <div class="game-header">
           <h1 class="game-title">Mines</h1>
           <p class="game-subtitle">Avoid the bombs, earn coins!</p>
           <div class="coin-tracker">
               <div class="coin-icon"></div>
               <span class="coin-amount" id="coinDisplay">0</span>
           </div>
           <div class="earnings-tracker">
               <div class="earnings-icon"></div>
               <span class="earnings-amount" id="earningsDisplay">0</span>
           </div>
       </div>

       <div class="game-board">
           <canvas id="game-canvas"></canvas>
           <div id="mines-game-container" style="display: none;">
               <div class="game-info" id="game-info">Select squares to reveal. Find safe squares to earn coins!</div>
               <div id="mines-grid" class="mines-grid"></div>
               <div class="game-actions">
                   <button id="cashout-btn" class="cashout-btn" disabled>Cash Out</button>
               </div>
           </div>

           <!-- Start Screen Overlay -->
           <div class="game-overlay visible" id="start-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title">Mines</h2>
                   <p class="overlay-message">Select the number of squares to play with:<br>
                   24 Squares: Higher risk, higher reward<br>
                   44 Squares: Balanced risk and reward<br>
                   64 Squares: Lower risk, lower reward</p>

                   <div class="option-selector">
                       <button class="option-btn selected" data-squares="24" data-base-reward="1">24 Squares</button>
                       <button class="option-btn" data-squares="44" data-base-reward="1">44 Squares</button>
                       <button class="option-btn" data-squares="64" data-base-reward="1">64 Squares</button>
                   </div>

                   <button id="next-btn" class="game-btn">Next</button>
               </div>
           </div>

           <!-- Bomb Selection Screen -->
           <div class="game-overlay" id="bomb-select-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title">Select Bombs</h2>
                   <p class="overlay-message">More bombs = higher reward per safe square!<br>
                   Maximum reward is 1,000,000 coins with almost all bombs.</p>

                   <div class="bomb-count-selector">
                       <div class="bomb-count-display" id="bomb-count-display">Bombs: 1</div>
                       <div class="reward-display" id="reward-display">Reward per square: 1 coin</div>

                       <div class="bomb-slider-container">
                           <input type="range" min="1" max="23" value="1" class="bomb-slider" id="bomb-slider">
                       </div>

                       <div class="bomb-count-controls">
                           <button class="bomb-count-btn" id="decrease-bomb">-</button>
                           <button class="bomb-count-btn" id="increase-bomb">+</button>
                       </div>
                   </div>

                   <button id="start-btn" class="game-btn">Start Game (5 coins)</button>
               </div>
           </div>

           <!-- Game Over Overlay -->
           <div class="game-overlay" id="game-over-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title lose">Bomb Found!</h2>
                   <p class="overlay-message">You hit a bomb!<br>You revealed <span id="revealed-count">0</span> safe squares<br>Lost: <span id="lost-earnings" class="lose-amount">0</span> coins</p>
                   <button id="play-again-btn" class="game-btn">Play Again</button>
               </div>
           </div>

           <!-- Cashout Screen Overlay -->
           <div class="game-overlay" id="cashout-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title win">Cashed Out!</h2>
                   <p class="overlay-message">Congratulations!<br>You revealed <span id="cashout-count">0</span> safe squares<br>Won: <span id="cashout-reward" class="win-amount">0</span> coins</p>
                   <button id="new-game-btn" class="game-btn">Play Again</button>
               </div>
           </div>
       </div>

       <div class="controls">
           <button id="back-btn" class="restart-btn">Back to Beta Games</button>
       </div>
   </div>

   <!-- Firebase SDK -->
   <script type="module">
       // Firebase Imports
       import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
       import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
       import { 
           getFirestore, 
           doc, 
           getDoc, 
           updateDoc, 
           setDoc, 
           collection, 
           runTransaction,
           serverTimestamp 
       } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore.js";

       // Firebase Configuration
       const firebaseConfig = {
           apiKey: "AIzaSyCkAp_GCGCtw4zv7GgHJOE9GPgIaPEuOvQ",
           authDomain: "void-games-c8d9e.firebaseapp.com",
           projectId: "void-games-c8d9e",
           storageBucket: "void-games-c8d9e.firebasestorage.app",
           messagingSenderId: "1063089929776",
           appId: "1:1063089929776:web:8e226a23a4f3ab9c5777f5"
       };

       // Initialize Firebase
       const app = initializeApp(firebaseConfig);
       const auth = getAuth(app);
       const db = getFirestore(app);

       // SECURITY: Wrap everything in an IIFE to prevent global access
       (function() {
           // Generate a unique security token for this session
           const securityToken = Array.from(window.crypto.getRandomValues(new Uint8Array(16)))
               .map(b => b.toString(16).padStart(2, "0"))
               .join('');
           
           // Create a secure reference to store the last verified server balance
           let lastVerifiedBalance = 0;
           let pendingTransactions = new Set();
           let transactionInProgress = false;
           
           // Authentication and Coin Management
           let currentUser = null;
           let _coinBalance = 1000; // Default starting balance
           
           // Create secure property for coin balance
           Object.defineProperty(window, 'coinBalance', {
               get: function() {
                   return _coinBalance;
               },
               set: function(value) {
                   // Only allow updates from our secure methods
                   const stack = new Error().stack;
                   if (stack.includes('updateCoins') || 
                       stack.includes('loadFirebaseCoinBalance') || 
                       stack.includes('recordGameTransaction')) {
                       _coinBalance = value;
                   } else {
                       console.warn("Attempt to directly modify coin balance detected and blocked");
                   }
               },
               configurable: false
           });

           // Authentication State Listener
           onAuthStateChanged(auth, async (user) => {
               if (user) {
                   // User is signed in
                   currentUser = user;
                   console.log("User signed in:", user.uid);
                   await loadFirebaseCoinBalance();
               } else {
                   // No user is signed in - use default balance
                   currentUser = null;
                   console.log("No user signed in, using default balance");
                   _coinBalance = 1000; // Default fallback
                   updateCoinDisplay();
               }
           });

           // SECURITY: Server-side balance verification
           async function verifyBalance() {
               if (!currentUser) return true; // No verification needed for guest
               
               try {
                   // Get fresh server data
                   const userRef = doc(db, 'users', currentUser.uid);
                   const userDoc = await getDoc(userRef, { source: 'server' });
                   
                   if (userDoc.exists()) {
                       const serverBalance = userDoc.data().accountBalance || 0;
                       
                       // If local balance doesn't match server (possible tampering)
                       if (Math.abs(_coinBalance - serverBalance) > 1) { // Allow small floating point differences
                           console.warn("Balance verification failed. Resetting to server value.");
                           _coinBalance = serverBalance;
                           updateCoinDisplay();
                           return false;
                       }
                       
                       // Update the last verified balance
                       lastVerifiedBalance = serverBalance;
                       return true;
                   }
                   return false;
               } catch (error) {
                   console.error("Error verifying balance:", error);
                   return false;
               }
           }

           // SECURITY: Use Firestore transactions for safer balance updates
           async function loadFirebaseCoinBalance() {
               if (!currentUser) {
                   console.log("No user available to load balance");
                   return;
               }

               try {
                   console.log("Loading balance for user:", currentUser.uid);
                   
                   const userRef = doc(db, 'users', currentUser.uid);
                   
                   // Use a transaction to get the latest data
                   const result = await runTransaction(db, async (transaction) => {
                       const userDoc = await transaction.get(userRef);
                       
                       if (userDoc.exists()) {
                           // Get coin balance from Firestore
                           const userData = userDoc.data();
                           const serverBalance = userData.accountBalance || 0;
                           
                           // Store the verified server balance
                           lastVerifiedBalance = serverBalance;
                           
                           return { 
                               balance: serverBalance,
                               isNew: false
                           };
                       } else {
                           // Create initial balance if no document exists
                           const initialBalance = 1000;
                           
                           // We'll create the document outside the transaction
                           return {
                               balance: initialBalance,
                               isNew: true
                           };
                       }
                   });
                   
                   // If new user, create the document
                   if (result.isNew) {
                       await setDoc(userRef, { 
                           accountBalance: result.balance,
                           username: currentUser.displayName || "Player",
                           email: currentUser.email,
                           createdAt: serverTimestamp(),
                           totalGamesPlayed: 0,
                           totalMoneySpent: 0,
                           totalMoneyEarned: 0,
                           securityToken: securityToken // Store security token
                       });
                   }
                   
                   // Update local balances safely
                   _coinBalance = result.balance;
                   
                   // Update UI and game state
                   updateCoinDisplay();
                   
                   // Update start button appearance
                   updateStartButtonAppearance();
                   
                   console.log("Updated local balance:", _coinBalance);
                   return result.balance;
               } catch (error) {
                   console.error("Error loading coin balance:", error);
                   _coinBalance = 1000; // Default fallback
                   updateCoinDisplay();
                   return 0;
               }
           }

           // SECURITY: Secure transaction recording with server verification
           async function recordGameTransaction(gameId, amount, isWin) {
               if (!currentUser) {
                   // For guests, just update local balance
                   _coinBalance += isWin ? amount : -Math.abs(amount);
                   updateCoinDisplay();
                   return { newBalance: _coinBalance };
               }
               
               // Validate with security verification
               if (!await verifyBalance()) {
                   console.error("Balance verification failed, transaction canceled");
                   return null;
               }

               try {
                   console.log(`Recording transaction: ${isWin ? 'win' : 'play'} for ${Math.abs(amount)} coins`);
                   
                   // Create a unique transaction ID
                   const transactionId = crypto.randomUUID();
                   
                   // Check for duplicate transactions
                   if (pendingTransactions.has(transactionId)) {
                       console.log("Duplicate transaction detected");
                       return null;
                   }
                   
                   pendingTransactions.add(transactionId);
                   
                   // Set a transaction lock to prevent duplicate updates
                   if (transactionInProgress) {
                       console.log("Transaction already in progress, waiting...");
                       await new Promise(resolve => setTimeout(resolve, 300));
                   }
                   
                   transactionInProgress = true;
                   
                   try {
                       // Use a Firestore transaction for atomicity
                       const result = await runTransaction(db, async (transaction) => {
                           // Get user document with fresh server data
                           const userRef = doc(db, 'users', currentUser.uid);
                           const userDoc = await transaction.get(userRef);
                           
                           if (!userDoc.exists()) {
                               throw new Error("User document not found");
                           }
                           
                           const userData = userDoc.data();
                           const currentServerBalance = userData.accountBalance || 0;
                           
                           // Perform security check with lastVerifiedBalance
                           if (Math.abs(currentServerBalance - lastVerifiedBalance) > 1) {
                               console.error("Possible balance tampering detected");
                               return { error: "Security verification failed" };
                           }
                           
                           // Calculate new balance
                           let updatedBalance = currentServerBalance;
                           const absAmount = Math.abs(amount);
                           
                           if (isWin) {
                               updatedBalance += amount;
                               userData.totalMoneyEarned = (userData.totalMoneyEarned || 0) + absAmount;
                           } else {
                               updatedBalance -= absAmount;
                               userData.totalGamesPlayed = (userData.totalGamesPlayed || 0) + 1;
                               userData.totalMoneySpent = (userData.totalMoneySpent || 0) + absAmount;
                           }
                           
                           // Create transaction record
                           const transactionRef = doc(collection(db, 'transactions'), transactionId);
                           
                           // Update user document
                           transaction.update(userRef, {
                               accountBalance: updatedBalance,
                               totalGamesPlayed: userData.totalGamesPlayed || 0,
                               totalMoneySpent: userData.totalMoneySpent || 0,
                               totalMoneyEarned: userData.totalMoneyEarned || 0,
                               lastUpdated: serverTimestamp()
                           });
                           
                           // Record transaction with security token
                           transaction.set(transactionRef, {
                               userId: currentUser.uid,
                               gameId: gameId,
                               transactionId: transactionId,
                               transactionType: isWin ? 'game_win' : 'game_play',
                               amount: absAmount,
                               balanceBefore: currentServerBalance,
                               balanceAfter: updatedBalance,
                               securityToken: securityToken,
                               timestamp: serverTimestamp()
                           });
                           
                           return {
                               newBalance: updatedBalance,
                               transactionId: transactionId
                           };
                       });
                       
                       // Update local state to match server
                       if (!result.error) {
                           lastVerifiedBalance = result.newBalance;
                           _coinBalance = result.newBalance;
                           updateCoinDisplay();
                           return result;
                       } else {
                           console.error("Transaction error:", result.error);
                           return null;
                       }
                   } finally {
                       // Always release locks
                       transactionInProgress = false;
                       pendingTransactions.delete(transactionId);
                   }
               } catch (error) {
                   console.error("Transaction Error:", error);
                   transactionInProgress = false;
                   pendingTransactions.clear();
                   return null;
               }
           }

           // Update start button appearance based on balance
           function updateStartButtonAppearance() {
               const startBtn = document.getElementById('start-btn');
               if (startBtn) {
                   if (_coinBalance < 5) {
                       startBtn.classList.add('insufficient');
                       startBtn.textContent = "Insufficient Coins (Need 5)";
                       startBtn.disabled = true;
                   } else {
                       startBtn.classList.remove('insufficient');
                       startBtn.textContent = "Start Game (5 coins)";
                       startBtn.disabled = false;
                   }
               }
           }

           // Update coin display
           function updateCoinDisplay() {
               const coinDisplay = document.getElementById('coinDisplay');
               if (coinDisplay) {
                   coinDisplay.textContent = _coinBalance.toLocaleString();
               }

               // Also update start button appearance
               updateStartButtonAppearance();
           }

           // Make updateCoinDisplay available to game code
           window.updateCoinDisplay = updateCoinDisplay;
           
           // Expose necessary functions in a secure way
           window.loadFirebaseCoinBalance = loadFirebaseCoinBalance;
           window.recordGameTransaction = recordGameTransaction;
           
           // SECURITY: Anti-debugging protection
           const antiDebugInterval = setInterval(() => {
               const startTime = performance.now();
               debugger; // This statement gets triggered when DevTools is open
               const endTime = performance.now();
               
               // If debugger statement takes too long to execute, DevTools is likely open
               if (endTime - startTime > 100) {
                   console.log("%cDeveloper tools detected", "color:red; font-size:20px;");
                   console.log("%cCheating attempts may result in account penalties.", "color:orange; font-size:16px");
                   
                   // Force a verification when developer tools detected
                   verifyBalance();
               }
           }, 2000);

           // Override console methods to detect manipulation attempts
           const originalConsoleLog = console.log;
           const originalConsoleError = console.error;
           const originalConsoleWarn = console.warn;
           
           console.log = function(...args) {
               // Check for attempts to manipulate coins or bombs
               const message = args.join(' ').toLowerCase();
               if (message.includes('coin') || message.includes('balance') || 
                   message.includes('bomb') || message.includes('firebase')) {
                   // Log attempt but continue
                   originalConsoleWarn.apply(console, ["Security: Possible manipulation attempt detected"]);
               }
               return originalConsoleLog.apply(console, args);
           };
           
           // Cleanup on page unload
           window.addEventListener('unload', () => {
               clearInterval(antiDebugInterval);
           });
       })();
   </script>

   <script>
// SECURITY: Secure IIFE to isolate game variables from global scope
(function() {
    // =====================
    // SECURE CONFIGURATION
    // =====================
    
    // Secure game config with initialization through factory function
    const GAME_CONFIG = (function createGameConfig() {
        const _internal = {
            startCost: 5,            // Cost to start the game
            gameId: 'mines_game',    // ID for Firebase transactions
            maxWinnings: 1000000,    // Maximum winnings cap
            bombPenalty: 10000,      // Penalty for hitting a bomb
            maxReward: 1000000       // Maximum reward per safe square
        };
        
        // Return a locked object that can't be modified
        return Object.freeze({
            get startCost() { return _internal.startCost; },
            get gameId() { return _internal.gameId; },
            get maxWinnings() { return _internal.maxWinnings; },
            get bombPenalty() { return _internal.bombPenalty; },
            get maxReward() { return _internal.maxReward; }
        });
    })();

    // =====================
    // SECURE STATE STORAGE
    // =====================
    
    // Secure bomb storage with cryptographic protection
    const _secureGameState = (function() {
        let _bombMap = {};
        let _salt = '';
        let _bombCount = 1;
        let _integrityToken = '';
        let _signature = '';
        
        // Create a strong random salt for this game instance
        const generateSalt = () => {
            const bytes = new Uint8Array(16);
            window.crypto.getRandomValues(bytes);
            _salt = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            return _salt;
        };
        
        // Create a cryptographic hash using the salt and index
        const hashIndex = (index) => {
            // Simple hash for demo - in production, use a proper crypto library
            const str = `${_salt}-${index}-${_bombCount}-${_integrityToken}`;
            let hash = 0;
            for(let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0; // Convert to 32bit integer
            }
            return hash.toString(36);
        };
        
        // Create a tamper-proof signature for the current game state
        const createSignature = () => {
            const baseString = Object.keys(_bombMap).sort().join(':') + _salt + _bombCount;
            let signature = 0;
            for(let i = 0; i < baseString.length; i++) {
                signature = ((signature << 5) - signature) + baseString.charCodeAt(i);
                signature |= 0;
            }
            _signature = signature.toString(36);
            return _signature;
        };
        
        // Verify game integrity
        const verifyIntegrity = () => {
            const currentSignature = createSignature();
            return currentSignature === _signature;
        };
        
        // Initialize a new game with fresh cryptographic material
        const init = () => {
            _bombMap = {};
            _integrityToken = window.crypto.randomUUID();
            _salt = generateSalt();
            return _salt;
        };
        
        // Store bombs securely with encryption
        const setBombs = (bombs, count) => {
            _bombCount = count;
            _bombMap = {};
            
            // Encrypt bomb positions using one-way hash and scrambling
            bombs.forEach(index => {
                const key = hashIndex(index);
                // Create an encrypted value that can't be reverse-engineered
                const encrypted = btoa(String.fromCharCode.apply(null, 
                    new Uint8Array([
                        (index % 255) ^ (_salt.charCodeAt(0) % 255),
                        (index * 3) % 255,
                        (index * 7) % 255,
                        (_salt.charCodeAt(1) % 255)
                    ])
                ));
                _bombMap[key] = encrypted;
            });
            
            // Create tamper-proof signature
            createSignature();
        };
        
        // Check if an index is a bomb without exposing the array
        const isBomb = (index) => {
            // First verify game integrity
            if (!verifyIntegrity()) {
                console.warn("Game integrity compromised, re-randomizing bombs");
                // Emergency measure: If integrity check fails, randomize bomb placement
                const seed = performance.now().toString();
                init(); // Re-initialize encryption
                
                // Create a random bomb distribution based on the current timestamp
                const bombCount = _bombCount;
                const maxSquares = Object.keys(_bombMap).length + bombCount;
                
                // Generate new bomb positions without revealing them
                randomizeBombs(maxSquares, bombCount);
                return Math.random() < 0.5; // Return unpredictable result
            }
            
            const key = hashIndex(index);
            return _bombMap.hasOwnProperty(key);
        };
        
        // Emergency randomize function - should only be called when tampering detected
        const randomizeBombs = (totalSquares, bombCount) => {
            const newBombs = [];
            while (newBombs.length < bombCount) {
                const pos = Math.floor(Math.random() * totalSquares);
                if (!newBombs.includes(pos)) {
                    newBombs.push(pos);
                }
            }
            setBombs(newBombs, bombCount);
        };
        
        // Return only the necessary functions with no access to internal state
        return {
            init: init,
            setBombs: setBombs,
            checkBomb: isBomb,
            getBombCount: () => _bombCount,
            getIntegrity: () => verifyIntegrity()
        };
    })();

    // Secure revealed square tracker with obfuscation
    const _secureRevealState = (function() {
        const _reveals = new Map();
        let _revealCount = 0;
        let _safeRevealCount = 0;
        let _integrityValue = '';
        
        // Generate integrity value to detect tampering
        const updateIntegrity = () => {
            _integrityValue = btoa(`${_revealCount}:${_safeRevealCount}:${Date.now()}`);
        };
        
        // Validate integrity
        const checkIntegrity = () => {
            try {
                const data = atob(_integrityValue);
                const [storedCount, storedSafe] = data.split(':').map(Number);
                return storedCount === _revealCount && storedSafe === _safeRevealCount;
            } catch(e) {
                return false;
            }
        };
        
        // Record a revealed square
        const reveal = (index, isSafe) => {
            // Generate a unique key with scrambling to prevent analysis
            const key = `${Math.random().toString(36).substring(2)}_${index ^ 0x5A7D}`;
            _reveals.set(key, { i: index, s: isSafe });
            _revealCount++;
            if (isSafe) _safeRevealCount++;
            
            // Update integrity value
            updateIntegrity();
        };
        
        // Check if a square is already revealed
        const isRevealed = (index) => {
            // Verify integrity first
            if (!checkIntegrity()) {
                console.warn("Reveal state integrity compromised");
                return false;
            }
            
            // Check if this index exists in our reveals
            for (const [, value] of _reveals) {
                if (value.i === index) return true;
            }
            return false;
        };
        
        // Reset reveal state
        const reset = () => {
            _reveals.clear();
            _revealCount = 0;
            _safeRevealCount = 0;
            updateIntegrity();
        };
        
        // Return only the necessary functions
        return {
            reveal: reveal,
            isRevealed: isRevealed,
            getTotal: () => {
                if (!checkIntegrity()) return 0;
                return _revealCount;
            },
            getSafe: () => {
                if (!checkIntegrity()) return 0;
                return _safeRevealCount;
            },
            reset: reset
        };
    })();

    // =====================
    // SECURE GAME VARIABLES
    // =====================
    
    let canvas, ctx;
    let canvasWidth, canvasHeight;
    let animationFrame;
    let currentEarnings = 0;
    let gameActive = false;
    let totalSquares = 24; // Default grid size
    let _gameFrameCount = 0; // Used for timing verification

    // DOM element references
    let coinDisplay, earningsDisplay, startScreen, bombSelectScreen, gameOverScreen,
        cashoutScreen, startBtn, nextBtn, playAgainBtn, newGameBtn, backBtn, cashoutBtn,
        minesGameContainer, minesGrid, gameInfo, optionBtns, bombSlider, bombCountDisplay,
        rewardDisplay, decreaseBombBtn, increaseBombBtn;

    // =====================
    // SECURITY & ENCRYPTION
    // =====================
    
    // Generate a secure random ID
    function generateSecureId(prefix = 'el') {
        return `${prefix}_${Array.from(window.crypto.getRandomValues(new Uint8Array(8)))
            .map(b => b.toString(16).padStart(2, '0')).join('')}`;
    }

    // Encrypt data with strong obfuscation
    function encryptData(data) {
        // Add a random nonce to prevent replay
        const nonce = window.crypto.getRandomValues(new Uint8Array(8));
        const nonceStr = Array.from(nonce).map(b => String.fromCharCode(b)).join('');
        
        // Combine data with nonce and timestamp for integrity
        const payload = JSON.stringify({
            d: data,
            n: nonceStr,
            t: Date.now()
        });
        
        // Simple encryption for demo - use proper encryption in production
        return btoa(payload);
    }

    // Decrypt and validate data
    function decryptData(encrypted) {
        try {
            const payload = JSON.parse(atob(encrypted));
            
            // Check timestamp to prevent replay attacks (older than 30 min)
            const maxAge = 30 * 60 * 1000; // 30 minutes in milliseconds
            if (Date.now() - payload.t > maxAge) {
                console.warn("Encrypted data expired");
                return null;
            }
            
            return payload.d;
        } catch (e) {
            console.error("Invalid encrypted data");
            return null;
        }
    }

    // =====================
    // GAME INITIALIZATION
    // =====================
    
    // Initialize DOM elements
    function initDomElements() {
        coinDisplay = document.getElementById('coinDisplay');
        earningsDisplay = document.getElementById('earningsDisplay');
        startScreen = document.getElementById('start-screen');
        bombSelectScreen = document.getElementById('bomb-select-screen');
        gameOverScreen = document.getElementById('game-over-screen');
        cashoutScreen = document.getElementById('cashout-screen');
        startBtn = document.getElementById('start-btn');
        nextBtn = document.getElementById('next-btn');
        playAgainBtn = document.getElementById('play-again-btn');
        newGameBtn = document.getElementById('new-game-btn');
        backBtn = document.getElementById('back-btn');
        cashoutBtn = document.getElementById('cashout-btn');
        minesGameContainer = document.getElementById('mines-game-container');
        minesGrid = document.getElementById('mines-grid');
        gameInfo = document.getElementById('game-info');
        optionBtns = document.querySelectorAll('.option-btn');
        bombSlider = document.getElementById('bomb-slider');
        bombCountDisplay = document.getElementById('bomb-count-display');
        rewardDisplay = document.getElementById('reward-display');
        decreaseBombBtn = document.getElementById('decrease-bomb');
        increaseBombBtn = document.getElementById('increase-bomb');
    }

    // Update earnings display
    function updateEarningsDisplay() {
        if (earningsDisplay) {
            earningsDisplay.textContent = currentEarnings.toLocaleString();
        }
    }

    // Update coin balance securely
    function updateCoins(amount) {
        // Record transaction to Firebase (uses the global window function from Firebase IIFE)
        if (window.recordGameTransaction) {
            window.recordGameTransaction(GAME_CONFIG.gameId, amount, amount > 0);
        } else {
            console.error("Transaction recording unavailable");
        }
    }

    // Update current earnings with max winnings cap
    function updateEarnings(amount) {
        // Check if adding this amount would exceed max winnings
        if (currentEarnings + amount > GAME_CONFIG.maxWinnings) {
            // Cap at max winnings
            amount = GAME_CONFIG.maxWinnings - currentEarnings;
            
            // Update game info to indicate they've hit the max
            if (gameInfo) {
                gameInfo.textContent = `You've reached the maximum winnings of ${GAME_CONFIG.maxWinnings.toLocaleString()} coins!`;
            }
            
            // Disable further reveals once max is reached
            if (amount <= 0) {
                return;
            }
        }
        
        currentEarnings += amount;
        updateEarningsDisplay();

        // Enable cashout button once there are earnings
        if (currentEarnings > 0 && cashoutBtn) {
            cashoutBtn.disabled = false;
        }
    }

    // Initialize canvas for background
    function initCanvas() {
        canvas = document.getElementById('game-canvas');
        if (!canvas) {
            console.error("Canvas element not found!");
            return;
        }

        ctx = canvas.getContext('2d');

        const gameBoard = document.querySelector('.game-board');
        if (!gameBoard) {
            console.error("Game board element not found!");
            return;
        }

        // Get actual dimensions of the game board
        canvasWidth = gameBoard.clientWidth;
        canvasHeight = gameBoard.clientHeight;

        // Set canvas dimensions
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = canvasWidth + "px";
        canvas.style.height = canvasHeight + "px";
    }

    // =====================
    // GAME LOGIC
    // =====================
    
    // Reset bombs when tampering detected - only accessible within this IIFE
    function repositionBombs() {
        if (gameActive) {
            // Generate new bomb positions
            placeBombs();
            console.warn("Game state reset due to security violation");
        }
    }

    // Complete game reset
    function resetGame() {
        // Reset game state
        gameActive = false;
        currentEarnings = 0;
        _secureRevealState.reset();

        // Reset displays
        updateEarningsDisplay();

        // Hide game elements
        if (minesGameContainer) {
            minesGameContainer.style.display = 'none';
        }

        // Clear any existing grid
        if (minesGrid) {
            minesGrid.innerHTML = '';
        }

        // Reset cashout button
        if (cashoutBtn) {
            cashoutBtn.disabled = true;
        }

        // Show start screen
        if (startScreen) {
            startScreen.classList.add('visible');
        }
        if (bombSelectScreen) {
            bombSelectScreen.classList.remove('visible');
        }
        if (gameOverScreen) {
            gameOverScreen.classList.remove('visible');
        }
        if (cashoutScreen) {
            cashoutScreen.classList.remove('visible');
        }

        // Cancel any animation frames
        if (animationFrame) {
            window.cancelAnimationFrame(animationFrame);
        }
    }

    // Show bomb selection screen
    function showBombSelection() {
        // Hide start screen
        startScreen.classList.remove('visible');

        // Update bomb slider max value based on total squares
        const maxBombs = totalSquares - 1;
        bombSlider.max = maxBombs;
        bombSlider.value = 1;

        // Initialize secure storage with a new salt
        _secureGameState.init();
        updateBombCountDisplay();

        // Show bomb selection screen
        bombSelectScreen.classList.add('visible');
    }

    // Update bomb count display
    function updateBombCountDisplay() {
        const bombCount = parseInt(bombSlider.value);
        bombCountDisplay.textContent = `Bombs: ${bombCount}`;

        // Calculate reward per square based on bomb count
        // Using a formula that scales exponentially from 1 to 1,000,000
        const maxBombs = totalSquares - 1;
        const bombRatio = bombCount / maxBombs;
        
        // Calculate reward per square - exponential scaling
        const rewardPerSquare = Math.floor(Math.pow(GAME_CONFIG.maxReward, bombRatio));
        
        // Ensure minimum reward is 1
        const finalReward = Math.max(1, rewardPerSquare);
        
        // Format the reward display with commas for readability
        rewardDisplay.textContent = `Reward per square: ${finalReward.toLocaleString()} coins`;
    }

    // Initialize game
    function initGame() {
        // Reset for new game
        gameActive = true;
        currentEarnings = 0;
        _secureRevealState.reset();
        updateEarningsDisplay();

        // Hide bomb selection screen
        bombSelectScreen.classList.remove('visible');

        // Deduct the start cost
        updateCoins(-GAME_CONFIG.startCost);

        // Place bombs
        placeBombs();

        // Create the grid
        createMinesGrid();

        // Show game container
        if (minesGameContainer) {
            minesGameContainer.style.display = 'flex';
        }

        // Update game info
        const bombCount = _secureGameState.getBombCount();
        const rewardPerSquare = calculateRewardPerSquare(bombCount);
        
        if (gameInfo) {
            gameInfo.textContent = `Find safe squares to earn ${rewardPerSquare.toLocaleString()} coins each! Avoid the ${bombCount} bomb${bombCount > 1 ? 's' : ''}!`;
        }

        // Reset cashout button
        if (cashoutBtn) {
            cashoutBtn.disabled = true;
        }

        // Start game loop for background effects
        window.cancelAnimationFrame(animationFrame);
        gameLoop();
    }

    // Calculate reward per square
    function calculateRewardPerSquare(bombCount) {
        const maxBombs = totalSquares - 1;
        const bombRatio = bombCount / maxBombs;
        
        // Calculate reward per square - exponential scaling
        const rewardPerSquare = Math.floor(Math.pow(GAME_CONFIG.maxReward, bombRatio));
        
        // Ensure minimum reward is 1
        return Math.max(1, rewardPerSquare);
    }

    // Place bombs with cryptographic security
    function placeBombs() {
        const bombCount = parseInt(bombSlider.value);
        
        // Generate bomb positions using cryptographically secure random
        const positions = new Set();
        
        // Generate unique positions using window.crypto
        while (positions.size < bombCount) {
            // Use crypto-secure random number generation
            const bytes = new Uint8Array(4);
            window.crypto.getRandomValues(bytes);
            
            // Convert to a number between 0 and totalSquares-1
            const randomValue = new DataView(bytes.buffer).getUint32(0) % totalSquares;
            positions.add(randomValue);
        }
        
        // Convert to array
        const bombIndices = Array.from(positions);
        
        // Store bombs in secure storage
        _secureGameState.setBombs(bombIndices, bombCount);
    }

    // Create the mines grid with secure cell identifiers
    function createMinesGrid() {
        if (!minesGrid) {
            console.error("Mines grid element not found!");
            return;
        }

        // Clear any existing grid
        minesGrid.innerHTML = '';

        // Set appropriate class for grid size
        minesGrid.className = `mines-grid grid-${totalSquares}`;

        // Generate a unique nonce for this game with strong entropy
        const gameNonce = window.crypto.randomUUID();

        // Create cells with secure, encrypted identifiers
        for (let i = 0; i < totalSquares; i++) {
            const cell = document.createElement('div');
            
            // Generate a cryptographically secure random ID for each cell
            const cellId = generateSecureId('cell');
            cell.id = cellId;
            
            cell.className = 'mine-cell';
            
            // Use a simpler data attribute approach that works better
            const dataKey = `data-cell-${gameNonce.substring(0, 8)}`;
            cell.setAttribute(dataKey, i);
            
            // Add a nonce attribute for verification
            cell.setAttribute('data-nonce', gameNonce);
            
            // Add click handling with bind to maintain context
            cell.onclick = function(event) {
                handleCellClick(event, gameNonce);
            };

            // Add touch events for mobile
            cell.addEventListener('touchstart', function(event) {
                event.preventDefault(); // Prevent zoom/scroll on touch
                handleCellClick(event, gameNonce);
            }, { passive: false });

            minesGrid.appendChild(cell);
        }
    }

    // Handle cell click with secure verification
    function handleCellClick(event, gameNonce) {
        // Prevent event bubbling
        event.stopPropagation();

        if (!gameActive) {
            return;
        }

        // Get the cell that was clicked
        const cell = event.currentTarget;

        if (!cell) {
            return;
        }
        
        // Verify the nonce matches to prevent replay attacks
        const cellNonce = cell.getAttribute('data-nonce');
        if (cellNonce !== gameNonce) {
            console.warn("Cell nonce mismatch - possible tampering");
            return;
        }
        
        // Get the index directly using the simpler approach
        const dataKey = `data-cell-${gameNonce.substring(0, 8)}`;
        const indexStr = cell.getAttribute(dataKey);
        
        if (!indexStr) {
            console.warn("Cell index not found");
            return;
        }
        
        const index = parseInt(indexStr);
        
        // Basic validation
        if (isNaN(index) || index < 0 || index >= totalSquares) {
            console.warn("Invalid cell index");
            return;
        }

        // Check if already revealed
        if (_secureRevealState.isRevealed(index)) {
            return;
        }

        // Check if bomb using secure check
        const isBomb = _secureGameState.checkBomb(index);
        
        // Mark as revealed
        _secureRevealState.reveal(index, !isBomb);

        if (isBomb) {
            // Hit a bomb!
            cell.classList.add('revealed-bomb');
            cell.innerHTML = '<span class="bomb-icon"></span>';

            // Apply bomb penalty
            updateCoins(-GAME_CONFIG.bombPenalty);
            
            // Update game info
            if (gameInfo) {
                gameInfo.textContent = `You hit a bomb! ${GAME_CONFIG.bombPenalty.toLocaleString()} coins penalty applied.`;
            }

            // Reveal all other bombs with a delay
            revealAllBombs(cell, gameNonce);

            // Game over
            gameActive = false;

            // Show game over with delay
            setTimeout(() => {
                showGameOver();
            }, 1500); // Longer delay to show all bombs
        } else {
            // Safe square
            cell.classList.add('revealed-safe');
            cell.innerHTML = '<span class="coin-icon-cell"></span>';
            
            // Award coins based on the calculated reward (with max cap)
            const bombCount = _secureGameState.getBombCount();
            const rewardPerSquare = calculateRewardPerSquare(bombCount);
            updateEarnings(rewardPerSquare);

            // Enable cashout if there are earnings
            if (currentEarnings > 0 && cashoutBtn) {
                cashoutBtn.disabled = false;
            }
            
            // Check if reached max winnings
            if (currentEarnings >= GAME_CONFIG.maxWinnings) {
                // Encourage player to cash out
                if (gameInfo) {
                    gameInfo.textContent = `Maximum winnings reached! Cash out now to collect ${GAME_CONFIG.maxWinnings.toLocaleString()} coins!`;
                }
            }
        }
    }

    // Reveal all bombs securely
    function revealAllBombs(hitCell, gameNonce) {
        // Get all cells
        const cells = document.querySelectorAll('.mine-cell');
        
        // Reveal bombs one by one with delay
        cells.forEach((cell) => {
            if (cell === hitCell) return; // Skip the bomb that was already hit

            // Use the simpler approach to get cell index
            const dataKey = `data-cell-${gameNonce.substring(0, 8)}`;
            const indexStr = cell.getAttribute(dataKey);
            
            if (!indexStr) return;
            const index = parseInt(indexStr);
            
            if (isNaN(index)) return;
            
            // Check if it's a bomb
            if (_secureGameState.checkBomb(index)) {
                setTimeout(() => {
                    cell.classList.add('revealed-bomb');
                    cell.innerHTML = '<span style="font-size: 20px"></span>';
                }, 200 + Math.random() * 300);
            }
        });
    }

    // Show game over screen
    function showGameOver() {
        // Update game over screen details
        const revealedCountEl = document.getElementById('revealed-count');
        const lostEarningsEl = document.getElementById('lost-earnings');

        if (revealedCountEl) {
            revealedCountEl.textContent = _secureRevealState.getSafe().toString();
        }

        if (lostEarningsEl) {
            // Show both the potential earnings and the bomb penalty
            lostEarningsEl.textContent = `${currentEarnings.toLocaleString()} + ${GAME_CONFIG.bombPenalty.toLocaleString()} bomb penalty`;
        }

        // Show game over screen
        if (gameOverScreen) {
            gameOverScreen.classList.add('visible');
        }
    }

    // Show cashout screen with secure transaction
    function showCashoutScreen() {
        // Update cashout screen details
        const cashoutCountEl = document.getElementById('cashout-count');
        const cashoutRewardEl = document.getElementById('cashout-reward');

        if (cashoutCountEl) {
            cashoutCountEl.textContent = _secureRevealState.getSafe().toString();
        }

        if (cashoutRewardEl) {
            cashoutRewardEl.textContent = currentEarnings.toLocaleString();
        }

        // Add the earnings to the balance with secure transaction
        const winnings = currentEarnings;
        updateCoins(winnings);

        // Reset current earnings
        currentEarnings = 0;
        updateEarningsDisplay();

        // Show cashout screen
        if (cashoutScreen) {
            cashoutScreen.classList.add('visible');
        }

        // End the game
        gameActive = false;
    }

    // Draw stars in background
    function drawStars() {
        if (!ctx || !canvas) return;

        // Clear canvas
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = '#FFFFFF';

        // Track frame count for animation and security verification
        _gameFrameCount++;

        for (let i = 0; i < 100; i++) {
            // Create a deterministic but varied star pattern
            const seed = (i * 12437 + _gameFrameCount) % 1000000; // Add frame count for animation
            const x = (seed % canvasWidth) % canvasWidth;
            const y = ((seed * 23) % canvasHeight) % canvasHeight;

            // Vary the star sizes
            const size = (i % 3) + 1;

            // Make stars twinkle
            const alpha = 0.3 + 0.7 * Math.sin(Date.now() * 0.001 + i);

            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.globalAlpha = 1.0;
    }

    // Game loop with security checks
    function gameLoop() {
        // Security check every 100 frames
        if (_gameFrameCount % 100 === 0) {
            // Verify game integrity
            if (gameActive && !_secureGameState.getIntegrity()) {
                console.warn("Game integrity check failed - resetting game state");
                repositionBombs();
            }
        }
        
        // Draw background
        drawStars();

        // Continue game loop
        animationFrame = requestAnimationFrame(gameLoop);
    }

    // Setup event listeners
    function setupEventListeners() {
        // Next button (after grid size selection)
        nextBtn.addEventListener('click', function() {
            showBombSelection();
        });

        // Start button (after bomb selection)
        startBtn.addEventListener('click', function() {
            if (window.coinBalance < GAME_CONFIG.startCost) {
                alert("You need at least 5 coins to play!");
                return;
            }

            initGame();
        });

        // Play again button
        playAgainBtn.addEventListener('click', function() {
            if (gameOverScreen) gameOverScreen.classList.remove('visible');
            resetGame();
        });

        // New game button
        newGameBtn.addEventListener('click', function() {
            if (cashoutScreen) cashoutScreen.classList.remove('visible');
            resetGame();
        });

        // Back button
        backBtn.addEventListener('click', function() {
            window.location.href = '/voidgms.html';
        });

        // Cashout button
        cashoutBtn.addEventListener('click', function() {
            if (gameActive && !cashoutBtn.disabled && currentEarnings > 0) {
                showCashoutScreen();
            }
        });

        // Grid size option buttons
        optionBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                // Get grid size and base reward from data attributes
                const squares = parseInt(btn.dataset.squares);
                
                // Remove selected class from all buttons
                optionBtns.forEach(b => b.classList.remove('selected'));

                // Add selected class to clicked button
                btn.classList.add('selected');

                // Update total squares
                totalSquares = squares;
            });
        });

        // Bomb slider
        bombSlider.addEventListener('input', function() {
            updateBombCountDisplay();
        });

        // Bomb count buttons
        decreaseBombBtn.addEventListener('click', function() {
            if (parseInt(bombSlider.value) > 1) {
                bombSlider.value = parseInt(bombSlider.value) - 1;
                updateBombCountDisplay();
            }
        });

        increaseBombBtn.addEventListener('click', function() {
            const maxBombs = totalSquares - 1;
            if (parseInt(bombSlider.value) < maxBombs) {
                bombSlider.value = parseInt(bombSlider.value) + 1;
                updateBombCountDisplay();
            }
        });

        // Add resize event listener
        window.addEventListener('resize', function() {
            initCanvas();
            if (gameActive) {
                drawStars();
            }
        });
        
        // Prevent right-click menu to stop cell inspection
        document.addEventListener('contextmenu', function(e) {
            if (gameActive && e.target.classList.contains('mine-cell')) {
                e.preventDefault();
                return false;
            }
        });
    }

    // =====================
    // ANTI-CHEAT MEASURES
    // =====================
    
    // Protect against debugger tricks and tampering
    function initSecurityMeasures() {
        // Override JSON.stringify to hide bomb information
        const origStringify = JSON.stringify;
        JSON.stringify = function(obj) {
            // Clone the object to avoid modifying the original
            if (obj && typeof obj === 'object') {
                // Check if this looks like our game state
                if ((obj.hasOwnProperty('bombIndices') || obj._bombMap) ||
                    (typeof obj === 'object' && obj.constructor && 
                     obj.constructor.name === 'Array' && 
                     obj.some(i => i.toString().includes('bomb')))) {
                    return origStringify({});
                }
            }
            
            return origStringify.apply(this, arguments);
        };
        
        // Anti-devtools detection
        const interval = setInterval(function() {
            const startTime = performance.now();
            const div = document.createElement('div');
            
            // Perform some complex DOM operations that are slower when dev tools are open
            for (let i = 0; i < 100; i++) {
                div.style.backgroundColor = `rgb(${i}, ${i}, ${i})`;
                div.style.width = `${10 + i}px`;
                div.style.height = `${5 + i}px`;
                const computed = window.getComputedStyle(div).backgroundColor;
            }
            
            const delay = performance.now() - startTime;
            
            // If this takes too long, debugger or dev tools might be active
            if (delay > 100) {
                console.log("%cDeveloper tools detected", "color:red; font-size:20px;");
                
                // Anti-cheat measure: Reset game state if active
                if (gameActive) {
                    repositionBombs();
                }
            }
        }, 2000);
        
        // Clean up on unload
        window.addEventListener('unload', () => {
            clearInterval(interval);
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
        });
        
        // Protect against function modification
        const protectedFunctions = [
            updateCoins, updateEarnings, placeBombs, calculateRewardPerSquare,
            handleCellClick, showCashoutScreen
        ];
        
        protectedFunctions.forEach(fn => {
            const original = fn.toString();
            Object.defineProperty(fn, 'toString', {
                value: function() {
                    return original;
                },
                writable: false,
                configurable: false
            });
        });
        
        // Expose one function for emergency reset when tampering detected
        window._rp = repositionBombs;
    }

    // =====================
    // INITIALIZATION
    // =====================
    
    // Initialize game after DOM is fully loaded
    function initializeGame() {
        // Initialize DOM elements
        initDomElements();

        // Initialize canvas
        initCanvas();

        // Setup security measures
        initSecurityMeasures();

        // Setup event listeners
        setupEventListeners();

        // Initial reset
        resetGame();
    }

    // Initialize when DOM is fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        initializeGame();
    });
})();
   </script>
</body>
</html>
