<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Mission Uncrossable</title>
   
   <style>
       body, html {
           margin: 0;
           padding: 0;
           width: 100%;
           height: 100%;
           background: #000;
           color: #fff;
           font-family: 'Arial', sans-serif;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
       }

       .game-container {
           background: linear-gradient(180deg, #000000, #151530, #0a0a24);
           border-radius: 10px;
           width: 90%;
           max-width: 800px;
           height: 90vh;
           max-height: 800px;
           display: flex;
           flex-direction: column;
           position: relative;
           padding: 1rem;
           box-shadow: 
               0 0 2px #fff,
               0 0 4px #fff,
               0 0 6px #4d7cff,
               0 0 8px #4d7cff,
               inset 0 0 2px rgba(255, 255, 255, 0.2);
           z-index: 3;
           overflow: hidden;
       }

       .game-container::before {
           content: '';
           position: absolute;
           inset: -1px;
           background: transparent;
           border-radius: 10px;
           z-index: -1;
           box-shadow: 
               0 0 15px #fff,
               0 0 30px rgba(77, 124, 255, 0.8),
               0 0 40px rgba(77, 124, 255, 0.6),
               0 0 50px rgba(77, 124, 255, 0.4);
           opacity: 0.5;
           animation: pulse 3s infinite alternate;
       }

       @keyframes pulse {
           0% { opacity: 0.4; }
           100% { opacity: 0.7; }
       }

       .game-header {
           text-align: center;
           padding-bottom: 1rem;
           border-bottom: 1px solid rgba(77, 124, 255, 0.2);
           position: relative;
           background: linear-gradient(90deg, transparent, rgba(77, 124, 255, 0.05), transparent);
       }

       .game-title {
           font-size: 2.2rem;
           margin: 0 0 0.5rem 0;
           background: linear-gradient(45deg, #fff, #4d7cff);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           font-weight: bold;
           text-transform: uppercase;
           letter-spacing: 3px;
           text-shadow: 0 0 10px rgba(77, 124, 255, 0.7);
           animation: titleGlow 2s infinite alternate;
       }

       @keyframes titleGlow {
           0% { text-shadow: 0 0 5px rgba(77, 124, 255, 0.7); }
           100% { text-shadow: 0 0 15px rgba(77, 124, 255, 0.9), 0 0 30px rgba(77, 124, 255, 0.5); }
       }

       .game-subtitle {
           font-size: 1rem;
           color: #aac4ff;
           margin: 0;
           text-transform: uppercase;
           letter-spacing: 2px;
           opacity: 0.8;
       }

       .coin-tracker {
           position: absolute;
           top: 0;
           right: 0;
           background: linear-gradient(135deg, rgba(77, 124, 255, 0.1), rgba(20, 30, 60, 0.5));
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           padding: 0.5rem 1rem;
           display: flex;
           align-items: center;
           gap: 0.5rem;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.3);
           animation: glow 2s infinite;
           backdrop-filter: blur(5px);
       }

       .coin-icon {
           width: 20px;
           height: 20px;
           background: linear-gradient(135deg, #FFD700, #FFA500);
           border-radius: 50%;
           box-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
           position: relative;
           overflow: hidden;
       }

       .coin-icon::after {
           content: '';
           position: absolute;
           top: 3px;
           left: 3px;
           width: 6px;
           height: 6px;
           background: rgba(255, 255, 255, 0.8);
           border-radius: 50%;
       }

       .coin-amount {
           font-weight: bold;
           font-size: 1.1rem;
           color: #FFD700;
           text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
       }

       .game-board {
           flex-grow: 1;
           position: relative;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           background: linear-gradient(to bottom, #000b1e, #001133);
           border-radius: 8px;
           margin: 1rem 0;
           min-height: 60vh;
           border: 1px solid rgba(77, 124, 255, 0.2);
           box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
       }

       #game-canvas {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: transparent;
           z-index: 1;
           display: block;
       }

       .game-overlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           background: rgba(0, 8, 30, 0.85);
           z-index: 10;
           opacity: 0;
           pointer-events: none;
           transition: opacity 0.3s ease;
           backdrop-filter: blur(4px);
       }

       .game-overlay.visible {
           opacity: 1;
           pointer-events: all;
           animation: fadeIn 0.5s ease-out;
       }

       @keyframes fadeIn {
           from { opacity: 0; }
           to { opacity: 1; }
       }

       .overlay-content {
           text-align: center;
           padding: 2.5rem;
           background: linear-gradient(135deg, rgba(13, 21, 40, 0.9), rgba(5, 10, 30, 0.9));
           border-radius: 10px;
           border: 1px solid rgba(77, 124, 255, 0.3);
           box-shadow: 0 0 30px rgba(77, 124, 255, 0.2);
           max-width: 80%;
           animation: floatEffect 4s infinite ease-in-out;
       }

       @keyframes floatEffect {
           0%, 100% { transform: translateY(0); }
           50% { transform: translateY(-10px); }
       }

       .overlay-title {
           font-size: 2.5rem;
           margin-bottom: 1rem;
           text-transform: uppercase;
           letter-spacing: 3px;
           font-weight: bold;
       }

       .overlay-title.win {
           background: linear-gradient(45deg, #4CAF50, #8BC34A);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
       }

       .overlay-title.lose {
           background: linear-gradient(45deg, #f44336, #E91E63);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
       }

       .overlay-message {
           font-size: 1.2rem;
           margin-bottom: 2rem;
           color: #aac4ff;
           line-height: 1.6;
       }

       .controls {
           display: flex;
           justify-content: center;
           align-items: center;
           padding: 1rem 0;
           gap: 1rem;
       }

       .game-btn {
           padding: 0.75rem 2rem;
           font-size: 1.2rem;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           color: #fff;
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           cursor: pointer;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.2);
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 2px;
           font-weight: bold;
           position: relative;
           overflow: hidden;
       }

       .game-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
           transition: all 0.6s ease;
       }

       .game-btn:hover::before {
           left: 100%;
       }

       .game-btn:hover {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: translateY(-2px);
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.3);
       }

       .game-btn:active {
           transform: translateY(1px);
       }

       .game-btn:disabled {
           opacity: 0.5;
           cursor: not-allowed;
           background: linear-gradient(135deg, #444, #333);
       }
       
       .game-btn.insufficient {
           background: linear-gradient(135deg, #70283f, #350f1a);
           color: #ffcccc;
           border-color: rgba(244, 67, 54, 0.4);
       }
       
       .game-btn.cashout {
           background: linear-gradient(135deg, #388E3C, #1B5E20);
           border-color: rgba(76, 175, 80, 0.6);
           color: #FFFFFF;
           animation: pulseGreen 1.5s infinite;
       }
       
       @keyframes pulseGreen {
           0% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.7); }
           50% { box-shadow: 0 0 15px rgba(76, 175, 80, 0.9); }
           100% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.7); }
       }

       .restart-btn {
           padding: 0.75rem 1.5rem;
           font-size: 1rem;
           background: linear-gradient(135deg, #192238, #0d1526);
           color: #aac4ff;
           border: 1px solid rgba(77, 124, 255, 0.2);
           border-radius: 30px;
           cursor: pointer;
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 1px;
           position: relative;
           overflow: hidden;
       }

       .restart-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
           transition: all 0.6s ease;
       }

       .restart-btn:hover::before {
           left: 100%;
       }

       .restart-btn:hover {
           color: #fff;
           border-color: rgba(77, 124, 255, 0.4);
           background: linear-gradient(135deg, #243252, #131e36);
       }

       .score-display {
           text-align: center;
           margin-top: 1rem;
           font-size: 1.2rem;
           height: 1.5rem;
           color: #aac4ff;
           text-shadow: 0 0 5px rgba(77, 124, 255, 0.5);
           background: linear-gradient(90deg, transparent, rgba(77, 124, 255, 0.05), transparent);
           padding: 0.2rem 0;
           border-radius: 20px;
       }

       .win-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #4caf50;
           text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
       }

       .lose-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #f44336;
           text-shadow: 0 0 5px rgba(244, 67, 54, 0.5);
       }

       .back-link {
           margin-top: 1rem;
           color: rgba(255, 255, 255, 0.7);
           text-decoration: none;
           font-size: 0.9rem;
           transition: color 0.3s ease;
       }

       .back-link:hover {
           color: #fff;
           text-decoration: underline;
       }

       .controls-info {
           position: absolute;
           bottom: 10px;
           left: 50%;
           transform: translateX(-50%);
           font-size: 0.9rem;
           color: rgba(170, 196, 255, 0.7);
           text-align: center;
           padding: 5px 15px;
           background: rgba(10, 20, 40, 0.6);
           border-radius: 20px;
           border: 1px solid rgba(77, 124, 255, 0.2);
           backdrop-filter: blur(3px);
           animation: fadeInOut 3s infinite alternate;
       }

       @keyframes fadeInOut {
           0% { opacity: 0.5; }
           100% { opacity: 0.9; }
       }

       /* Multiplier bar replaces progress bar */
       .multiplier-display {
           position: absolute;
           top: 10px;
           left: 10px;
           background: rgba(15, 30, 60, 0.6);
           padding: 10px 15px;
           border-radius: 10px;
           border: 1px solid rgba(77, 124, 255, 0.3);
           color: #fff;
           font-size: 1.3rem;
           font-weight: bold;
           z-index: 5;
           text-align: center;
           min-width: 80px;
       }
       
       .current-multiplier {
           font-size: 1.8rem;
           color: #4CAF50;
           text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
           margin-bottom: 4px;
           display: block;
       }
       
       .next-multiplier {
           font-size: 0.9rem;
           color: #aac4ff;
           opacity: 0.8;
       }

       .bet-display {
           position: absolute;
           top: 10px;
           right: 10px;
           background: rgba(15, 30, 60, 0.6);
           padding: 10px;
           border-radius: 10px;
           border: 1px solid rgba(77, 124, 255, 0.3);
           color: #fff;
           font-size: 0.9rem;
           z-index: 5;
       }
       
       .bet-amount {
           font-size: 1.3rem;
           color: #FFD700;
           font-weight: bold;
           display: block;
           margin-bottom: 2px;
       }
       
       .potential-win {
           color: #4CAF50;
           font-weight: bold;
       }

       .difficulty-indicator {
           position: absolute;
           top: 10px;
           right: 50%;
           transform: translateX(50%);
           padding: 5px 15px;
           border-radius: 20px;
           background: rgba(15, 30, 60, 0.6);
           color: #aac4ff;
           font-size: 0.9rem;
           border: 1px solid rgba(77, 124, 255, 0.3);
           transition: all 0.3s ease;
           opacity: 0.8;
       }
       
       /* Cash out button that appears during gameplay */
       .cashout-container {
           position: absolute;
           bottom: 15px;
           right: 15px;
           z-index: 5;
       }
       
       /* Bet controls for start screen */
       .bet-controls {
           display: flex;
           align-items: center;
           justify-content: center;
           gap: 15px;
           margin: 15px 0;
       }
       
       .bet-btn {
           width: 35px;
           height: 35px;
           border-radius: 50%;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           border: 1px solid rgba(77, 124, 255, 0.4);
           color: white;
           font-size: 1.2rem;
           display: flex;
           align-items: center;
           justify-content: center;
           cursor: pointer;
           transition: all 0.2s ease;
       }
       
       .bet-btn:hover {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: scale(1.1);
       }
       
       .bet-input {
           width: 100px;
           padding: 8px;
           text-align: center;
           background: rgba(10, 20, 40, 0.6);
           border: 1px solid rgba(77, 124, 255, 0.3);
           border-radius: 5px;
           color: #FFD700;
           font-size: 1.2rem;
           font-weight: bold;
       }
       
       .bet-input:focus {
           outline: none;
           border-color: rgba(77, 124, 255, 0.7);
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.3);
       }
       
       /* Quick bet buttons */
       .quick-bets {
           display: flex;
           justify-content: center;
           gap: 10px;
           margin-top: 10px;
       }
       
       .quick-bet {
           padding: 5px 10px;
           background: rgba(15, 30, 60, 0.6);
           border: 1px solid rgba(77, 124, 255, 0.3);
           border-radius: 5px;
           color: #aac4ff;
           cursor: pointer;
           transition: all 0.2s ease;
       }
       
       .quick-bet:hover {
           background: rgba(30, 60, 120, 0.6);
           color: white;
       }
       
       /* Animation for multiplier increase */
       @keyframes multiplierUp {
           0% { transform: scale(1); }
           50% { transform: scale(1.2); color: #4CAF50; }
           100% { transform: scale(1); }
       }
       
       .multiplier-increase {
           animation: multiplierUp 0.3s ease-out;
       }
       
       /* Animation for cashout win */
       @keyframes winPulse {
           0% { transform: scale(1); }
           50% { transform: scale(1.2); }
           100% { transform: scale(1); }
       }

       @media (max-width: 768px) {
           .game-container {
               width: 95%;
               height: 80vh;
           }
           
           .game-title {
               font-size: 1.7rem;
           }
           
           .game-btn, .restart-btn {
               padding: 0.6rem 1.5rem;
               font-size: 1rem;
           }

           .coin-tracker {
               padding: 0.3rem 0.8rem;
           }

           .coin-icon {
               width: 16px;
               height: 16px;
           }

           .coin-amount {
               font-size: 0.9rem;
           }
           
           .overlay-content {
               padding: 1.5rem;
           }
           
           .overlay-title {
               font-size: 2rem;
           }
           
           .multiplier-display, .bet-display {
               padding: 5px 10px;
               font-size: 0.8rem;
           }
           
           .current-multiplier {
               font-size: 1.4rem;
           }
       }

       /* Special Effects */
       @keyframes glow {
           0% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
           50% { filter: drop-shadow(0 0 10px rgba(77, 124, 255, 0.9)); }
           100% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
       }
       
       /* Particle effect */
       .particle {
           position: absolute;
           background: rgba(77, 124, 255, 0.5);
           border-radius: 50%;
           pointer-events: none;
           z-index: 0;
       }
       
       /* Hash display for provably fair */
       .hash-display {
           font-size: 0.8rem;
           opacity: 0.6;
           color: #aac4ff;
           margin-top: 10px;
           word-break: break-all;
           max-width: 300px;
           margin: 10px auto;
       }
   </style>
</head>

<body>
   <div class="game-container">
       <div class="game-header">
           <h1 class="game-title">Mission Uncrossable</h1>
           <p class="game-subtitle">Cross roads and cash out before you crash!</p>
           <div class="coin-tracker">
               <div class="coin-icon"></div>
               <span class="coin-amount" id="coinDisplay">1000</span>
           </div>
       </div>
       
       <div class="game-board">
           <canvas id="game-canvas"></canvas>
           <div class="controls-info">Use arrow keys or WASD to move</div>
           
           <!-- Multiplier Display -->
           <div class="multiplier-display" id="multiplier-display">
              <span class="current-multiplier" id="current-multiplier">1.00x</span>
              <span class="next-multiplier" id="next-multiplier">Next: 1.20x</span>
           </div>
           
           <!-- Bet Display -->
           <div class="bet-display" id="bet-display">
              <span class="bet-amount" id="current-bet">5.00</span>
              <span class="potential-win" id="potential-win">Win: 5.00</span>
           </div>
           
           <!-- Difficulty Indicator -->
           <div class="difficulty-indicator" id="difficulty-indicator">Easy</div>
           
           <!-- Cash Out Button (shows during gameplay) -->
           <div class="cashout-container" id="cashout-container" style="display: none;">
               <button id="cashout-btn" class="game-btn cashout">CASH OUT</button>
           </div>
           
           <!-- Start Screen Overlay -->
           <div class="game-overlay visible" id="start-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title">Mission Uncrossable</h2>
                   <p class="overlay-message">Set your bet and cross as many roads as you can.<br>Cash out anytime to secure your winnings!<br><span style="font-size: 0.9em; opacity: 0.8;">Each road increases your multiplier!</span></p>
                   
                   <!-- Bet controls -->
                   <div class="bet-controls">
                       <div class="bet-btn" id="decrease-bet">-</div>
                       <input type="text" class="bet-input" id="bet-input" value="5.00">
                       <div class="bet-btn" id="increase-bet">+</div>
                   </div>
                   
                   <!-- Quick bet buttons -->
                   <div class="quick-bets">
                       <div class="quick-bet" data-value="1">1</div>
                       <div class="quick-bet" data-value="5">5</div>
                       <div class="quick-bet" data-value="10">10</div>
                       <div class="quick-bet" data-value="25">25</div>
                       <div class="quick-bet" data-value="100">100</div>
                   </div>
                   
                   <button id="start-btn" class="game-btn">Start Game</button>
                   
                   <!-- Hash for provably fair -->
                   <div class="hash-display" id="game-hash">
                       Game Hash: 7a8bc9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6
                   </div>
               </div>
           </div>
           
           <!-- Game Over Overlay -->
           <div class="game-overlay" id="game-over-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title lose">Crashed!</h2>
                   <p class="overlay-message">You got hit by a car!<br>Lost: <span class="lose-amount" id="lost-amount">5.00</span><br>You reached <span id="final-level">0</span> roads with <span id="final-multiplier">1.00x</span></p>
                   <button id="restart-btn" class="game-btn">Play Again</button>
                   
                   <!-- Hash verification -->
                   <div class="hash-display" id="verify-hash">
                       Verify: 7a8bc9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6
                   </div>
               </div>
           </div>
           
           <!-- Win/Cashout Overlay -->
           <div class="game-overlay" id="win-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title win">Cash Out Success!</h2>
                   <p class="overlay-message">You cashed out at <span id="cashout-multiplier">2.35x</span>!<br>Won: <span class="win-amount" id="win-amount">11.75</span><br>Crossed <span id="roads-crossed">12</span> roads safely!</p>
                   <button id="continue-btn" class="game-btn">Play Again</button>
               </div>
           </div>
       </div>
       
       <div class="score-display" id="scoreDisplay">Multiplier: 1.00x</div>
       
       <div class="controls">
           <button id="back-btn" class="restart-btn">Back to Games</button>
       </div>
   </div>
   
   <script>
// Game Configuration
const GAME_CONFIG = {
    minBet: 1,            // Minimum bet amount
    maxBet: 1000,         // Maximum bet amount
    playerSize: 20,       // Size of player square
    roadHeight: 60,       // Height of each road
    safeZoneHeight: 60,   // Height of safe zones between roads
    carMinSpeed: 3,       // Minimum car speed
    carMaxSpeed: 15,      // Maximum car speed
    carWidth: 60,         // Width of cars
    carHeight: 30,        // Height of cars
    carSpawnRate: 0.018,  // Chance of car spawning each frame
    maxRoads: 100,        // Maximum roads (theoretical)
    maxMultiplier: 100,   // Maximum multiplier
    difficultyScaling: 0.20, // Higher difficulty scaling per road
    obstacleRate: 0.3     // Chance of obstacles in safe zones
};

// Multiplier Configuration
const MULTIPLIER_CONFIG = {
    base: 1,              // Starting multiplier
    increment: [          // Multiplier increments at different stages
        { threshold: 0, value: 0.05 },    // 0-4 roads: +0.05 per road
        { threshold: 5, value: 0.10 },    // 5-14 roads: +0.10 per road
        { threshold: 15, value: 0.15 },   // 15-24 roads: +0.15 per road
        { threshold: 25, value: 0.20 },   // 25-49 roads: +0.20 per road
        { threshold: 50, value: 0.50 },   // 50-74 roads: +0.50 per road
        { threshold: 75, value: 1.00 }    // 75+ roads: +1.00 per road
    ]
};

// Game state variables
let canvas, ctx;
let canvasWidth, canvasHeight;
let player = null;
let roads = [];
let cars = [];
let obstacles = [];
let gameActive = false;
let currentLevel = 0;
let gameOver = false;
let gameWon = false;
let coinBalance = 1000; // Starting balance
let currentBet = 5.00;
let currentMultiplier = MULTIPLIER_CONFIG.base;
let nextMultiplier = 0;
let gameHash = "";
let animationFrame;
let keysPressed = {};

// DOM elements - will be initialized in the init function
let startScreen, gameOverScreen, winScreen;
let coinDisplay, scoreDisplay;
let startBtn, restartBtn, continueBtn, cashoutBtn, backBtn;
let betInput, increaseBetBtn, decreaseBetBtn;
let cashoutContainer;
let currentMultiplierDisplay, nextMultiplierDisplay;
let currentBetDisplay, potentialWinDisplay;
let quickBets = [];

// Generator for game hash
function generateGameHash() {
    const characters = '0123456789abcdef';
    let hash = '';
    for (let i = 0; i < 40; i++) {
        hash += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return hash;
}

// Initialize canvas
function initCanvas() {
    canvas = document.getElementById('game-canvas');
    if (!canvas) {
        console.error("Canvas element not found!");
        return;
    }
    
    ctx = canvas.getContext('2d');
    
    const gameBoard = document.querySelector('.game-board');
    if (!gameBoard) {
        console.error("Game board element not found!");
        return;
    }
    
    // Get actual dimensions of the game board
    canvasWidth = gameBoard.clientWidth;
    canvasHeight = gameBoard.clientHeight;
    
    console.log("Setting canvas dimensions:", canvasWidth, "x", canvasHeight);
    
    // Set canvas dimensions
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = canvasWidth + "px";
    canvas.style.height = canvasHeight + "px";
}

// Initialize game for play
function initGame() {
    console.log("Initializing game...");
    
    // Get current bet from input
    currentBet = parseFloat(betInput.value);
    if (isNaN(currentBet) || currentBet < GAME_CONFIG.minBet) {
        currentBet = GAME_CONFIG.minBet;
        betInput.value = currentBet.toFixed(2);
    } else if (currentBet > GAME_CONFIG.maxBet) {
        currentBet = GAME_CONFIG.maxBet;
        betInput.value = currentBet.toFixed(2);
    }

    // Deduct the bet amount
    updateCoins(-currentBet);
    
    // Reset multiplier
    currentMultiplier = MULTIPLIER_CONFIG.base;
    
    // Generate new game hash
    gameHash = generateGameHash();
    document.getElementById('game-hash').textContent = `Game Hash: ${gameHash}`;
    document.getElementById('verify-hash').textContent = `Verify: ${gameHash}`;
    
    // Set up player
    player = {
        x: canvasWidth / 2 - GAME_CONFIG.playerSize / 2,
        y: canvasHeight - GAME_CONFIG.playerSize - 20,
        width: GAME_CONFIG.playerSize,
        height: GAME_CONFIG.playerSize,
        speed: 5,
        color: '#4CAF50',
        trail: [], // Add trail for visual effect
        lives: 1   // Player only has one life
    };
    
    // Generate roads and safe zones
    roads = [];
    cars = [];
    obstacles = []; // Reset obstacles array
    currentLevel = 0;
    
    // Create road layouts
    const totalHeight = canvasHeight;
    const roadAndSafeZoneHeight = GAME_CONFIG.roadHeight + GAME_CONFIG.safeZoneHeight;
    const numRoadSections = Math.floor(totalHeight / roadAndSafeZoneHeight) + 10; // Add extra roads beyond view
    
    // Player starts at the bottom in a safe zone
    let yPosition = canvasHeight - GAME_CONFIG.safeZoneHeight;
    
    // Create roads from bottom to top
    for (let i = 0; i < numRoadSections; i++) {
        // Add a road
        const roadType = Math.floor(Math.random() * 3); // 0: normal, 1: highway, 2: city
        const laneCount = Math.floor(Math.random() * 3) + 1; // 1-3 lanes
        
        // Higher roads have more lanes and higher speeds
        const levelFactor = 1 + (i * 0.05);
        const adjustedLaneCount = Math.min(3, Math.floor(laneCount * levelFactor));
        
        // Base speed increases with level
        const baseSpeedMin = GAME_CONFIG.carMinSpeed * (1 + (i * 0.02));
        const baseSpeedMax = GAME_CONFIG.carMinSpeed + 
            (GAME_CONFIG.carMaxSpeed - GAME_CONFIG.carMinSpeed) * 
            Math.min(1, i / (GAME_CONFIG.maxRoads * 0.7)); // Gradually reach max speed
        
        roads.push({
            y: yPosition - GAME_CONFIG.roadHeight,
            height: GAME_CONFIG.roadHeight,
            direction: Math.random() > 0.5 ? 1 : -1, // Random direction
            speed: baseSpeedMin + Math.random() * (baseSpeedMax - baseSpeedMin),
            // Difficulty scaling - more cars on later roads
            spawnRate: GAME_CONFIG.carSpawnRate * (1 + i * 0.1),
            // Visual enhancements
            roadType: roadType,
            laneCount: adjustedLaneCount,
            
            // Special road types (higher levels)
            doubleDirection: i > 30 && Math.random() > 0.7, // Some roads have cars in both directions
            speedLimit: i > 50 ? Math.random() * 3 + 0.8 : 1, // Speed multiplier for very fast roads
            
            // Additional hazards
            hazardType: i > 60 ? Math.floor(Math.random() * 3) : 0, // 0: none, 1: slippery, 2: bumpy
        });
        
        // Add obstacles to safe zones (only in higher levels)
        if (i > 20 && Math.random() < GAME_CONFIG.obstacleRate) {
            // Number of obstacles increases with level
            const obstacleCount = Math.floor(Math.random() * 3) + 1;
            
            for (let o = 0; o < obstacleCount; o++) {
                const obstacleX = Math.random() * (canvasWidth - 30);
                const obstacleY = yPosition - GAME_CONFIG.safeZoneHeight / 2;
                
                obstacles.push({
                    x: obstacleX,
                    y: obstacleY,
                    width: 30,
                    height: 30,
                    type: Math.floor(Math.random() * 3) // 0: rock, 1: tree, 2: water
                });
            }
        }
        
        // Move up for next road
        yPosition -= (GAME_CONFIG.roadHeight + GAME_CONFIG.safeZoneHeight);
    }
    
    // Set game state
    gameActive = true;
    gameOver = false;
    gameWon = false;
    
    // Show cash out button
    cashoutContainer.style.display = 'block';
    
    // Update displays
    updateBetDisplay();
    updateMultiplierDisplay();
    updateScoreDisplay();
    
    // Create initial particles
    createParticles(50);
    
    // Start game loop
    window.cancelAnimationFrame(animationFrame);
    gameLoop();
    
    console.log("Game initialized successfully!");
}

// Update player balance and display
function updateCoins(amount) {
    coinBalance += amount;
    coinDisplay.textContent = coinBalance.toFixed(2);
    console.log(`Balance updated: ${amount > 0 ? '+' : ''}${amount}, New balance: ${coinBalance}`);
}

// Update bet display
function updateBetDisplay() {
    currentBetDisplay.textContent = currentBet.toFixed(2);
    const potentialWin = currentBet * currentMultiplier;
    potentialWinDisplay.textContent = `Win: ${potentialWin.toFixed(2)}`;
}

// Update multiplier display
function updateMultiplierDisplay() {
    // Get the current multiplier increment based on level
    let increment = getMultiplierIncrement(currentLevel);
    
    // Calculate next multiplier
    nextMultiplier = parseFloat((currentMultiplier + increment).toFixed(2));
    
    // Update displays
    currentMultiplierDisplay.textContent = `${currentMultiplier.toFixed(2)}x`;
    nextMultiplierDisplay.textContent = `Next: ${nextMultiplier.toFixed(2)}x`;
    
    // Update potential win
    const potentialWin = currentBet * currentMultiplier;
    potentialWinDisplay.textContent = `Win: ${potentialWin.toFixed(2)}`;
}

// Get multiplier increment based on level
function getMultiplierIncrement(level) {
    // Find the appropriate increment based on level thresholds
    let increment = MULTIPLIER_CONFIG.increment[0].value;
    
    for (let i = MULTIPLIER_CONFIG.increment.length - 1; i >= 0; i--) {
        if (level >= MULTIPLIER_CONFIG.increment[i].threshold) {
            increment = MULTIPLIER_CONFIG.increment[i].value;
            break;
        }
    }
    
    return increment;
}

// Update score display
function updateScoreDisplay() {
    scoreDisplay.textContent = `Multiplier: ${currentMultiplier.toFixed(2)}x`;
    
    // Update difficulty indicator
    const difficultyIndicator = document.getElementById('difficulty-indicator');
    if (difficultyIndicator) {
        let difficulty;
        if (currentLevel < 20) {
            difficulty = "Easy";
            difficultyIndicator.style.color = "#4CAF50";
        } else if (currentLevel < 40) {
            difficulty = "Medium";
            difficultyIndicator.style.color = "#FFC107";
        } else if (currentLevel < 70) {
            difficulty = "Hard";
            difficultyIndicator.style.color = "#FF9800";
        } else {
            difficulty = "Extreme";
            difficultyIndicator.style.color = "#F44336";
        }
        difficultyIndicator.textContent = difficulty;
    }
}

// Update start button state based on current bet
function updateStartButtonState() {
    if (coinBalance < currentBet) {
        startBtn.classList.add('insufficient');
        startBtn.textContent = "Insufficient Balance";
        startBtn.disabled = true;
    } else {
        startBtn.classList.remove('insufficient');
        startBtn.textContent = "Start Game";
        startBtn.disabled = false;
    }
}

// Spawn cars on roads
function spawnCars() {
    for (let i = 0; i < roads.length; i++) {
        const road = roads[i];
        
        // Skip roads that are off-screen
        if (road.y > canvasHeight || road.y + road.height < 0) {
            continue;
        }
        
        // Scale spawn rate based on current level
        const roadLevel = roads.length - i - 1;
        const levelFactor = 1 + (roadLevel * GAME_CONFIG.difficultyScaling / 10);
        const adjustedSpawnRate = road.spawnRate * levelFactor;
        
        // Handle double direction roads
        if (road.doubleDirection) {
            // Spawn cars in both directions
            if (Math.random() < adjustedSpawnRate * 0.6) { // Slightly lower spawn rate for each direction
                spawnCar(road, 1); // Right direction
            }
            
            if (Math.random() < adjustedSpawnRate * 0.6) {
                spawnCar(road, -1); // Left direction
            }
        } else {
            // Normal single direction road
            if (Math.random() < adjustedSpawnRate) {
                spawnCar(road, road.direction);
            }
        }
    }
}

// Helper function to spawn a car
function spawnCar(road, direction) {
    // Determine spawn position based on direction
    let carX;
    if (direction > 0) {
        carX = -GAME_CONFIG.carWidth; // Spawn from left
    } else {
        carX = canvasWidth; // Spawn from right
    }
    
    // Determine vertical position based on lane
    const laneHeight = road.height / (road.laneCount || 1);
    const lane = Math.floor(Math.random() * road.laneCount);
    const carY = road.y + lane * laneHeight + (laneHeight - GAME_CONFIG.carHeight) / 2;
    
    // Create car object with variation based on level
    const roadLevel = currentLevel;
    const speedVariation = 1 + (roadLevel * GAME_CONFIG.difficultyScaling / 20);
    
    // Apply speed limit multiplier for very fast roads
    const finalSpeed = road.speed * direction * speedVariation * (road.speedLimit || 1);
    
    // Random car type - more variety
    const carType = Math.floor(Math.random() * 5); // 0: normal, 1: truck, 2: sports car, 3: bus, 4: motorcycle
    
    // Adjust car dimensions based on type
    let carWidth = GAME_CONFIG.carWidth;
    let carHeight = GAME_CONFIG.carHeight;
    
    switch(carType) {
        case 1: // Truck - longer
            carWidth = GAME_CONFIG.carWidth * 1.7;
            break;
        case 2: // Sports car - sleeker
            carHeight = GAME_CONFIG.carHeight * 0.8;
            break;
        case 3: // Bus - much longer
            carWidth = GAME_CONFIG.carWidth * 2.2;
            break;
        case 4: // Motorcycle - smaller
            carWidth = GAME_CONFIG.carWidth * 0.5;
            carHeight = GAME_CONFIG.carHeight * 0.7;
            break;
    }
    
    // Get car color
    const normalColors = ['#f44336', '#E91E63', '#9C27B0', '#673AB7', '#3F51B5', '#2196F3', '#03A9F4', '#00BCD4', '#009688'];
    const truckColors = ['#795548', '#607D8B', '#6D4C41', '#546E7A']; 
    const sportsCarColors = ['#F44336', '#FFEB3B', '#2196F3', '#000000', '#FFFFFF'];
    const busColors = ['#FFC107', '#CDDC39', '#4CAF50'];
    const motorcycleColors = ['#000000', '#212121', '#424242', '#1A237E'];
    
    let carColor;
    switch(carType) {
        case 1: // Truck
            carColor = truckColors[Math.floor(Math.random() * truckColors.length)];
            break;
        case 2: // Sports car
            carColor = sportsCarColors[Math.floor(Math.random() * sportsCarColors.length)];
            break;
        case 3: // Bus
            carColor = busColors[Math.floor(Math.random() * busColors.length)];
            break;
        case 4: // Motorcycle
            carColor = motorcycleColors[Math.floor(Math.random() * motorcycleColors.length)];
            break;
        default: // Normal car
            carColor = normalColors[Math.floor(Math.random() * normalColors.length)];
    }
    
    const car = {
        x: carX,
        y: carY,
        width: carWidth,
        height: carHeight,
        speed: finalSpeed,
        color: carColor,
        type: carType,
        // Add headlights for visual enhancement
        headlights: Math.random() > 0.3, // 70% chance to have headlights
        brake: Math.random() > 0.8, // 20% chance to have brake lights
        windowTint: Math.floor(Math.random() * 50) + 30, // Random window darkness
        // Hazard effect
        hazardEffect: road.hazardType > 0
    };
    
    cars.push(car);
}

// Move cars
function moveCars() {
    for (let i = cars.length - 1; i >= 0; i--) {
        const car = cars[i];
        car.x += car.speed;
        
        // Remove cars that are off-screen
        if ((car.speed > 0 && car.x > canvasWidth) || (car.speed < 0 && car.x + car.width < 0)) {
            cars.splice(i, 1);
        }
    }
}

// Move player
function movePlayer() {
    if (!player) return;
    
    // Store previous position for trail effect
    const prevX = player.x;
    const prevY = player.y;
    
    // Move based on key presses
    if ((keysPressed['ArrowUp'] || keysPressed['w'] || keysPressed['W']) && player.y > 0) {
        player.y -= player.speed;
        checkLevelProgress();
    }
    
    if ((keysPressed['ArrowDown'] || keysPressed['s'] || keysPressed['S']) && player.y + player.height < canvasHeight) {
        player.y += player.speed;
    }
    
    if ((keysPressed['ArrowLeft'] || keysPressed['a'] || keysPressed['A']) && player.x > 0) {
        player.x -= player.speed;
    }
    
    if ((keysPressed['ArrowRight'] || keysPressed['d'] || keysPressed['D']) && player.x + player.width < canvasWidth) {
        player.x += player.speed;
    }
    
    // Add trail effect only when the player actually moves
    if (player.x !== prevX || player.y !== prevY) {
        // Add current position to trail if not already tracking
        if (!player.trail) player.trail = [];
        
        // Limit trail length
        if (player.trail.length > 10) {
            player.trail.shift();
        }
        
        player.trail.push({
            x: prevX + player.width / 2,
            y: prevY + player.height / 2,
            alpha: 1
        });
    }
}

// Check level progress
function checkLevelProgress() {
    if (!player) return;
    
    // Calculate which level (road) the player is at
    const roadAndSafeZoneHeight = GAME_CONFIG.roadHeight + GAME_CONFIG.safeZoneHeight;
    const playerLevel = Math.floor((canvasHeight - player.y) / roadAndSafeZoneHeight);
    
    // Update current level if player has advanced
    if (playerLevel > currentLevel) {
        // Crossed a new road
        currentLevel = playerLevel;
        
        // Increase multiplier
        const increment = getMultiplierIncrement(currentLevel);
        currentMultiplier += increment;
        
        // Cap multiplier at maximum
        if (currentMultiplier > GAME_CONFIG.maxMultiplier) {
            currentMultiplier = GAME_CONFIG.maxMultiplier;
        }
        
        // Add multiplier increase animation
        animateMultiplierIncrease();
        
        // Update displays
        updateMultiplierDisplay();
        updateScoreDisplay();
        updateBetDisplay();
    }
}

// Animate multiplier increase
function animateMultiplierIncrease() {
    // Add animation class to multiplier display
    currentMultiplierDisplay.classList.add('multiplier-increase');
    
    // Remove class after animation completes
    setTimeout(() => {
        currentMultiplierDisplay.classList.remove('multiplier-increase');
    }, 300);
}

// Check collisions with cars and obstacles
function checkCollisions() {
    if (!player) return;
    
    // Check collisions with cars
    for (const car of cars) {
        if (
            player.x < car.x + car.width &&
            player.x + player.width > car.x &&
            player.y < car.y + car.height &&
            player.y + player.height > car.y
        ) {
            // Collision detected
            gameOver = true;
            gameActive = false;
            
            // Visual effect for collision
            createExplosion(player.x + player.width / 2, player.y + player.height / 2);
            
            // Hide cashout button
            cashoutContainer.style.display = 'none';
            
            // Update game over screen
            document.getElementById('lost-amount').textContent = currentBet.toFixed(2);
            document.getElementById('final-level').textContent = currentLevel;
            document.getElementById('final-multiplier').textContent = currentMultiplier.toFixed(2) + 'x';
            
            // Show game over screen
            gameOverScreen.classList.add('visible');
            return;
        }
    }
    
    // Check collisions with obstacles
    for (const obstacle of obstacles) {
        if (
            player.x < obstacle.x + obstacle.width &&
            player.x + player.width > obstacle.x &&
            player.y < obstacle.y + obstacle.height &&
            player.y + player.height > obstacle.y
        ) {
            // Different effects based on obstacle type
            switch(obstacle.type) {
                case 0: // Rock - immovable
                    // Push player back
                    const centerX = player.x + player.width / 2;
                    const centerY = player.y + player.height / 2;
                    const obstacleCenterX = obstacle.x + obstacle.width / 2;
                    const obstacleCenterY = obstacle.y + obstacle.height / 2;
                    
                    // Calculate direction to push
                    const dx = centerX - obstacleCenterX;
                    const dy = centerY - obstacleCenterY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Normalize and apply push
                    if (dist > 0) {
                        player.x += (dx / dist) * player.speed;
                        player.y += (dy / dist) * player.speed;
                    }
                    break;
                    
                case 1: // Tree - similar to rock but less pushback
                    // Slightly push player
                    const treeDx = (player.x + player.width / 2) - (obstacle.x + obstacle.width / 2);
                    const treeDy = (player.y + player.height / 2) - (obstacle.y + obstacle.height / 2);
                    const treeDist = Math.sqrt(treeDx * treeDx + treeDy * treeDy);
                    
                    if (treeDist > 0) {
                        player.x += (treeDx / treeDist) * (player.speed * 0.7);
                        player.y += (treeDy / treeDist) * (player.speed * 0.7);
                    }
                    break;
                    
                case 2: // Water - instant game over
                    gameOver = true;
                    gameActive = false;
                    
                    // Visual effect for drowning
                    createRippleEffect(player.x + player.width / 2, player.y + player.height / 2);
                    
                    // Hide cashout button
                    cashoutContainer.style.display = 'none';
                    
                    // Update game over screen
                    document.getElementById('lost-amount').textContent = currentBet.toFixed(2);
                    document.getElementById('final-level').textContent = currentLevel;
                    document.getElementById('final-multiplier').textContent = currentMultiplier.toFixed(2) + 'x';
                    
                    // Show game over screen with special message
                    const gameOverMessage = document.querySelector('#game-over-screen .overlay-message');
                    if (gameOverMessage) {
                        gameOverMessage.innerHTML = `You drowned!<br>Lost: <span class="lose-amount">${currentBet.toFixed(2)}</span><br>You reached ${currentLevel} roads with <span id="final-multiplier">${currentMultiplier.toFixed(2)}x</span>`;
                    }
                    
                    gameOverScreen.classList.add('visible');
                    return;
            }
        }
    }
}

// Cash out (player decides to take current winnings)
function cashOut() {
    if (!gameActive) return;
    
    // Calculate winnings
    const winnings = currentBet * currentMultiplier;
    
    // Update balance
    updateCoins(winnings);
    
    // End game
    gameActive = false;
    gameWon = true;
    
    // Hide cashout button
    cashoutContainer.style.display = 'none';
    
    // Update win screen
    document.getElementById('cashout-multiplier').textContent = currentMultiplier.toFixed(2) + 'x';
    document.getElementById('win-amount').textContent = winnings.toFixed(2);
    document.getElementById('roads-crossed').textContent = currentLevel;
    
    // Show win screen
    winScreen.classList.add('visible');
    
    // Create win celebration effect
    createWinCelebration();
}

// Create particles for visual effects
function createParticles(count) {
    // Remove existing particles
    const existingParticles = document.querySelectorAll('.particle');
    existingParticles.forEach(p => p.remove());
    
    // Create new particles
    const gameBoard = document.querySelector('.game-board');
    if (!gameBoard) return;
    
    for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        // Random position
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        
        // Random size
        const size = Math.random() * 3 + 1;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Random opacity
        particle.style.opacity = Math.random() * 0.5 + 0.2;
        
        // Animation
        particle.style.animation = `float ${Math.random() * 10 + 5}s linear infinite`;
        particle.style.animationDelay = `${Math.random() * 5}s`;
        
        gameBoard.appendChild(particle);
    }
}

// Create explosion effect
function createExplosion(x, y) {
    // Create multiple particles for explosion
    for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        // Position at collision point
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        
        // Larger size for explosion particles
        const size = Math.random() * 6 + 3;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Different colors for explosion
        const colors = ['#f44336', '#ffeb3b', '#ff9800'];
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        
        // Random direction
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 3;
        const xVelocity = Math.cos(angle) * speed;
        const yVelocity = Math.sin(angle) * speed;
        
        // Animation
        particle.style.transition = 'all 0.5s ease-out';
        
        const gameBoard = document.querySelector('.game-board');
        if (gameBoard) {
            gameBoard.appendChild(particle);
            
            // Animate explosion
            setTimeout(() => {
                particle.style.left = `${x + xVelocity * 20}px`;
                particle.style.top = `${y + yVelocity * 20}px`;
                particle.style.opacity = '0';
            }, 10);
            
            // Remove particles after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 1000);
        }
    }
}

// Create ripple effect for water
function createRippleEffect(x, y) {
    // Create ripple circles
    for (let i = 0; i < 3; i++) {
        const ripple = document.createElement('div');
        ripple.style.position = 'absolute';
        ripple.style.left = `${x}px`;
        ripple.style.top = `${y}px`;
        ripple.style.width = '10px';
        ripple.style.height = '10px';
        ripple.style.borderRadius = '50%';
        ripple.style.border = '2px solid #03a9f4';
        ripple.style.backgroundColor = 'transparent';
        ripple.style.transform = 'translate(-50%, -50%)';
        ripple.style.zIndex = '10';
        
        // Animation
        ripple.style.transition = `all ${0.5 + i * 0.3}s ease-out`;
        
        const gameBoard = document.querySelector('.game-board');
        if (gameBoard) {
            gameBoard.appendChild(ripple);
            
            // Start animation after a delay
            setTimeout(() => {
                ripple.style.width = '100px';
                ripple.style.height = '100px';
                ripple.style.opacity = '0';
            }, i * 200);
            
            // Remove ripple after animation
            setTimeout(() => {
                if (ripple.parentNode) {
                    ripple.parentNode.removeChild(ripple);
                }
            }, (i * 200) + 1000);
        }
    }
}

// Create win celebration effect
function createWinCelebration() {
    // Create confetti particles
    for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        // Random starting position at top
        const x = Math.random() * canvasWidth;
        particle.style.left = `${x}px`;
        particle.style.top = '0';
        
        // Random size
        const size = Math.random() * 8 + 4;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Celebration colors
        const colors = ['#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800'];
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        
        // Animation
        particle.style.transition = `all ${Math.random() * 3 + 2}s ease-out`;
        
        const gameBoard = document.querySelector('.game-board');
        if (gameBoard) {
            gameBoard.appendChild(particle);
            
            // Animate falling with some horizontal movement
            setTimeout(() => {
                const endX = x + (Math.random() - 0.5) * 200;
                particle.style.left = `${endX}px`;
                particle.style.top = `${canvasHeight}px`;
                particle.style.transform = `rotate(${Math.random() * 360}deg)`;
                particle.style.opacity = '0';
            }, 10);
            
            // Remove particles after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 5000);
        }
    }
}

// Flash warning for extreme levels
function flashWarning() {
    const warningOverlay = document.createElement('div');
    warningOverlay.style.position = 'absolute';
    warningOverlay.style.top = '0';
    warningOverlay.style.left = '0';
    warningOverlay.style.width = '100%';
    warningOverlay.style.height = '100%';
    warningOverlay.style.backgroundColor = 'rgba(244, 67, 54, 0.2)';
    warningOverlay.style.zIndex = '5';
    warningOverlay.style.pointerEvents = 'none';
    
    const gameBoard = document.querySelector('.game-board');
    if (gameBoard) {
        gameBoard.appendChild(warningOverlay);
        
        // Fade out
        setTimeout(() => {
            warningOverlay.style.transition = 'all 0.5s ease-out';
            warningOverlay.style.opacity = '0';
        }, 100);
        
        // Remove after animation
        setTimeout(() => {
            if (warningOverlay.parentNode) {
                warningOverlay.parentNode.removeChild(warningOverlay);
            }
        }, 600);
    }
}

// Adapt difficulty based on level progression
function adaptDifficulty() {
    if (!player) return;
    
    // Increase player speed slightly as levels progress, but cap it
    if (currentLevel > 10 && currentLevel < 60) {
        player.speed = 5 + (currentLevel - 10) * 0.04;
    } else if (currentLevel >= 60) {
        // Slightly reduce speed at extreme levels to maintain control
        player.speed = 5 + 50 * 0.04 - (currentLevel - 60) * 0.01;
        player.speed = Math.max(5, player.speed); // Don't go below base speed
    }
    
    // Make obstacles shift positions sometimes in higher levels
    if (currentLevel > 50 && obstacles.length > 0 && Math.random() < 0.01) {
        for (const obstacle of obstacles) {
            if (Math.random() < 0.3) { // 30% chance for each obstacle
                obstacle.x += (Math.random() - 0.5) * 5; // Shift left or right slightly
                
                // Keep within bounds
                obstacle.x = Math.max(0, Math.min(canvasWidth - obstacle.width, obstacle.x));
            }
        }
    }
    
    // Create particle effects at higher levels - more at higher levels
    const particleChance = currentLevel > 30 ? 0.02 + (currentLevel / 500) : 0;
    if (Math.random() < particleChance) {
        const particleCount = Math.floor(currentLevel / 20) + 5;
        createParticles(particleCount);
    }
    
    // Flash warning on extreme levels
    if (currentLevel > 80 && Math.random() < 0.05) {
        flashWarning();
    }
}

// Draw game elements
function drawGame() {
    if (!canvas || !ctx) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    
    // Draw background pattern
    drawBackgroundPattern();
    
    // Draw player trail
    drawPlayerTrail();
    
    // Draw roads and safe zones
    for (let i = 0; i < roads.length; i++) {
        const road = roads[i];
        
        // Skip roads that are off-screen
        if (road.y > canvasHeight || road.y + road.height < 0) {
            continue;
        }
        
        // Get road type
        const roadColor = road.roadType === 1 ? '#333' : road.roadType === 2 ? '#3c3c3c' : '#2c2c2c';
        
        // Draw road
        ctx.fillStyle = roadColor;
        ctx.fillRect(0, road.y, canvasWidth, road.height);
        
        // Draw road borders
        ctx.fillStyle = '#444';
        ctx.fillRect(0, road.y, canvasWidth, 3);
        ctx.fillRect(0, road.y + road.height - 3, canvasWidth, 3);
        
        // Draw road markings based on lane count
        const laneHeight = road.height / (road.laneCount || 1);
        
        for (let lane = 0; lane < road.laneCount; lane++) {
            const laneY = road.y + (lane + 1) * laneHeight;
            
            if (lane < road.laneCount - 1) {
                // Draw lane divider
                ctx.setLineDash([20, 10]);
                ctx.beginPath();
                ctx.moveTo(0, laneY);
                ctx.lineTo(canvasWidth, laneY);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // Draw center line 
        ctx.setLineDash([20, 10]);
        ctx.beginPath();
        ctx.moveTo(0, road.y + road.height / 2);
        ctx.lineTo(canvasWidth, road.y + road.height / 2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw direction indicator
        const arrowSize = 10;
        const arrowX = road.direction > 0 ? 20 : canvasWidth - 20;
        const arrowY = road.y + road.height / 2;
        
        ctx.beginPath();
        if (road.direction > 0) {
            // Right arrow
            ctx.moveTo(arrowX - arrowSize, arrowY - arrowSize);
            ctx.lineTo(arrowX + arrowSize, arrowY);
            ctx.lineTo(arrowX - arrowSize, arrowY + arrowSize);
        } else {
            // Left arrow
            ctx.moveTo(arrowX + arrowSize, arrowY - arrowSize);
            ctx.lineTo(arrowX - arrowSize, arrowY);
            ctx.lineTo(arrowX + arrowSize, arrowY + arrowSize);
        }
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Draw safety zones between roads (grass)
        if (i < roads.length - 1) {
            const nextRoad = roads[i + 1];
            const safetyZoneY = road.y - GAME_CONFIG.safeZoneHeight;
            
            // Skip off-screen safe zones
            if (safetyZoneY > canvasHeight || safetyZoneY + GAME_CONFIG.safeZoneHeight < 0) {
                continue;
            }
            
            // Draw grass texture
            const gradient = ctx.createLinearGradient(0, safetyZoneY, 0, safetyZoneY + GAME_CONFIG.safeZoneHeight);
            gradient.addColorStop(0, '#1a472a');
            gradient.addColorStop(1, '#0d3320');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, safetyZoneY, canvasWidth, GAME_CONFIG.safeZoneHeight);
            
            // Add grass details
            for (let g = 0; g < 30; g++) {
                const grassX = Math.random() * canvasWidth;
                const grassY = safetyZoneY + Math.random() * GAME_CONFIG.safeZoneHeight;
                const grassHeight = 2 + Math.random() * 4;
                
                ctx.fillStyle = `rgba(45, 136, 45, ${0.5 + Math.random() * 0.5})`;
                ctx.fillRect(grassX, grassY, 2, grassHeight);
            }
        }
    }
    
    // Draw obstacles
    for (const obstacle of obstacles) {
        // Skip obstacles that are off-screen
        if (obstacle.y > canvasHeight || obstacle.y + obstacle.height < 0) {
            continue;
        }
        
        switch(obstacle.type) {
            case 0: // Rock
                // Draw rock
                const rockGradient = ctx.createRadialGradient(
                    obstacle.x + obstacle.width / 2, 
                    obstacle.y + obstacle.height / 2, 
                    0,
                    obstacle.x + obstacle.width / 2, 
                    obstacle.y + obstacle.height / 2, 
                    obstacle.width / 2
                );
                rockGradient.addColorStop(0, '#777');
                rockGradient.addColorStop(1, '#555');
                
                ctx.fillStyle = rockGradient;
                ctx.beginPath();
                ctx.ellipse(
                    obstacle.x + obstacle.width / 2, 
                    obstacle.y + obstacle.height / 2, 
                    obstacle.width / 2, 
                    obstacle.height / 2, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                break;
                
            case 1: // Tree
                // Draw tree trunk
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(
                    obstacle.x + obstacle.width / 2 - 3, 
                    obstacle.y + obstacle.height / 2, 
                    6, 
                    obstacle.height / 2
                );
                
                // Draw tree foliage
                ctx.fillStyle = '#2E7D32';
                ctx.beginPath();
                ctx.moveTo(obstacle.x + obstacle.width / 2, obstacle.y);
                ctx.lineTo(obstacle.x, obstacle.y + obstacle.height / 2);
                ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height / 2);
                ctx.closePath();
                ctx.fill();
                break;
                
            case 2: // Water
                // Draw water
                const waterGradient = ctx.createLinearGradient(
                    0, obstacle.y, 
                    0, obstacle.y + obstacle.height
                );
                waterGradient.addColorStop(0, 'rgba(3, 169, 244, 0.7)');
                waterGradient.addColorStop(1, 'rgba(1, 87, 155, 0.7)');
                
                ctx.fillStyle = waterGradient;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Add water ripple effect
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.moveTo(obstacle.x, obstacle.y + obstacle.height / 3);
                ctx.bezierCurveTo(
                    obstacle.x + obstacle.width / 4, obstacle.y + obstacle.height / 3 - 2,
                    obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 3 + 2,
                    obstacle.x + obstacle.width, obstacle.y + obstacle.height / 3
                );
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(obstacle.x, obstacle.y + 2 * obstacle.height / 3);
                ctx.bezierCurveTo(
                    obstacle.x + obstacle.width / 4, obstacle.y + 2 * obstacle.height / 3 + 2,
                    obstacle.x + obstacle.width / 2, obstacle.y + 2 * obstacle.height / 3 - 2,
                    obstacle.x + obstacle.width, obstacle.y + 2 * obstacle.height / 3
                );
                ctx.stroke();
                break;
        }
    }
    
    // Draw cars with enhanced visuals
    for (const car of cars) {
        // Skip cars that are off-screen
        if ((car.x > canvasWidth) || (car.x + car.width < 0) || 
            (car.y > canvasHeight) || (car.y + car.height < 0)) {
            continue;
        }
        
        // Car body
        ctx.fillStyle = car.color;
        const cornerRadius = 5;
        
        // Draw rounded rectangle for car body
        ctx.beginPath();
        ctx.moveTo(car.x + cornerRadius, car.y);
        ctx.lineTo(car.x + car.width - cornerRadius, car.y);
        ctx.quadraticCurveTo(car.x + car.width, car.y, car.x + car.width, car.y + cornerRadius);
        ctx.lineTo(car.x + car.width, car.y + car.height - cornerRadius);
        ctx.quadraticCurveTo(car.x + car.width, car.y + car.height, car.x + car.width - cornerRadius, car.y + car.height);
        ctx.lineTo(car.x + cornerRadius, car.y + car.height);
        ctx.quadraticCurveTo(car.x, car.y + car.height, car.x, car.y + car.height - cornerRadius);
        ctx.lineTo(car.x, car.y + cornerRadius);
        ctx.quadraticCurveTo(car.x, car.y, car.x + cornerRadius, car.y);
        ctx.closePath();
        ctx.fill();
        
        // Windows (darker shade)
        const windowColor = `rgba(0, 0, 0, ${car.windowTint / 100})`;
        ctx.fillStyle = windowColor;
        
        // Front window
        ctx.fillRect(car.x + car.width * 0.6, car.y + 3, car.width * 0.2, car.height - 6);
        
        // Back window
        ctx.fillRect(car.x + car.width * 0.2, car.y + 3, car.width * 0.2, car.height - 6);
        
        // Add headlights or taillights based on direction
        if (car.speed > 0) {
            // Moving right - headlights on the right
            if (car.headlights) {
                // Headlight glow (outer)
                const headlightGradient = ctx.createRadialGradient(
                    car.x + car.width, car.y + car.height / 2,
                    0,
                    car.x + car.width, car.y + car.height / 2,
                    20
                );
                headlightGradient.addColorStop(0, 'rgba(255, 255, 150, 0.8)');
                headlightGradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
                
                ctx.fillStyle = headlightGradient;
                ctx.beginPath();
                ctx.arc(car.x + car.width, car.y + car.height / 2, 20, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Actual headlights
            ctx.fillStyle = 'rgba(255, 255, 150, 0.9)';
            ctx.fillRect(car.x + car.width - 3, car.y + 5, 3, 5);
            ctx.fillRect(car.x + car.width - 3, car.y + car.height - 10, 3, 5);
        } else {
            // Moving left - headlights on the left
            if (car.headlights) {
                // Headlight glow (outer)
                const headlightGradient = ctx.createRadialGradient(
                    car.x, car.y + car.height / 2,
                    0,
                    car.x, car.y + car.height / 2,
                    20
                );
                headlightGradient.addColorStop(0, 'rgba(255, 255, 150, 0.8)');
                headlightGradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
                
                ctx.fillStyle = headlightGradient;
                ctx.beginPath();
                ctx.arc(car.x, car.y + car.height / 2, 20, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Actual headlights
            ctx.fillStyle = 'rgba(255, 255, 150, 0.9)';
            ctx.fillRect(car.x, car.y + 5, 3, 5);
            ctx.fillRect(car.x, car.y + car.height - 10, 3, 5);
        }
        
        // Add brake lights on the opposite side
        if (car.brake) {
            if (car.speed > 0) {
                // Brake lights at left (back) of car
                ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
                ctx.fillRect(car.x, car.y + 5, 3, 5);
                ctx.fillRect(car.x, car.y + car.height - 10, 3, 5);
            } else {
                // Brake lights at right (back) of car
                ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
                ctx.fillRect(car.x + car.width - 3, car.y + 5, 3, 5);
                ctx.fillRect(car.x + car.width - 3, car.y + car.height - 10, 3, 5);
            }
        }
    }
    
    // Draw player with enhanced visuals
    if (player) {
        ctx.save();
        const playerCenterX = player.x + player.width / 2;
        const playerCenterY = player.y + player.height / 2;
        
        // Create a gradient for the player
        const playerGradient = ctx.createRadialGradient(
            playerCenterX, playerCenterY, 0,
            playerCenterX, playerCenterY, player.width
        );
        playerGradient.addColorStop(0, '#4CAF50');
        playerGradient.addColorStop(1, '#2E7D32');
        
        // Draw player body (rounded rectangle)
        const cornerRadius = 5;
        ctx.fillStyle = playerGradient;
        
        ctx.beginPath();
        ctx.moveTo(player.x + cornerRadius, player.y);
        ctx.lineTo(player.x + player.width - cornerRadius, player.y);
        ctx.quadraticCurveTo(player.x + player.width, player.y, player.x + player.width, player.y + cornerRadius);
        ctx.lineTo(player.x + player.width, player.y + player.height - cornerRadius);
        ctx.quadraticCurveTo(player.x + player.width, player.y + player.height, player.x + player.width - cornerRadius, player.y + player.height);
        ctx.lineTo(player.x + cornerRadius, player.y + player.height);
        ctx.quadraticCurveTo(player.x, player.y + player.height, player.x, player.y + player.height - cornerRadius);
        ctx.lineTo(player.x, player.y + cornerRadius);
        ctx.quadraticCurveTo(player.x, player.y, player.x + cornerRadius, player.y);
        ctx.closePath();
        ctx.fill();
        
        // Add player glow effect
        ctx.shadowColor = '#4CAF50';
        ctx.shadowBlur = 10;
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#81C784';
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Add player details (eyes)
        ctx.fillStyle = '#fff';
        const eyeSize = 4;
        ctx.fillRect(player.x + player.width / 4 - eyeSize / 2, player.y + player.height / 3, eyeSize, eyeSize);
        ctx.fillRect(player.x + 3 * player.width / 4 - eyeSize / 2, player.y + player.height / 3, eyeSize, eyeSize);
        
        // Add player "mouth" - simple smile
        ctx.beginPath();
        ctx.arc(player.x + player.width / 2, player.y + player.height / 2 + 2, 4, 0, Math.PI);
        ctx.stroke();
        
        ctx.restore();
    }
}

// Draw background pattern
function drawBackgroundPattern() {
    if (!ctx) return;
    
    // Create grid pattern
    ctx.fillStyle = '#001133';
    
    for (let x = 0; x < canvasWidth; x += 20) {
        for (let y = 0; y < canvasHeight; y += 20) {
            ctx.fillRect(x, y, 1, 1);
        }
    }
}

// Draw player trail
function drawPlayerTrail() {
    if (!ctx || !player || !player.trail) return;
    
    // Draw trail
    for (let i = 0; i < player.trail.length; i++) {
        const point = player.trail[i];
        const alpha = i / player.trail.length;
        const size = (player.width / 2) * alpha;
        
        ctx.fillStyle = `rgba(76, 175, 80, ${alpha * 0.3})`;
        ctx.beginPath();
        ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Game loop
function gameLoop() {
    if (gameActive) {
        // Game logic
        spawnCars();
        moveCars();
        movePlayer();
        checkCollisions();
        
        // Draw game
        drawGame();
        
        // Adapt difficulty based on level progression
        adaptDifficulty();
        
        // Continue game loop
        animationFrame = requestAnimationFrame(gameLoop);
    }
}

// Initialize game components and event listeners
function init() {
    console.log("Initializing Mission Uncrossable...");
    
    // Get DOM elements
    startScreen = document.getElementById('start-screen');
    gameOverScreen = document.getElementById('game-over-screen');
    winScreen = document.getElementById('win-screen');
    
    coinDisplay = document.getElementById('coinDisplay');
    scoreDisplay = document.getElementById('scoreDisplay');
    
    startBtn = document.getElementById('start-btn');
    restartBtn = document.getElementById('restart-btn');
    continueBtn = document.getElementById('continue-btn');
    cashoutBtn = document.getElementById('cashout-btn');
    backBtn = document.getElementById('back-btn');
    
    betInput = document.getElementById('bet-input');
    increaseBetBtn = document.getElementById('increase-bet');
    decreaseBetBtn = document.getElementById('decrease-bet');
    
    cashoutContainer = document.getElementById('cashout-container');
    
    currentMultiplierDisplay = document.getElementById('current-multiplier');
    nextMultiplierDisplay = document.getElementById('next-multiplier');
    
    currentBetDisplay = document.getElementById('current-bet');
    potentialWinDisplay = document.getElementById('potential-win');
    
    quickBets = document.querySelectorAll('.quick-bet');
    
    // Initialize canvas
    initCanvas();
    
    // Generate initial game hash
    gameHash = generateGameHash();
    const hashElement = document.getElementById('game-hash');
    if (hashElement) {
        hashElement.textContent = `Game Hash: ${gameHash}`;
    }
    
    const verifyElement = document.getElementById('verify-hash');
    if (verifyElement) {
        verifyElement.textContent = `Verify: ${gameHash}`;
    }
    
    // Set up event listeners
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
        keysPressed[e.key] = true;
        
        // Prevent scrolling when using arrow keys
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
            e.preventDefault();
        }
        
        // Cash out with space bar
        if (e.key === ' ' && gameActive) {
            cashOut();
        }
    });

    document.addEventListener('keyup', (e) => {
        keysPressed[e.key] = false;
    });
    
    // Bet controls
    if (increaseBetBtn) {
        increaseBetBtn.addEventListener('click', function() {
            currentBet = parseFloat(betInput.value);
            currentBet += currentBet >= 100 ? 100 : currentBet >= 10 ? 10 : 1;
            currentBet = Math.min(currentBet, GAME_CONFIG.maxBet);
            betInput.value = currentBet.toFixed(2);
            updateStartButtonState();
        });
    }
    
    if (decreaseBetBtn) {
        decreaseBetBtn.addEventListener('click', function() {
            currentBet = parseFloat(betInput.value);
            currentBet -= currentBet > 100 ? 100 : currentBet > 10 ? 10 : 1;
            currentBet = Math.max(currentBet, GAME_CONFIG.minBet);
            betInput.value = currentBet.toFixed(2);
            updateStartButtonState();
        });
    }
    
    if (betInput) {
        betInput.addEventListener('input', function() {
            let newBet = parseFloat(betInput.value);
            if (isNaN(newBet) || newBet < GAME_CONFIG.minBet) {
                newBet = GAME_CONFIG.minBet;
            } else if (newBet > GAME_CONFIG.maxBet) {
                newBet = GAME_CONFIG.maxBet;
            }
            currentBet = newBet;
            updateStartButtonState();
        });
    }
    
    // Quick bet buttons
    quickBets.forEach(btn => {
        btn.addEventListener('click', function() {
            currentBet = parseFloat(btn.getAttribute('data-value'));
            betInput.value = currentBet.toFixed(2);
            updateStartButtonState();
        });
    });
    
    // Game control buttons
    if (startBtn) {
        startBtn.addEventListener('click', function() {
            if (coinBalance >= currentBet) {
                startScreen.classList.remove('visible');
                initGame();
            }
        });
    }
    
    if (restartBtn) {
        restartBtn.addEventListener('click', function() {
            gameOverScreen.classList.remove('visible');
            startScreen.classList.add('visible');
            updateStartButtonState();
        });
    }
    
    if (continueBtn) {
        continueBtn.addEventListener('click', function() {
            winScreen.classList.remove('visible');
            startScreen.classList.add('visible');
            updateStartButtonState();
        });
    }
    
    if (cashoutBtn) {
        cashoutBtn.addEventListener('click', function() {
            cashOut();
        });
    }
    
    if (backBtn) {
        backBtn.addEventListener('click', function() {
            window.location.href = '/betavngames.html';
        });
    }
    
    // Update display
    updateCoinDisplay();
    updateBetDisplay();
    updateMultiplierDisplay();
    updateStartButtonState();
    
    // Create initial particles for visual effect
    createParticles(30);
    
    console.log("Initialization complete!");
}

// Start everything when page loads
window.addEventListener('load', init);
   </script>
</body>
</html>
