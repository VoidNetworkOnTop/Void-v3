<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>The Void Games - Blackjack</title>

   <!-- Favicon -->
   <link rel="shortcut icon" href="./assets/favicon.png" type="image/png">

   <style>
       body, html {
           margin: 0;
           padding: 0;
           width: 100%;
           height: 100%;
           background: #000;
           color: #fff;
           font-family: 'Arial', sans-serif;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
       }

       .game-container {
           background: linear-gradient(180deg, #000000, #0c0c1f, #000018);
           border-radius: 10px;
           width: 90%;
           max-width: 800px;
           height: 90vh;
           max-height: 800px;
           display: flex;
           flex-direction: column;
           position: relative;
           padding: 1rem;
           box-shadow: 
               0 0 2px #fff,
               0 0 4px #fff,
               0 0 6px #4d7cff,
               0 0 8px #4d7cff,
               inset 0 0 2px rgba(255, 255, 255, 0.2);
           z-index: 3;
           overflow: hidden;
       }

       .game-header {
           text-align: center;
           padding-bottom: 1rem;
           border-bottom: 1px solid rgba(77, 124, 255, 0.2);
           position: relative;
           background: linear-gradient(90deg, transparent, rgba(77, 124, 255, 0.05), transparent);
           z-index: 10;
       }

       .game-title {
           font-size: 2.2rem;
           margin: 0 0 0.5rem 0;
           background: linear-gradient(45deg, #fff, #4d7cff);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           font-weight: bold;
           text-transform: uppercase;
           letter-spacing: 3px;
           text-shadow: 0 0 10px rgba(77, 124, 255, 0.7);
           animation: titleGlow 2s infinite alternate;
       }

       @keyframes titleGlow {
           0% { text-shadow: 0 0 5px rgba(77, 124, 255, 0.7); }
           100% { text-shadow: 0 0 15px rgba(77, 124, 255, 0.9), 0 0 30px rgba(77, 124, 255, 0.5); }
       }

       .game-subtitle {
           font-size: 1rem;
           color: #aac4ff;
           margin: 0;
           text-transform: uppercase;
           letter-spacing: 2px;
           opacity: 0.8;
       }

       .coin-tracker {
           position: absolute;
           top: 0;
           right: 0;
           background: linear-gradient(135deg, rgba(77, 124, 255, 0.1), rgba(20, 30, 60, 0.5));
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           padding: 0.5rem 1rem;
           display: flex;
           align-items: center;
           gap: 0.5rem;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.3);
           animation: glow 2s infinite;
           backdrop-filter: blur(5px);
           z-index: 10;
       }

       .coin-icon {
           width: 20px;
           height: 20px;
           background: linear-gradient(135deg, #FFD700, #FFA500);
           border-radius: 50%;
           box-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
           position: relative;
           overflow: hidden;
       }

       .coin-icon::after {
           content: '';
           position: absolute;
           top: 3px;
           left: 3px;
           width: 6px;
           height: 6px;
           background: rgba(255, 255, 255, 0.8);
           border-radius: 50%;
       }

       .coin-amount {
           font-weight: bold;
           font-size: 1.1rem;
           color: #FFD700;
           text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
       }

       .game-board {
           flex-grow: 1;
           position: relative;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           background: #1a1a2e;
           border-radius: 8px;
           margin: 1rem 0;
           min-height: 60vh;
           border: 1px solid rgba(77, 124, 255, 0.2);
           box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
           padding: 20px;
       }

       #game-canvas {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: transparent;
           z-index: 1;
           display: block;
       }

       .game-overlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           background: rgba(0, 8, 30, 0.85);
           z-index: 100; /* Higher z-index to ensure it's above everything */
           opacity: 0;
           pointer-events: none;
           transition: opacity 0.3s ease;
           backdrop-filter: blur(4px);
       }

       .game-overlay.visible {
           opacity: 1;
           pointer-events: all;
           animation: fadeIn 0.5s ease-out;
       }

       @keyframes fadeIn {
           from { opacity: 0; }
           to { opacity: 1; }
       }

       .overlay-content {
           text-align: center;
           padding: 2.5rem;
           background: linear-gradient(135deg, rgba(13, 21, 40, 0.9), rgba(5, 10, 30, 0.9));
           border-radius: 10px;
           border: 1px solid rgba(77, 124, 255, 0.3);
           box-shadow: 0 0 30px rgba(77, 124, 255, 0.2);
           max-width: 80%;
           animation: floatEffect 4s infinite ease-in-out;
       }

       @keyframes floatEffect {
           0%, 100% { transform: translateY(0); }
           50% { transform: translateY(-10px); }
       }

       .overlay-title {
           font-size: 2.5rem;
           margin-bottom: 1rem;
           text-transform: uppercase;
           letter-spacing: 3px;
           font-weight: bold;
       }

       .overlay-title.win {
           background: linear-gradient(45deg, #4CAF50, #8BC34A);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
       }

       .overlay-title.lose {
           background: linear-gradient(45deg, #f44336, #E91E63);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
       }

       .overlay-title.push {
           background: linear-gradient(45deg, #FFC107, #FF9800);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
       }

       .overlay-message {
           font-size: 1.2rem;
           margin-bottom: 2rem;
           color: #aac4ff;
           line-height: 1.6;
       }

       .game-btn {
           padding: 0.75rem 2rem;
           font-size: 1.2rem;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           color: #fff;
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           cursor: pointer;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.2);
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 2px;
           font-weight: bold;
           position: relative;
           overflow: hidden;
           margin: 0.5rem;
       }

       .game-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
           transition: all 0.6s ease;
       }

       .game-btn:hover::before {
           left: 100%;
       }

       .game-btn:hover {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: translateY(-2px);
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.3);
       }

       .game-btn:active {
           transform: translateY(1px);
       }

       .game-btn:disabled {
           opacity: 0.5;
           cursor: not-allowed;
           background: linear-gradient(135deg, #444, #333);
       }

       .game-btn.insufficient {
           background: linear-gradient(135deg, #70283f, #350f1a);
           color: #ffcccc;
           border-color: rgba(244, 67, 54, 0.4);
       }

       .controls {
           display: flex;
           justify-content: center;
           align-items: center;
           padding: 1rem 0;
           gap: 1rem;
           z-index: 10;
       }

       .restart-btn {
           padding: 0.75rem 1.5rem;
           font-size: 1rem;
           background: linear-gradient(135deg, #192238, #0d1526);
           color: #aac4ff;
           border: 1px solid rgba(77, 124, 255, 0.2);
           border-radius: 30px;
           cursor: pointer;
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 1px;
           position: relative;
           overflow: hidden;
       }

       .restart-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
           transition: all 0.6s ease;
       }

       .restart-btn:hover::before {
           left: 100%;
       }

       .restart-btn:hover {
           color: #fff;
           border-color: rgba(77, 124, 255, 0.4);
           background: linear-gradient(135deg, #243252, #131e36);
       }

       /* Special Effects */
       @keyframes glow {
           0% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
           50% { filter: drop-shadow(0 0 10px rgba(77, 124, 255, 0.9)); }
           100% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
       }

       /* Blackjack specific styles */
       #blackjack-container {
           display: flex;
           flex-direction: column;
           justify-content: space-between;
           width: 100%;
           height: 100%;
           z-index: 10;
       }

       .dealer-area, .player-area {
           display: flex;
           flex-direction: column;
           align-items: center;
           width: 100%;
           height: 40%;
           position: relative;
       }

       .area-label {
           font-size: 1.2rem;
           color: #aac4ff;
           margin-bottom: 10px;
           text-transform: uppercase;
           letter-spacing: 2px;
       }

       .hand-value {
           font-size: 1.5rem;
           font-weight: bold;
           color: #fff;
           margin: 5px 0;
           text-shadow: 0 0 10px rgba(77, 124, 255, 0.7);
       }

       .cards-container {
           display: flex;
           justify-content: center;
           align-items: center;
           gap: 10px;
           min-height: 150px;
           width: 100%;
           position: relative;
       }

       .card {
           width: 100px;
           height: 140px;
           background: #fff;
           border-radius: 8px;
           box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
           display: flex;
           flex-direction: column;
           justify-content: space-between;
           padding: 5px;
           font-weight: bold;
           position: relative;
           transition: transform 0.3s ease;
           transform-style: preserve-3d;
           perspective: 1000px;
       }

       .card.hidden {
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           border: 2px solid rgba(77, 124, 255, 0.4);
           display: flex;
           justify-content: center;
           align-items: center;
       }

       .card.hidden::after {
           content: '?';
           font-size: 3rem;
           color: #4d7cff;
           text-shadow: 0 0 5px rgba(77, 124, 255, 0.5);
       }

       .card.red {
           color: #e91e63;
       }

       .card.black {
           color: #000;
       }

       .card-top, .card-bottom {
           display: flex;
           flex-direction: column;
           align-items: flex-start;
       }

       .card-bottom {
           transform: rotate(180deg);
       }

       .card-value {
           font-size: 1.5rem;
           line-height: 1;
       }

       .card-suit {
           font-size: 1.2rem;
       }

       .card-center {
           display: flex;
           justify-content: center;
           align-items: center;
           flex-grow: 1;
           font-size: 3rem;
       }

       .bet-controls {
           display: flex;
           flex-direction: column;
           align-items: center;
           padding: 15px;
           gap: 10px;
           width: 100%;
       }

       .bet-amount {
           font-size: 1.5rem;
           font-weight: bold;
           color: #FFD700;
           text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
       }

       .bet-btns {
           display: flex;
           gap: 10px;
           flex-wrap: wrap;
           justify-content: center;
       }

       .bet-btn {
           padding: 8px 15px;
           background: linear-gradient(135deg, #2e7d32, #1b5e20);
           color: #fff;
           border: 1px solid rgba(76, 175, 80, 0.4);
           border-radius: 20px;
           cursor: pointer;
           transition: all 0.3s ease;
           font-weight: bold;
       }

       .bet-btn:hover {
           background: linear-gradient(135deg, #388e3c, #2e7d32);
           transform: translateY(-2px);
       }

       .action-controls {
           display: flex;
           justify-content: center;
           gap: 10px;
           flex-wrap: wrap;
           margin-top: 10px;
       }

       .action-btn {
           padding: 10px 20px;
           font-size: 1rem;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           color: #fff;
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 25px;
           cursor: pointer;
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 1px;
           font-weight: bold;
       }

       .action-btn:hover {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: translateY(-2px);
       }

       .action-btn:disabled {
           opacity: 0.5;
           cursor: not-allowed;
           background: linear-gradient(135deg, #444, #333);
       }

       .game-status {
           text-align: center;
           margin: 10px 0;
           padding: 5px 15px;
           border-radius: 20px;
           background: rgba(10, 20, 40, 0.6);
           border: 1px solid rgba(77, 124, 255, 0.2);
           display: inline-block;
       }

       .win-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #4caf50;
           text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
       }

       .lose-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #f44336;
           text-shadow: 0 0 5px rgba(244, 67, 54, 0.5);
       }

       /* Animations */
       @keyframes dealCard {
           0% { transform: translateY(-200px) rotate(10deg); opacity: 0; }
           100% { transform: translateY(0) rotate(0); opacity: 1; }
       }

       @keyframes flipCard {
           0% { transform: rotateY(90deg); }
           100% { transform: rotateY(0); }
       }

       @keyframes cardGlow {
           0% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.5); }
           100% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.9); }
       }

       @keyframes cardShake {
           0%, 100% { transform: translateX(0); }
           25% { transform: translateX(-5px); }
           75% { transform: translateX(5px); }
       }

       /* Media queries for better responsiveness */
       @media (max-height: 700px) {
           .cards-container {
               min-height: 120px;
           }

           .card {
               width: 80px;
               height: 112px;
           }

           .card-value {
               font-size: 1.2rem;
           }

           .card-suit {
               font-size: 1rem;
           }

           .card-center {
               font-size: 2.5rem;
           }

           .bet-amount, .hand-value {
               font-size: 1.2rem;
           }

           .action-btn, .bet-btn {
               padding: 8px 15px;
               font-size: 0.9rem;
           }
       }

       @media (max-width: 600px) {
           .card {
               width: 60px;
               height: 84px;
           }

           .card-value {
               font-size: 1rem;
           }

           .card-suit {
               font-size: 0.8rem;
           }

           .card-center {
               font-size: 2rem;
           }

           .overlay-title {
               font-size: 1.8rem;
           }

           .overlay-message {
               font-size: 0.9rem;
           }

           .game-title {
               font-size: 1.8rem;
           }

           .action-btn, .bet-btn {
               padding: 6px 12px;
               font-size: 0.8rem;
           }
       }
   </style>
</head>

<body>
   <div class="game-container">
       <div class="game-header">
           <h1 class="game-title">Blackjack</h1>
           <p class="game-subtitle">Beat the dealer to 21</p>
           <div class="coin-tracker">
               <div class="coin-icon"></div>
               <span class="coin-amount" id="coinDisplay">0</span>
           </div>
       </div>

       <div class="game-board">
           <canvas id="game-canvas"></canvas>
           <div id="blackjack-container" style="display: none;">
               <div class="dealer-area">
                   <div class="area-label">Dealer</div>
                   <div class="hand-value" id="dealer-value">0</div>
                   <div class="cards-container" id="dealer-cards"></div>
               </div>
               
               <div class="bet-controls" id="bet-controls">
                   <div class="game-status" id="game-status">Place your bet to start</div>
                   <div class="bet-amount">Bet: <span id="bet-amount">0</span> coins</div>
                   <div class="bet-btns">
                       <button class="bet-btn" data-amount="10">+10</button>
                       <button class="bet-btn" data-amount="50">+50</button>
                       <button class="bet-btn" data-amount="100">+100</button>
                       <button class="bet-btn" data-amount="500">+500</button>
                       <button class="bet-btn" data-amount="1000">+1000</button>
                       <button class="bet-btn" data-amount="clear">Clear</button>
                       <button class="bet-btn" id="deal-btn">Deal</button>
                   </div>
               </div>
               
               <div class="action-controls" id="action-controls" style="display: none;">
                   <button class="action-btn" id="hit-btn">Hit</button>
                   <button class="action-btn" id="stand-btn">Stand</button>
                   <button class="action-btn" id="double-btn">Double</button>
               </div>
               
               <div class="player-area">
                   <div class="area-label">Player</div>
                   <div class="hand-value" id="player-value">0</div>
                   <div class="cards-container" id="player-cards"></div>
               </div>
           </div>

           <!-- Start Screen Overlay -->
           <div class="game-overlay visible" id="start-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title">Blackjack</h2>
                   <p class="overlay-message">
                       Try to beat the dealer by getting a hand value closer to 21 without going over.<br>
                       • Blackjack pays 3:2<br>
                       • Dealer stands on all 17s<br>
                       • Double down on any two cards<br>
                       • No splitting or insurance
                   </p>
                   <button id="start-btn" class="game-btn">Start Game</button>
               </div>
           </div>

           <!-- Login Required Overlay -->
           <div class="game-overlay" id="login-required-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title" style="background: linear-gradient(45deg, #FF9800, #F44336); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Login Required</h2>
                   <p class="overlay-message">
                       You need to be logged in to play Blackjack.<br>
                       Please sign in to your Void Games account.
                   </p>
                   <button id="login-btn" class="game-btn">Go to Login</button>
               </div>
           </div>

           <!-- Game Result Overlay -->
           <div class="game-overlay" id="result-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title" id="result-title">You Win!</h2>
                   <p class="overlay-message" id="result-message">
                       You beat the dealer!<br>
                       You won: <span class="win-amount">0</span> coins!
                   </p>
                   <button id="play-again-btn" class="game-btn">Play Again</button>
               </div>
           </div>
       </div>

       <div class="controls">
           <button id="back-btn" class="restart-btn">Back to Beta Games</button>
       </div>
   </div>

   <!-- Firebase SDK -->
   <script type="module">
       // Firebase Imports
       import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
       import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
       import { getFirestore, doc, getDoc, updateDoc, setDoc, collection, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore.js";

       // Firebase Configuration - UPDATED
       const firebaseConfig = {
           apiKey: "AIzaSyCkAp_GCGCtw4zv7GgHJOE9GPgIaPEuOvQ",
           authDomain: "void-games-c8d9e.firebaseapp.com",
           projectId: "void-games-c8d9e",
           storageBucket: "void-games-c8d9e.firebasestorage.app",
           messagingSenderId: "1063089929776",
           appId: "1:1063089929776:web:8e226a23a4f3ab9c5777f5"
       };

       // Initialize Firebase
       const app = initializeApp(firebaseConfig);
       const auth = getAuth(app);
       const db = getFirestore(app);

       // Secure game session with a unique token
       const sessionToken = generateSecureToken();
       
       // Authentication and Coin Management with security improvements
       let currentUser = null;
       let firebaseCoinBalance = 0;
       let lastServerBalance = 0; // Track last known server balance
       let lastTransactionTime = Date.now(); // Track transaction timing for rate limiting
       let gameSessionData = { // Store game session data with validation
           initialBalance: 0,
           transactions: [],
           sessionToken: sessionToken
       };

       // Security function - Generate secure token for this session
       function generateSecureToken() {
           const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
           let token = '';
           const randomValues = new Uint32Array(32);
           crypto.getRandomValues(randomValues);
           randomValues.forEach(val => {
               token += chars[val % chars.length];
           });
           return token + Date.now().toString(36);
       }

       // Security function - Validate transaction request
       function validateTransaction(amount, type, currentBalance) {
           // Rate limiting check - prevent rapid transactions
           const now = Date.now();
           if (now - lastTransactionTime < 500) { // 500ms minimum between transactions
               console.warn("Transaction rate limit exceeded");
               return false;
           }
           
           // Validate the amount makes sense for the transaction type
           if (type === 'win' && amount <= 0) {
               console.warn("Invalid win amount");
               return false;
           }
           
           if (type === 'bet' && (amount <= 0 || amount > currentBalance)) {
               console.warn("Invalid bet amount");
               return false;
           }
           
           // Basic integrity check - transaction seems valid
           lastTransactionTime = now;
           return true;
       }

       // Authentication State Listener
       onAuthStateChanged(auth, async (user) => {
           if (user) {
               // User is signed in
               currentUser = user;
               console.log("User signed in:", user.uid);
               await loadFirebaseCoinBalance();
               
               // Setup session data for this player
               gameSessionData.initialBalance = firebaseCoinBalance;
               gameSessionData.userId = user.uid;
               gameSessionData.sessionStartTime = Date.now();
               
               // Store initial game session in Firebase for validation
               try {
                   const sessionRef = doc(collection(db, 'gameSessions'));
                   await setDoc(sessionRef, {
                       userId: user.uid,
                       gameId: 'blackjack_game',
                       initialBalance: firebaseCoinBalance,
                       sessionToken: sessionToken,
                       startTime: serverTimestamp(),
                       device: {
                           userAgent: navigator.userAgent,
                           platform: navigator.platform,
                           screen: `${window.screen.width}x${window.screen.height}`
                       }
                   });
                   gameSessionData.sessionId = sessionRef.id;
               } catch (error) {
                   console.error("Error creating game session:", error);
               }
           } else {
               // No user is signed in - use default balance
               currentUser = null;
               console.log("No user signed in, using default balance");
               
               // Use the secure accessor function instead of direct window.coinBalance
               _secureGameState.updateBalance(1000);
               _secureGameState.updateDisplay();
           }
       });

       // Load Coin Balance from Firebase with additional validation
       async function loadFirebaseCoinBalance() {
           if (!currentUser) {
               console.log("No user available to load balance");
               return;
           }

           try {
               console.log("Loading balance for user:", currentUser.uid);

               // Use currentUser.uid and force server data retrieval
               const userRef = doc(db, 'users', currentUser.uid);
               const userDoc = await getDoc(userRef, { source: 'server' }); // Force server data

               if (userDoc.exists()) {
                   // Get coin balance from Firestore
                   const userData = userDoc.data();

                   // IMPORTANT: Use accountBalance field for consistency with main page
                   firebaseCoinBalance = userData.accountBalance || 0;
                   lastServerBalance = firebaseCoinBalance; // Store server balance
                   
                   console.log("Loaded balance from Firebase:", firebaseCoinBalance);

                   // Update local game state through secure function
                   _secureGameState.updateBalance(firebaseCoinBalance);
                   _secureGameState.updateDisplay();

                   console.log("Updated local balance:", _secureGameState.getBalance());
                   return firebaseCoinBalance;
               } else {
                   console.log("User document doesn't exist, creating new one");
                   // Create initial balance if no document exists
                   const initialBalance = 1000;
                   
                   await setDoc(userRef, { 
                     accountBalance: initialBalance,
                     username: currentUser.displayName || "Player",
                     email: currentUser.email,
                     createdAt: serverTimestamp(),
                     totalGamesPlayed: 0,
                     totalMoneySpent: 0,
                     totalMoneyEarned: 0
                   });

                   firebaseCoinBalance = initialBalance;
                   lastServerBalance = initialBalance;
                   
                   _secureGameState.updateBalance(initialBalance);
                   _secureGameState.updateDisplay();
                   return initialBalance;
               }
           } catch (error) {
               console.error("Error loading coin balance:", error);
               
               // Fallback to default value
               const defaultBalance = 1000;
               _secureGameState.updateBalance(defaultBalance);
               _secureGameState.updateDisplay();
               return defaultBalance;
           }
       }

       // Record Game Transaction with enhanced security
       async function recordGameTransaction(gameId, amount, isWin) {
           if (!currentUser) return null;

           // First validate the transaction
           const transactionType = isWin ? 'win' : 'bet';
           if (!validateTransaction(amount, transactionType, _secureGameState.getBalance())) {
               console.error("Transaction validation failed");
               return null;
           }

           try {
               // Get current server balance before making changes
               const userRef = doc(db, 'users', currentUser.uid);
               const userDoc = await getDoc(userRef, { source: 'server' });
               
               if (!userDoc.exists()) {
                   console.error("User document not found");
                   return null;
               }
               
               const userData = userDoc.data();
               const currentServerBalance = userData.accountBalance || 0;
               
               // Verify balance hasn't been tampered with
               if (Math.abs(currentServerBalance - lastServerBalance) > 10) {
                   console.error("Balance verification failed - possible tampering detected");
                   // Force refresh from server
                   await loadFirebaseCoinBalance();
                   return null;
               }
               
               // Calculate new balance
               let newBalance = currentServerBalance;
               if (isWin) {
                   newBalance += amount;
                   userData.totalMoneyEarned = (userData.totalMoneyEarned || 0) + amount;
               } else {
                   newBalance -= amount;
                   userData.totalGamesPlayed = (userData.totalGamesPlayed || 0) + 1;
                   userData.totalMoneySpent = (userData.totalMoneySpent || 0) + amount;
               }
               
               // Create transaction record
               const transactionRef = doc(collection(db, 'transactions'));
               const transactionData = {
                   userId: currentUser.uid,
                   gameId: gameId,
                   transactionType: isWin ? 'game_win' : 'game_play',
                   amount: amount,
                   timestamp: serverTimestamp(),
                   previousBalance: currentServerBalance,
                   newBalance: newBalance,
                   sessionToken: sessionToken,
                   sessionId: gameSessionData.sessionId || null
               };
               
               // Store the transaction in our secure game state
               gameSessionData.transactions.push({
                   type: transactionType,
                   amount: amount,
                   timestamp: Date.now(),
                   balance: _secureGameState.getBalance()
               });
               
               // Update user document with new balance
               await updateDoc(userRef, {
                   accountBalance: newBalance,
                   totalGamesPlayed: userData.totalGamesPlayed || 0,
                   totalMoneySpent: userData.totalMoneySpent || 0,
                   totalMoneyEarned: userData.totalMoneyEarned || 0,
                   lastUpdated: serverTimestamp()
               });
               
               // Record the transaction
               await setDoc(transactionRef, transactionData);
               
               // Update our local tracking
               lastServerBalance = newBalance;
               _secureGameState.updateBalance(newBalance);
               _secureGameState.updateDisplay();
               
               return {
                   transactionId: transactionRef.id,
                   newBalance: newBalance
               };
           } catch (error) {
               console.error("Transaction Error:", error);
               return null;
           }
       }

       // Create a secure encapsulated game state manager (using IIFE pattern)
       // Create this early to ensure it's available throughout the app lifecycle
       const _secureGameState = (function() {
           // Private variables that can't be accessed directly from console
           let _balance = 1000; // Default starting balance to avoid showing 0
           let _coinDisplay = null;
           let _transactionLock = false;
           
           // Initialize the display element reference
           function _initDisplay() {
               _coinDisplay = document.getElementById('coinDisplay');
               if (_coinDisplay) {
                   _coinDisplay.textContent = _balance.toLocaleString();
               }
           }
           
           // Update the display with current balance
           function _updateDisplay() {
               if (!_coinDisplay) _initDisplay();
               if (_coinDisplay) {
                   _coinDisplay.textContent = _balance.toLocaleString();
               }
           }
           
           // Call init on document ready
           document.addEventListener('DOMContentLoaded', function() {
               _initDisplay();
           });
           
           // Return only the methods we want to expose
           return {
               getBalance: function() {
                   return _balance;
               },
               updateBalance: function(newBalance) {
                   if (typeof newBalance !== 'number' || isNaN(newBalance)) {
                       console.error("Invalid balance update attempted");
                       return false;
                   }
                   _balance = newBalance;
                   _updateDisplay(); // Update display immediately
                   return true;
               },
               updateDisplay: function() {
                   _updateDisplay();
               },
               applyTransaction: async function(amount, isWin) {
                   // Use transaction lock to prevent concurrent modifications
                   if (_transactionLock) return false;
                   
                   try {
                       _transactionLock = true;
                       
                       // First update local state for responsive UI
                       let newBalance = _balance;
                       if (isWin) {
                           newBalance += amount;
                       } else {
                           newBalance -= amount;
                       }
                       
                       // Update local balance temporarily
                       _balance = newBalance;
                       _updateDisplay();
                       
                       // Apply server-side change
                       const result = await recordGameTransaction('blackjack_game', amount, isWin);
                       
                       // If server transaction failed, revert the local update
                       if (!result) {
                           console.warn("Server transaction failed, reverting local balance");
                           await loadFirebaseCoinBalance(); // Refresh from server
                           return false;
                       }
                       
                       return true;
                   } catch (error) {
                       console.error("Transaction error:", error);
                       return false;
                   } finally {
                       _transactionLock = false;
                   }
               }
           };
       })();

       // Create and expose methods only through secure wrapper functions
       // Define this early to ensure availability
       window.gameInterface = {
           getBalance: function() {
               return _secureGameState.getBalance();
           },
           processTransaction: async function(amount, isWin) {
               return await _secureGameState.applyTransaction(amount, isWin);
           },
           updateDisplay: function() {
               _secureGameState.updateDisplay();
           },
           refreshBalance: async function() {
               return await loadFirebaseCoinBalance();
           }
       };

       // Anti-debugging measure - detect console open
       (function() {
           let devtoolsOpen = false;
           
           // Method 1: Check for firebug
           if (window.Firebug && window.Firebug.chrome && window.Firebug.chrome.isInitialized) {
               devtoolsOpen = true;
           }
           
           // Method 2: Console timing method
           const threshold = 160;
           const start = Date.now();
           
           function checkTime() {
               // Check time spent executing this function
               // If debugger is open, this takes longer to execute
               const end = Date.now();
               if (end - start > threshold) {
                   console.warn("Developer tools detected");
                   // Additional security measures could be taken here
               }
           }
           
           checkTime();
           
           // Method 3: Monitor console logging (limited protection)
           const originalLog = console.log;
           console.log = function() {
               originalLog.apply(console, arguments);
               
               // Check if someone is trying to inspect the game state
               const logString = Array.from(arguments).join(" ").toLowerCase();
               if (logString.includes("coin") || logString.includes("balance") || 
                   logString.includes("firebase") || logString.includes("cheat")) {
                   console.warn("Suspicious console activity detected");
               }
           };
       })();
       
       // Add protection against tampering
       Object.freeze(window.gameInterface);
   </script>

   <script>
// SECURE BLACKJACK GAME IMPLEMENTATION
// All game logic is encapsulated in an IIFE to prevent direct access from console

(function() {
    // Game Configuration
    const GAME_CONFIG = {
        gameId: 'blackjack_game', // ID for Firebase transactions
        minBet: 10,           // Minimum bet amount
        maxBet: 10000,        // Maximum bet amount
        blackjackPayout: 1.5, // Blackjack pays 3:2
        hiddenEntryFee: 5,    // Small hidden fee per hand (not shown to user)
        dealerStandValue: 17, // Dealer stands on all 17s
    };

    // Game state
    let canvas, ctx;
    let canvasWidth, canvasHeight;
    let animationFrame;
    let gameActive = false;
    let currentBet = 0;
    let dealerCards = [];
    let playerCards = [];
    let isDealerTurn = false;
    let gameResult = null; // 'win', 'lose', 'push', 'blackjack'
    let canDouble = false;

    // Security - Hash of the game state for validation
    let gameStateHash = '';
    let lastGameAction = '';
    let actionCounter = 0;
    let initializationMode = true; // Allow initialization without validation errors

    // Deck state
    let deck = [];
    const suits = ['♥', '♦', '♠', '♣'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

    // DOM elements
    let startScreen;
    let resultScreen;
    let startBtn;
    let playAgainBtn;
    let backBtn;
    let blackjackContainer;
    let dealerCardsContainer;
    let playerCardsContainer;
    let dealerValueDisplay;
    let playerValueDisplay;
    let betAmount;
    let betControls;
    let actionControls;
    let dealBtn;
    let hitBtn;
    let standBtn;
    let doubleBtn;
    let gameStatus;
    let resultTitle;
    let resultMessage;

    // Security function - Generate a hash for game state validation
    function hashGameState() {
        try {
            // Create a string representing critical game state
            // Use a simpler representation that's less prone to false positives
            const stateString = JSON.stringify({
                playerCardCount: playerCards.length,
                dealerCardCount: dealerCards.length,
                betPhase: actionControls ? actionControls.style.display === 'none' : true,
                gameActive: gameActive
            });
            
            // Simple hash function
            let hash = 0;
            for (let i = 0; i < stateString.length; i++) {
                const char = stateString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            
            return hash.toString(16);
        } catch (error) {
            console.error("Error generating hash:", error);
            return "error";
        }
    }
    
    // Security function - Validate game state integrity
    function validateGameState() {
        // Skip validation during initialization to prevent false positives
        if (initializationMode) {
            return true;
        }
        
        // Skip validation during bet phase which has frequent small changes
        if (betControls && betControls.style.display === 'block') {
            // During betting, we'll just update the hash without validation
            gameStateHash = hashGameState();
            return true;
        }
        
        const currentHash = hashGameState();
        
        // If we have a previous hash to compare against and it's not equal
        if (gameStateHash && gameStateHash !== currentHash && gameStateHash !== "error" && currentHash !== "error") {
            console.error("Game state tampering detected");
            // Could implement additional security measures here
            return false;
        }
        
        // Update the hash
        gameStateHash = currentHash;
        return true;
    }

    // Helper function to clear all timeouts
    function clearAllTimeouts() {
        // Create a very large number (bigger than any reasonable timeout id)
        const highestTimeoutId = setTimeout(() => {}, 0);
        
        // Clear all timeout IDs from 0 to the highest one
        for (let i = 0; i < highestTimeoutId; i++) {
            clearTimeout(i);
        }
    }

    // Initialize DOM elements
    function initDomElements() {
        startScreen = document.getElementById('start-screen');
        resultScreen = document.getElementById('result-screen');
        startBtn = document.getElementById('start-btn');
        playAgainBtn = document.getElementById('play-again-btn');
        backBtn = document.getElementById('back-btn');
        blackjackContainer = document.getElementById('blackjack-container');
        dealerCardsContainer = document.getElementById('dealer-cards');
        playerCardsContainer = document.getElementById('player-cards');
        dealerValueDisplay = document.getElementById('dealer-value');
        playerValueDisplay = document.getElementById('player-value');
        betAmount = document.getElementById('bet-amount');
        betControls = document.getElementById('bet-controls');
        actionControls = document.getElementById('action-controls');
        dealBtn = document.getElementById('deal-btn');
        hitBtn = document.getElementById('hit-btn');
        standBtn = document.getElementById('stand-btn');
        doubleBtn = document.getElementById('double-btn');
        gameStatus = document.getElementById('game-status');
        resultTitle = document.getElementById('result-title');
        resultMessage = document.getElementById('result-message');
        
        // Ensure balance display is up to date - with error handling
        try {
            if (window.gameInterface && typeof window.gameInterface.updateDisplay === 'function') {
                window.gameInterface.updateDisplay();
            } else {
                console.log("Game interface not ready yet, display will update when ready");
                // Fallback direct update
                const coinDisplay = document.getElementById('coinDisplay');
                if (coinDisplay) {
                    coinDisplay.textContent = "1000";
                }
            }
        } catch (err) {
            console.error("Error updating coin display:", err);
        }
    }

    // Update coin balance - Using the secure gameInterface instead of direct manipulation
    async function updateCoins(amount, isWin = true) {
        // Log the attempt for debugging
        console.log(`Updating coins: current=${window.gameInterface.getBalance()}, change=${amount}`);
        
        // Use the secure game interface to update coins
        const success = await window.gameInterface.processTransaction(Math.abs(amount), isWin);
        
        if (!success) {
            console.error("Failed to update coins");
            // Force refresh from server as a fallback
            await window.gameInterface.refreshBalance();
        }
        
        // Update game state hash after balance change
        validateGameState();
    }

    // Initialize canvas for background
    function initCanvas() {
        canvas = document.getElementById('game-canvas');
        if (!canvas) {
            console.error("Canvas element not found!");
            return;
        }

        ctx = canvas.getContext('2d');

        const gameBoard = document.querySelector('.game-board');
        if (!gameBoard) {
            console.error("Game board element not found!");
            return;
        }

        // Get actual dimensions of the game board
        canvasWidth = gameBoard.clientWidth;
        canvasHeight = gameBoard.clientHeight;

        // Set canvas dimensions
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = canvasWidth + "px";
        canvas.style.height = canvasHeight + "px";
    }

    // Create a new shuffled deck with improved randomness
    function createDeck() {
        deck = [];
        for (let suit of suits) {
            for (let value of values) {
                deck.push({ suit, value });
            }
        }
        shuffleDeck();
    }

    // Shuffle the deck with cryptographically secure randomness
    function shuffleDeck() {
        // Get cryptographically secure random values if available
        const getSecureRandom = () => {
            if (window.crypto && window.crypto.getRandomValues) {
                const rand = new Uint32Array(1);
                window.crypto.getRandomValues(rand);
                return rand[0] / (0xFFFFFFFF + 1);
            } else {
                return Math.random();
            }
        };
        
        // Fisher-Yates shuffle with secure randomness
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(getSecureRandom() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        
        // Track the shuffle in game state
        lastGameAction = 'shuffle';
        actionCounter++;
        validateGameState();
    }

    // Draw a card from the deck
    function drawCard() {
        // If deck is running low, create a new one
        if (deck.length < 10) {
            createDeck();
        }
        
        const card = deck.pop();
        
        // Track the action
        lastGameAction = 'draw';
        actionCounter++;
        validateGameState();
        
        return card;
    }

    // Get the value of a card
    function getCardValue(card) {
        if (card.value === 'A') {
            return 11; // Ace is initially 11, will be adjusted for soft hands
        } else if (['K', 'Q', 'J'].includes(card.value)) {
            return 10;
        } else {
            return parseInt(card.value);
        }
    }

    // Calculate the total value of a hand
    function calculateHandValue(cards) {
        let total = 0;
        let aces = 0;
        
        // Sum up all cards
        for (let card of cards) {
            if (card.value === 'A') {
                aces++;
                total += 11;
            } else if (['K', 'Q', 'J'].includes(card.value)) {
                total += 10;
            } else {
                total += parseInt(card.value);
            }
        }
        
        // Adjust for aces if needed (convert from 11 to 1)
        while (total > 21 && aces > 0) {
            total -= 10; // Change one ace from 11 to 1
            aces--;
        }
        
        return total;
    }

    // Check if a hand is a blackjack
    function isBlackjack(cards) {
        return cards.length === 2 && calculateHandValue(cards) === 21;
    }

    // Check if a hand is busted
    function isBusted(cards) {
        return calculateHandValue(cards) > 21;
    }

    // Create a card element
    function createCardElement(card, isHidden = false) {
        const cardElement = document.createElement('div');
        cardElement.className = 'card';
        
        if (isHidden) {
            cardElement.classList.add('hidden');
            return cardElement;
        }
        
        // Add red/black class based on suit
        if (card.suit === '♥' || card.suit === '♦') {
            cardElement.classList.add('red');
        } else {
            cardElement.classList.add('black');
        }
        
        // Create card layout
        const topSection = document.createElement('div');
        topSection.className = 'card-top';
        
        const valueTop = document.createElement('div');
        valueTop.className = 'card-value';
        valueTop.textContent = card.value;
        
        const suitTop = document.createElement('div');
        suitTop.className = 'card-suit';
        suitTop.textContent = card.suit;
        
        topSection.appendChild(valueTop);
        topSection.appendChild(suitTop);
        
        const centerSection = document.createElement('div');
        centerSection.className = 'card-center';
        centerSection.textContent = card.suit;
        
        const bottomSection = document.createElement('div');
        bottomSection.className = 'card-bottom';
        
        const valueBottom = document.createElement('div');
        valueBottom.className = 'card-value';
        valueBottom.textContent = card.value;
        
        const suitBottom = document.createElement('div');
        suitBottom.className = 'card-suit';
        suitBottom.textContent = card.suit;
        
        bottomSection.appendChild(valueBottom);
        bottomSection.appendChild(suitBottom);
        
        cardElement.appendChild(topSection);
        cardElement.appendChild(centerSection);
        cardElement.appendChild(bottomSection);
        
        // Add animation
        cardElement.style.animation = 'dealCard 0.5s forwards';
        
        return cardElement;
    }

    // Update the displayed hand value
    function updateHandValues() {
        if (playerValueDisplay) {
            playerValueDisplay.textContent = calculateHandValue(playerCards);
        }
        
        // Only show dealer's visible cards value if it's not dealer's turn
        if (dealerValueDisplay) {
            if (isDealerTurn) {
                dealerValueDisplay.textContent = calculateHandValue(dealerCards);
            } else {
                // Show value of visible cards only
                const visibleCards = dealerCards.slice(1);
                dealerValueDisplay.textContent = calculateHandValue(visibleCards);
            }
        }
    }

    // Render cards to the containers
    function renderCards() {
        // Clear containers
        if (playerCardsContainer) {
            playerCardsContainer.innerHTML = '';
        }
        if (dealerCardsContainer) {
            dealerCardsContainer.innerHTML = '';
        }
        
        // Render player cards
        playerCards.forEach(card => {
            const cardElement = createCardElement(card);
            playerCardsContainer.appendChild(cardElement);
        });
        
        // Render dealer cards
        dealerCards.forEach((card, index) => {
            // First card is hidden if not dealer's turn
            const isHidden = index === 0 && !isDealerTurn;
            const cardElement = createCardElement(card, isHidden);
            dealerCardsContainer.appendChild(cardElement);
        });
        
        // Update hand values
        updateHandValues();
        
        // Validate game state after rendering
        validateGameState();
    }

    // Deal initial cards
    async function dealInitialCards() {
        // Validate current game state
        if (!validateGameState()) {
            console.error("Game state validation failed during deal");
            await window.gameInterface.refreshBalance();
            resetGame();
            return;
        }
        
        // Apply hidden entry fee
        const entryFee = GAME_CONFIG.hiddenEntryFee;
        if (entryFee > 0) {
            console.log(`Applying hidden entry fee: ${entryFee} coins`);
            await updateCoins(entryFee, false);
        }
        
        // Reset cards
        playerCards = [];
        dealerCards = [];
        
        // Deal 2 cards to player and dealer (alternating)
        playerCards.push(drawCard());
        dealerCards.push(drawCard());
        playerCards.push(drawCard());
        dealerCards.push(drawCard());
        
        // Render the cards
        renderCards();
        
        // Track the deal
        lastGameAction = 'deal';
        actionCounter++;
        validateGameState();
        
        // Check for blackjack
        const playerHasBlackjack = isBlackjack(playerCards);
        const dealerHasBlackjack = isBlackjack(dealerCards);
        
        if (playerHasBlackjack || dealerHasBlackjack) {
            // Reveal dealer's cards immediately for blackjack
            isDealerTurn = true;
            renderCards();
            
            if (playerHasBlackjack && dealerHasBlackjack) {
                // Both have blackjack - push
                gameResult = 'push';
                updateGameStatus("Both have Blackjack! Push!");
                setTimeout(() => {
                    endGame();
                }, 1500);
            } else if (playerHasBlackjack) {
                // Player has blackjack
                gameResult = 'blackjack';
                updateGameStatus("Blackjack! You win!");
                setTimeout(() => {
                    endGame();
                }, 1500);
            } else {
                // Dealer has blackjack
                gameResult = 'lose';
                updateGameStatus("Dealer has Blackjack! You lose.");
                setTimeout(() => {
                    endGame();
                }, 1500);
            }
        } else {
            // Game continues - enable player actions
            enablePlayerActions();
            
            // Check if player can double down
            canDouble = window.gameInterface.getBalance() >= currentBet;
            doubleBtn.disabled = !canDouble;
        }
    }

    // Enable player action buttons
    function enablePlayerActions() {
        if (actionControls) {
            actionControls.style.display = 'flex';
        }
        if (betControls) {
            betControls.style.display = 'none';
        }
        
        // Update game status
        updateGameStatus("Your turn");
        
        // Track the action
        lastGameAction = 'enableActions';
        actionCounter++;
        validateGameState();
    }

    // Disable player action buttons
    function disablePlayerActions() {
        if (actionControls) {
            actionControls.style.display = 'none';
        }
        
        // Track the action
        lastGameAction = 'disableActions';
        actionCounter++;
        validateGameState();
    }

    // Update the game status message
    function updateGameStatus(message) {
        if (gameStatus) {
            gameStatus.textContent = message;
        }
    }

    // Player hits - take another card
    function playerHit() {
        // Validate current game state
        if (!validateGameState()) {
            console.error("Game state validation failed during hit");
            resetGame();
            return;
        }
        
        // Track the action
        lastGameAction = 'hit';
        actionCounter++;
        
        // Draw a card and add to player's hand
        const card = drawCard();
        playerCards.push(card);
        
        // Render cards
        renderCards();
        
        // Check if player busts
        if (isBusted(playerCards)) {
            gameResult = 'lose';
            updateGameStatus("Busted! You went over 21.");
            disablePlayerActions();
            setTimeout(() => {
                endGame();
            }, 1500);
        }
        
        // Validate state after action
        validateGameState();
    }

    // Player stands - end turn and dealer plays
    function playerStand() {
        // Validate current game state
        if (!validateGameState()) {
            console.error("Game state validation failed during stand");
            resetGame();
            return;
        }
        
        // Track the action
        lastGameAction = 'stand';
        actionCounter++;
        
        disablePlayerActions();
        dealerPlay();
        
        // Validate state after action
        validateGameState();
    }

    // Player doubles down
    async function playerDoubleDown() {
        // Validate current game state
        if (!validateGameState()) {
            console.error("Game state validation failed during double down");
            resetGame();
            return;
        }
        
        // Track the action
        lastGameAction = 'double';
        actionCounter++;
        
        // Double the bet
        await updateCoins(currentBet, false);
        currentBet *= 2;
        
        // Update bet display
        if (betAmount) {
            betAmount.textContent = currentBet.toLocaleString();
        }
        
        // Take only one card
        playerHit();
        
        // If not busted, stand
        if (!isBusted(playerCards)) {
            setTimeout(() => {
                playerStand();
            }, 1000);
        }
        
        // Validate state after action
        validateGameState();
    }

    // Dealer plays their turn
    function dealerPlay() {
        // Track the action
        lastGameAction = 'dealerPlay';
        actionCounter++;
        
        isDealerTurn = true;
        renderCards();
        updateGameStatus("Dealer's turn");
        
        // Function to add cards to dealer with delay
        function dealerDraw() {
            // Validate state in each step
            if (!validateGameState()) {
                console.error("Game state validation failed during dealer draw");
                resetGame();
                return;
            }
            
            // Get current dealer hand value
            const dealerValue = calculateHandValue(dealerCards);
            
            if (dealerValue < GAME_CONFIG.dealerStandValue) {
                // Dealer hits
                setTimeout(() => {
                    const card = drawCard();
                    dealerCards.push(card);
                    renderCards();
                    
                    // Continue drawing if needed
                    dealerDraw();
                }, 800); // Delay between dealer draws
            } else {
                // Dealer stands - evaluate result
                setTimeout(() => {
                    evaluateResult();
                }, 1000);
            }
        }
        
        // Start dealer drawing
        dealerDraw();
        
        // Validate state after action
        validateGameState();
    }

    // Evaluate the game result
    function evaluateResult() {
        // Track the action
        lastGameAction = 'evaluate';
        actionCounter++;
        
        const playerValue = calculateHandValue(playerCards);
        const dealerValue = calculateHandValue(dealerCards);
        
        if (isBusted(dealerCards)) {
            // Dealer busts, player wins
            gameResult = 'win';
            updateGameStatus("Dealer busts! You win!");
        } else if (playerValue > dealerValue) {
            // Player has higher value
            gameResult = 'win';
            updateGameStatus("You win!");
        } else if (playerValue < dealerValue) {
            // Dealer has higher value
            gameResult = 'lose';
            updateGameStatus("Dealer wins!");
        } else {
            // Equal values - push
            gameResult = 'push';
            updateGameStatus("Push!");
        }
        
        setTimeout(() => {
            endGame();
        }, 1500);
        
        // Validate state after action
        validateGameState();
    }

    // End the game and show result
    async function endGame() {
        // Track the action
        lastGameAction = 'endGame';
        actionCounter++;
        
        let winAmount = 0;
        
        switch (gameResult) {
            case 'blackjack':
                // Blackjack pays 3:2
                winAmount = Math.floor(currentBet * GAME_CONFIG.blackjackPayout);
                await updateCoins(currentBet + winAmount, true);
                showResult("Blackjack!", `You hit 21 with two cards!<br>You won: <span class="win-amount">${winAmount}</span> coins!`, 'win');
                break;
                
            case 'win':
                // Regular win pays 1:1
                winAmount = currentBet;
                await updateCoins(currentBet + winAmount, true);
                showResult("You Win!", `You beat the dealer!<br>You won: <span class="win-amount">${winAmount}</span> coins!`, 'win');
                break;
                
            case 'lose':
                // Player already paid bet at start
                showResult("You Lose!", `The dealer won this round.<br>You lost: <span class="lose-amount">${currentBet}</span> coins.`, 'lose');
                break;
                
            case 'push':
                // Return the original bet
                await updateCoins(currentBet, true);
                showResult("Push!", "It's a tie! Your bet has been returned.", 'push');
                break;
        }
        
        gameActive = false;
        
        // Clear the cards from the containers for a clean transition
        if (playerCardsContainer) {
            playerCardsContainer.innerHTML = '';
        }
        if (dealerCardsContainer) {
            dealerCardsContainer.innerHTML = '';
        }
        
        // Reset card arrays
        playerCards = [];
        dealerCards = [];
        
        // Validate final state
        validateGameState();
    }

    // Show the result screen
    function showResult(title, message, resultClass) {
        if (!resultScreen || !resultTitle || !resultMessage) {
            console.error("Result screen elements not found!");
            return;
        }
        
        // Set the result screen content
        resultTitle.textContent = title;
        resultTitle.className = `overlay-title ${resultClass}`;
        resultMessage.innerHTML = message;
        
        // Make result screen visible
        resultScreen.style.display = 'flex';
        resultScreen.classList.add('visible');
        
        // Force coin display update
        window.gameInterface.updateDisplay();
    }

    // Place a bet
    function placeBet(amount) {
        // Track the action
        lastGameAction = 'placeBet';
        actionCounter++;
        
        // Clear bet if requested
        if (amount === 'clear') {
            currentBet = 0;
            if (betAmount) {
                betAmount.textContent = '0';
            }
            
            // Validate state after action
            validateGameState();
            return;
        }
        
        // Add to current bet
        const newBet = currentBet + amount;
        
        // Validate bet against min/max and player balance
        if (newBet > window.gameInterface.getBalance()) {
            alert("You don't have enough coins for that bet!");
            return;
        }
        
        if (newBet > GAME_CONFIG.maxBet) {
            alert(`Maximum bet is ${GAME_CONFIG.maxBet.toLocaleString()} coins!`);
            return;
        }
        
        // Update current bet
        currentBet = newBet;
        if (betAmount) {
            betAmount.textContent = currentBet.toLocaleString();
        }
        
        // Enable deal button if bet meets minimum
        if (dealBtn) {
            dealBtn.disabled = currentBet < GAME_CONFIG.minBet;
        }
        
        // Validate state after action
        validateGameState();
    }

    // Start dealing cards
    async function startDeal() {
        // Enable initialization mode during dealing phase
        initializationMode = true;
        
        // Track the action
        lastGameAction = 'startDeal';
        actionCounter++;
        
        // Check minimum bet
        if (currentBet < GAME_CONFIG.minBet) {
            alert(`Minimum bet is ${GAME_CONFIG.minBet} coins!`);
            return;
        }
        
        // Check if player has enough balance
        if (currentBet > window.gameInterface.getBalance()) {
            alert("You don't have enough coins for that bet!");
            return;
        }
        
        // Deduct bet from balance
        await updateCoins(currentBet, false);
        
        // Deal initial cards
        await dealInitialCards();
        
        // Reset hash and disable initialization mode after cards dealt
        gameStateHash = hashGameState();
        setTimeout(() => {
            initializationMode = false;
        }, 1000);
    }

    // Initialize game
    function initGame() {
        // Check if user is logged in before allowing game to start
        if (!currentUser) {
            console.log("User not logged in, showing login screen");
            let loginScreen = document.getElementById('login-required-screen');
            let startScreen = document.getElementById('start-screen');
            
            if (startScreen) {
                startScreen.classList.remove('visible');
            }
            if (loginScreen) {
                loginScreen.classList.add('visible');
            }
            return;
        }
    
        // Set initialization mode to avoid false tampering detection
        initializationMode = true;
        
        // Reset game state
        gameActive = true;
        currentBet = 0;
        playerCards = [];
        dealerCards = [];
        isDealerTurn = false;
        gameResult = null;
        canDouble = false;
        actionCounter = 0;
        lastGameAction = 'init';
        
        // Create and shuffle the deck
        createDeck();
        
        // Update UI
        if (betAmount) {
            betAmount.textContent = '0';
        }
        
        // Hide start screen
        if (startScreen) {
            startScreen.classList.remove('visible');
        }
        
        // Show blackjack container
        if (blackjackContainer) {
            blackjackContainer.style.display = 'flex';
        }
        
        // Show bet controls, hide action controls
        if (betControls) {
            betControls.style.display = 'block';
        }
        if (actionControls) {
            actionControls.style.display = 'none';
        }
        
        // Disable deal button until a valid bet is placed
        if (dealBtn) {
            dealBtn.disabled = true;
        }
        
        // Update game status
        updateGameStatus("Place your bet to start");
        
        // Start game loop for background effects
        window.cancelAnimationFrame(animationFrame);
        gameLoop();
        
        // Set initial game state hash
        gameStateHash = hashGameState();
        
        // Turn off initialization mode after setup
        setTimeout(() => {
            initializationMode = false;
        }, 500);
    }

    // Reset the game
    function resetGame() {
        // Clear any pending timeouts
        clearAllTimeouts();
        
        // Set initialization mode to prevent validation errors
        initializationMode = true;
        
        // Hide result screen if visible
        if (resultScreen) {
            resultScreen.classList.remove('visible');
        }
        
        // Make sure card containers are empty
        if (playerCardsContainer) {
            playerCardsContainer.innerHTML = '';
        }
        if (dealerCardsContainer) {
            dealerCardsContainer.innerHTML = '';
        }
        
        // Reset hand value displays
        if (playerValueDisplay) {
            playerValueDisplay.textContent = '0';
        }
        if (dealerValueDisplay) {
            dealerValueDisplay.textContent = '0';
        }
        
        // Show bet controls, hide action controls
        if (betControls) {
            betControls.style.display = 'block';
        }
        if (actionControls) {
            actionControls.style.display = 'none';
        }
        
        // Reset game state
        actionCounter = 0;
        gameStateHash = ''; // Clear hash state
        
        // Reset game state for a new round
        initGame();
        
        // Return to normal validation after a delay
        setTimeout(() => {
            initializationMode = false;
        }, 1500);
    }

    // Draw stars in background
    function drawStars() {
        if (!ctx || !canvas) return;
        
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = '#FFFFFF';
        
        for (let i = 0; i < 100; i++) {
            // Create a deterministic but varied star pattern
            const seed = i * 12437; // Large prime number
            const x = (seed % canvasWidth) % canvasWidth;
            const y = (seed * 23 % canvasHeight) % canvasHeight;
            
            // Vary the star sizes
            const size = (i % 3) + 1;
            
            // Make stars twinkle
            const alpha = 0.3 + 0.7 * Math.sin(Date.now() * 0.001 + i);
            
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1.0;
    }

    // Game loop
    function gameLoop() {
        // Draw background
        drawStars();
        
        // Continue game loop
        animationFrame = requestAnimationFrame(gameLoop);
    }

    // Setup event listeners with security checks
    function setupEventListeners() {
        // Add a security check for all game actions
        const secureAction = (action) => {
            return function(event) {
                try {
                    // Check if user is logged in for game actions
                    if (!currentUser && this.id !== 'login-btn' && this.id !== 'back-btn') {
                        console.log("User not logged in, showing login screen");
                        let loginScreen = document.getElementById('login-required-screen');
                        let startScreen = document.getElementById('start-screen');
                        
                        if (startScreen) {
                            startScreen.classList.remove('visible');
                        }
                        if (loginScreen) {
                            loginScreen.classList.add('visible');
                        }
                        return;
                    }
                    
                    // Betting actions get special treatment
                    if (this && this.classList && this.classList.contains('bet-btn')) {
                        // Always allow bet buttons to work without validation
                        action.call(this, event);
                        return;
                    }
                    
                    // Check if we're in initialization mode
                    if (initializationMode) {
                        action.call(this, event);
                    } else {
                        // Verify game hasn't been tampered with
                        if (validateGameState()) {
                            action.call(this, event);
                        } else {
                            console.error("Game state validation failed");
                            // Prevent infinite reset loops by setting initialization mode
                            initializationMode = true;
                            resetGame();
                            setTimeout(() => {
                                initializationMode = false;
                            }, 1000);
                        }
                    }
                } catch (error) {
                    console.error("Error in game action:", error);
                    // Safe recovery
                    initializationMode = true;
                    resetGame();
                    setTimeout(() => {
                        initializationMode = false;
                    }, 1000);
                }
            };
        };
        
        // Start button
        if (startBtn) {
            startBtn.addEventListener('click', secureAction(function() {
                initGame();
            }));
        }
        
        // Play again button
        if (playAgainBtn) {
            playAgainBtn.addEventListener('click', secureAction(function() {
                resetGame();
            }));
        }
        
        // Back button
        if (backBtn) {
            backBtn.addEventListener('click', function() {
                window.location.href = '/voidgms.html';
            });
        }
        
        // Bet buttons
        const betButtons = document.querySelectorAll('.bet-btn');
        betButtons.forEach(button => {
            button.addEventListener('click', secureAction(function() {
                const betValue = this.getAttribute('data-amount');
                
                if (betValue === 'clear') {
                    placeBet('clear');
                } else if (this.id === 'deal-btn') {
                    startDeal();
                } else {
                    placeBet(parseInt(betValue));
                }
            }));
        });
        
        // Action buttons
        if (hitBtn) {
            hitBtn.addEventListener('click', secureAction(playerHit));
        }
        
        if (standBtn) {
            standBtn.addEventListener('click', secureAction(playerStand));
        }
        
        if (doubleBtn) {
            doubleBtn.addEventListener('click', secureAction(playerDoubleDown));
        }
        
        // Add resize event listener
        window.addEventListener('resize', function() {
            initCanvas();
            if (gameActive) {
                drawStars();
            }
        });
    }

    // Handle page visibility changes to prevent cheating via tab switching
    document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'hidden') {
            lastGameAction = 'pageHidden';
            actionCounter++;
        } else {
            lastGameAction = 'pageVisible';
            actionCounter++;
            // Re-validate when the page becomes visible again
            validateGameState();
        }
    });

    // Initialize the game after DOM is fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize DOM elements
        initDomElements();
        
        // Initialize canvas
        initCanvas();
        
        // Setup event listeners
        setupEventListeners();
        
        // Check user login status
        checkLoginStatus();
        
        // Initialize with default coin balance and check Firebase
        setTimeout(() => {
            // Delayed initialization to ensure firebase is fully loaded
            try {
                if (window.gameInterface && window.gameInterface.refreshBalance) {
                    window.gameInterface.refreshBalance().then(() => {
                        window.gameInterface.updateDisplay();
                    }).catch(err => {
                        console.error("Error refreshing balance:", err);
                        // Ensure a fallback value is displayed
                        const coinDisplay = document.getElementById('coinDisplay');
                        if (coinDisplay && coinDisplay.textContent === "0") {
                            coinDisplay.textContent = "1000";
                        }
                    });
                } else {
                    // Direct fallback if interface isn't ready
                    const coinDisplay = document.getElementById('coinDisplay');
                    if (coinDisplay && coinDisplay.textContent === "0") {
                        coinDisplay.textContent = "1000";
                    }
                }
            } catch (err) {
                console.error("Error in balance initialization:", err);
            }
        }, 500); // Short delay to ensure Firebase is initialized
        
        // Make doubly sure the result screen is initially hidden
        const resultScreen = document.getElementById('result-screen');
        if (resultScreen) {
            resultScreen.classList.remove('visible');
        }
        
        // Set initial game state hash
        validateGameState();
    });
    
    // Check if user is logged in
    function checkLoginStatus() {
        let loginScreen = document.getElementById('login-required-screen');
        let startScreen = document.getElementById('start-screen');
        let loginBtn = document.getElementById('login-btn');
        
        if (loginBtn) {
            loginBtn.addEventListener('click', function() {
                window.location.href = '/login.html'; // Redirect to login page
            });
        }
        
        setTimeout(() => {
            // Check after a short delay to ensure Firebase auth has initialized
            if (!currentUser) {
                console.log("No user logged in, showing login screen");
                if (startScreen) {
                    startScreen.classList.remove('visible');
                }
                if (loginScreen) {
                    loginScreen.classList.add('visible');
                }
            } else {
                console.log("User is logged in, game can start");
                if (loginScreen) {
                    loginScreen.classList.remove('visible');
                }
            }
        }, 1000);
    }

    // Anti-tampering - freeze global objects to prevent modification
    Object.freeze(GAME_CONFIG);
})();

// Security measures to prevent access to game internals
(function() {
    // Override common console methods used for cheating
    const originalSetInterval = window.setInterval;
    const originalSetTimeout = window.setTimeout;
    const originalEval = window.eval;
    
    // Override eval to prevent potential injection attacks
    window.eval = function(code) {
        if (typeof code === 'string') {
            // Detect attempts to manipulate coins/balance
            const suspiciousPatterns = [
                'coin', 'balance', 'firebase', 'update', 
                'gameInterface', 'secureGameState', 'transaction'
            ];
            
            const lowerCode = code.toLowerCase();
            const isSuspicious = suspiciousPatterns.some(pattern => 
                lowerCode.includes(pattern.toLowerCase())
            );
            
            if (isSuspicious) {
                console.warn("Suspicious eval() detected and blocked");
                return null;
            }
        }
        
        return originalEval.apply(window, arguments);
    };
    
    // Override setTimeout and setInterval to prevent timing attacks
    const monitorTimers = (originalFn) => {
        return function(handler, timeout, ...args) {
            if (typeof handler === 'string') {
                // Check for suspicious code in string handlers
                const lowerHandler = handler.toLowerCase();
                if (lowerHandler.includes('coin') || 
                    lowerHandler.includes('balance') || 
                    lowerHandler.includes('firebase')) {
                    console.warn("Suspicious timer code detected and blocked");
                    return null;
                }
            } else if (typeof handler === 'function') {
                // Wrap function handlers to detect suspicious patterns
                const wrappedHandler = function() {
                    try {
                        return handler.apply(this, arguments);
                    } catch (e) {
                        console.error("Timer function error:", e);
                        return null;
                    }
                };
                return originalFn.call(window, wrappedHandler, timeout, ...args);
            }
            
            return originalFn.apply(window, arguments);
        };
    };
    
    // Apply timer monitoring
    window.setTimeout = monitorTimers(originalSetTimeout);
    window.setInterval = monitorTimers(originalSetInterval);
    
    // Protect gameInterface from modification, but don't freeze prototypes
    // as that can cause conflicts with browser functions
    
    // Only lock down window.gameInterface properties instead of freezing the whole object
    if (window.gameInterface) {
        Object.defineProperties(window.gameInterface, {
            getBalance: { writable: false, configurable: false },
            processTransaction: { writable: false, configurable: false },
            updateDisplay: { writable: false, configurable: false },
            refreshBalance: { writable: false, configurable: false }
        });
    }
})();
   </script>
</body>
</html>
