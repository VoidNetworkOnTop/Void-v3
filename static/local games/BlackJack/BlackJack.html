<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>The Void Games - Blackjack</title>

   <!-- Favicon -->
   <link rel="shortcut icon" href="./assets/favicon.png" type="image/png">

   <style>
       body, html {
           margin: 0;
           padding: 0;
           width: 100%;
           height: 100%;
           background: #000;
           color: #fff;
           font-family: 'Arial', sans-serif;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
       }

       .game-container {
           background: linear-gradient(180deg, #000000, #0c0c1f, #000018);
           border-radius: 10px;
           width: 90%;
           max-width: 800px;
           height: 90vh;
           max-height: 800px;
           display: flex;
           flex-direction: column;
           position: relative;
           padding: 1rem;
           box-shadow: 
               0 0 2px #fff,
               0 0 4px #fff,
               0 0 6px #4d7cff,
               0 0 8px #4d7cff,
               inset 0 0 2px rgba(255, 255, 255, 0.2);
           z-index: 3;
           overflow: hidden;
       }

       .game-header {
           text-align: center;
           padding-bottom: 1rem;
           border-bottom: 1px solid rgba(77, 124, 255, 0.2);
           position: relative;
           background: linear-gradient(90deg, transparent, rgba(77, 124, 255, 0.05), transparent);
           z-index: 10;
       }

       .game-title {
           font-size: 2.2rem;
           margin: 0 0 0.5rem 0;
           background: linear-gradient(45deg, #fff, #4d7cff);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           font-weight: bold;
           text-transform: uppercase;
           letter-spacing: 3px;
           text-shadow: 0 0 10px rgba(77, 124, 255, 0.7);
           animation: titleGlow 2s infinite alternate;
       }

       @keyframes titleGlow {
           0% { text-shadow: 0 0 5px rgba(77, 124, 255, 0.7); }
           100% { text-shadow: 0 0 15px rgba(77, 124, 255, 0.9), 0 0 30px rgba(77, 124, 255, 0.5); }
       }

       .game-subtitle {
           font-size: 1rem;
           color: #aac4ff;
           margin: 0;
           text-transform: uppercase;
           letter-spacing: 2px;
           opacity: 0.8;
       }

       .coin-tracker {
           position: absolute;
           top: 0;
           right: 0;
           background: linear-gradient(135deg, rgba(77, 124, 255, 0.1), rgba(20, 30, 60, 0.5));
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           padding: 0.5rem 1rem;
           display: flex;
           align-items: center;
           gap: 0.5rem;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.3);
           animation: glow 2s infinite;
           backdrop-filter: blur(5px);
           z-index: 10;
       }

       .coin-icon {
           width: 20px;
           height: 20px;
           background: linear-gradient(135deg, #FFD700, #FFA500);
           border-radius: 50%;
           box-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
           position: relative;
           overflow: hidden;
       }

       .coin-icon::after {
           content: '';
           position: absolute;
           top: 3px;
           left: 3px;
           width: 6px;
           height: 6px;
           background: rgba(255, 255, 255, 0.8);
           border-radius: 50%;
       }

       .coin-amount {
           font-weight: bold;
           font-size: 1.1rem;
           color: #FFD700;
           text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
       }

       .game-board {
           flex-grow: 1;
           position: relative;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           background: #1a1a2e;
           border-radius: 8px;
           margin: 1rem 0;
           min-height: 60vh;
           border: 1px solid rgba(77, 124, 255, 0.2);
           box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
           padding: 20px;
       }

       #game-canvas {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: transparent;
           z-index: 1;
           display: block;
       }

       .game-overlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           background: rgba(0, 8, 30, 0.85);
           z-index: 100; /* Higher z-index to ensure it's above everything */
           opacity: 0;
           pointer-events: none;
           transition: opacity 0.3s ease;
           backdrop-filter: blur(4px);
       }

       .game-overlay.visible {
           opacity: 1;
           pointer-events: all;
           animation: fadeIn 0.5s ease-out;
       }

       @keyframes fadeIn {
           from { opacity: 0; }
           to { opacity: 1; }
       }

       .overlay-content {
           text-align: center;
           padding: 2.5rem;
           background: linear-gradient(135deg, rgba(13, 21, 40, 0.9), rgba(5, 10, 30, 0.9));
           border-radius: 10px;
           border: 1px solid rgba(77, 124, 255, 0.3);
           box-shadow: 0 0 30px rgba(77, 124, 255, 0.2);
           max-width: 80%;
           animation: floatEffect 4s infinite ease-in-out;
       }

       @keyframes floatEffect {
           0%, 100% { transform: translateY(0); }
           50% { transform: translateY(-10px); }
       }

       .overlay-title {
           font-size: 2.5rem;
           margin-bottom: 1rem;
           text-transform: uppercase;
           letter-spacing: 3px;
           font-weight: bold;
       }

       .overlay-title.win {
           background: linear-gradient(45deg, #4CAF50, #8BC34A);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
       }

       .overlay-title.lose {
           background: linear-gradient(45deg, #f44336, #E91E63);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
       }

       .overlay-title.push {
           background: linear-gradient(45deg, #FFC107, #FF9800);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
       }

       .overlay-message {
           font-size: 1.2rem;
           margin-bottom: 2rem;
           color: #aac4ff;
           line-height: 1.6;
       }

       .game-btn {
           padding: 0.75rem 2rem;
           font-size: 1.2rem;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           color: #fff;
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           cursor: pointer;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.2);
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 2px;
           font-weight: bold;
           position: relative;
           overflow: hidden;
           margin: 0.5rem;
       }

       .game-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
           transition: all 0.6s ease;
       }

       .game-btn:hover::before {
           left: 100%;
       }

       .game-btn:hover {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: translateY(-2px);
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.3);
       }

       .game-btn:active {
           transform: translateY(1px);
       }

       .game-btn:disabled {
           opacity: 0.5;
           cursor: not-allowed;
           background: linear-gradient(135deg, #444, #333);
       }

       .game-btn.insufficient {
           background: linear-gradient(135deg, #70283f, #350f1a);
           color: #ffcccc;
           border-color: rgba(244, 67, 54, 0.4);
       }

       .controls {
           display: flex;
           justify-content: center;
           align-items: center;
           padding: 1rem 0;
           gap: 1rem;
           z-index: 10;
       }

       .restart-btn {
           padding: 0.75rem 1.5rem;
           font-size: 1rem;
           background: linear-gradient(135deg, #192238, #0d1526);
           color: #aac4ff;
           border: 1px solid rgba(77, 124, 255, 0.2);
           border-radius: 30px;
           cursor: pointer;
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 1px;
           position: relative;
           overflow: hidden;
       }

       .restart-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
           transition: all 0.6s ease;
       }

       .restart-btn:hover::before {
           left: 100%;
       }

       .restart-btn:hover {
           color: #fff;
           border-color: rgba(77, 124, 255, 0.4);
           background: linear-gradient(135deg, #243252, #131e36);
       }

       /* Special Effects */
       @keyframes glow {
           0% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
           50% { filter: drop-shadow(0 0 10px rgba(77, 124, 255, 0.9)); }
           100% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
       }

       /* Blackjack specific styles */
       #blackjack-container {
           display: flex;
           flex-direction: column;
           justify-content: space-between;
           width: 100%;
           height: 100%;
           z-index: 10;
       }

       .dealer-area, .player-area {
           display: flex;
           flex-direction: column;
           align-items: center;
           width: 100%;
           height: 40%;
           position: relative;
       }

       .area-label {
           font-size: 1.2rem;
           color: #aac4ff;
           margin-bottom: 10px;
           text-transform: uppercase;
           letter-spacing: 2px;
       }

       .hand-value {
           font-size: 1.5rem;
           font-weight: bold;
           color: #fff;
           margin: 5px 0;
           text-shadow: 0 0 10px rgba(77, 124, 255, 0.7);
       }

       .cards-container {
           display: flex;
           justify-content: center;
           align-items: center;
           gap: 10px;
           min-height: 150px;
           width: 100%;
           position: relative;
       }

       .card {
           width: 100px;
           height: 140px;
           background: #fff;
           border-radius: 8px;
           box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
           display: flex;
           flex-direction: column;
           justify-content: space-between;
           padding: 5px;
           font-weight: bold;
           position: relative;
           transition: transform 0.3s ease;
           transform-style: preserve-3d;
           perspective: 1000px;
       }

       .card.hidden {
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           border: 2px solid rgba(77, 124, 255, 0.4);
           display: flex;
           justify-content: center;
           align-items: center;
       }

       .card.hidden::after {
           content: '?';
           font-size: 3rem;
           color: #4d7cff;
           text-shadow: 0 0 5px rgba(77, 124, 255, 0.5);
       }

       .card.red {
           color: #e91e63;
       }

       .card.black {
           color: #000;
       }

       .card-top, .card-bottom {
           display: flex;
           flex-direction: column;
           align-items: flex-start;
       }

       .card-bottom {
           transform: rotate(180deg);
       }

       .card-value {
           font-size: 1.5rem;
           line-height: 1;
       }

       .card-suit {
           font-size: 1.2rem;
       }

       .card-center {
           display: flex;
           justify-content: center;
           align-items: center;
           flex-grow: 1;
           font-size: 3rem;
       }

       .bet-controls {
           display: flex;
           flex-direction: column;
           align-items: center;
           padding: 15px;
           gap: 10px;
           width: 100%;
       }

       .bet-amount {
           font-size: 1.5rem;
           font-weight: bold;
           color: #FFD700;
           text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
       }

       .bet-btns {
           display: flex;
           gap: 10px;
           flex-wrap: wrap;
           justify-content: center;
       }

       .bet-btn {
           padding: 8px 15px;
           background: linear-gradient(135deg, #2e7d32, #1b5e20);
           color: #fff;
           border: 1px solid rgba(76, 175, 80, 0.4);
           border-radius: 20px;
           cursor: pointer;
           transition: all 0.3s ease;
           font-weight: bold;
       }

       .bet-btn:hover {
           background: linear-gradient(135deg, #388e3c, #2e7d32);
           transform: translateY(-2px);
       }

       /* New Deal button style */
       .deal-btn {
           padding: 12px 40px;
           font-size: 1.4rem;
           background: linear-gradient(135deg, #2e7d32, #1b5e20);
           color: #fff;
           border: 1px solid rgba(76, 175, 80, 0.6);
           border-radius: 25px;
           cursor: pointer;
           transition: all 0.3s ease;
           font-weight: bold;
           letter-spacing: 2px;
           text-transform: uppercase;
           margin-bottom: 20px;
           box-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
           animation: dealButtonGlow 1.5s infinite alternate;
       }

       .deal-btn:hover {
           background: linear-gradient(135deg, #388e3c, #2e7d32);
           transform: translateY(-3px);
           box-shadow: 0 0 20px rgba(76, 175, 80, 0.9);
       }

       .deal-btn:disabled {
           opacity: 0.5;
           cursor: not-allowed;
           background: linear-gradient(135deg, #444, #333);
           animation: none;
           box-shadow: none;
       }

       @keyframes dealButtonGlow {
           0% {
               box-shadow: 0 0 5px rgba(76, 175, 80, 0.7),
                        0 0 10px rgba(76, 175, 80, 0.5);
           }
           100% {
               box-shadow: 0 0 15px rgba(76, 175, 80, 0.9),
                        0 0 25px rgba(76, 175, 80, 0.7),
                        0 0 35px rgba(76, 175, 80, 0.5);
           }
       }

       .action-controls {
           display: flex;
           justify-content: center;
           gap: 10px;
           flex-wrap: wrap;
           margin-top: 10px;
       }

       .action-btn {
           padding: 10px 20px;
           font-size: 1rem;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           color: #fff;
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 25px;
           cursor: pointer;
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 1px;
           font-weight: bold;
       }

       .action-btn:hover {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: translateY(-2px);
       }

       .action-btn:disabled {
           opacity: 0.5;
           cursor: not-allowed;
           background: linear-gradient(135deg, #444, #333);
       }

       .game-status {
           text-align: center;
           margin: 10px 0;
           padding: 5px 15px;
           border-radius: 20px;
           background: rgba(10, 20, 40, 0.6);
           border: 1px solid rgba(77, 124, 255, 0.2);
           display: inline-block;
       }

       .win-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #4caf50;
           text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
       }

       .lose-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #f44336;
           text-shadow: 0 0 5px rgba(244, 67, 54, 0.5);
       }

       /* Animations */
       @keyframes dealCard {
           0% { transform: translateY(-200px) rotate(10deg); opacity: 0; }
           100% { transform: translateY(0) rotate(0); opacity: 1; }
       }

       @keyframes flipCard {
           0% { transform: rotateY(90deg); }
           100% { transform: rotateY(0); }
       }

       @keyframes cardGlow {
           0% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.5); }
           100% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.9); }
       }

       @keyframes cardShake {
           0%, 100% { transform: translateX(0); }
           25% { transform: translateX(-5px); }
           75% { transform: translateX(5px); }
       }

       /* Media queries for better responsiveness */
       @media (max-height: 700px) {
           .cards-container {
               min-height: 120px;
           }

           .card {
               width: 80px;
               height: 112px;
           }

           .card-value {
               font-size: 1.2rem;
           }

           .card-suit {
               font-size: 1rem;
           }

           .card-center {
               font-size: 2.5rem;
           }

           .bet-amount, .hand-value {
               font-size: 1.2rem;
           }

           .action-btn, .bet-btn {
               padding: 8px 15px;
               font-size: 0.9rem;
           }
           
           .deal-btn {
               padding: 10px 30px;
               font-size: 1.2rem;
           }
       }

       @media (max-width: 600px) {
           .card {
               width: 60px;
               height: 84px;
           }

           .card-value {
               font-size: 1rem;
           }

           .card-suit {
               font-size: 0.8rem;
           }

           .card-center {
               font-size: 2rem;
           }

           .overlay-title {
               font-size: 1.8rem;
           }

           .overlay-message {
               font-size: 0.9rem;
           }

           .game-title {
               font-size: 1.8rem;
           }

           .action-btn, .bet-btn {
               padding: 6px 12px;
               font-size: 0.8rem;
           }
           
           .deal-btn {
               padding: 8px 25px;
               font-size: 1.1rem;
           }
       }
       
       /* New loading indicator style */
       .loading-spinner {
           display: inline-block;
           width: 20px;
           height: 20px;
           border: 3px solid rgba(255,255,255,.3);
           border-radius: 50%;
           border-top-color: #fff;
           animation: spin 1s ease-in-out infinite;
           margin-left: 10px;
       }

       @keyframes spin {
           to { transform: rotate(360deg); }
       }
       
       /* Debug display for development */
       .debug-display {
           position: fixed;
           bottom: 10px;
           right: 10px;
           background: rgba(0,0,0,0.8);
           color: #4caf50;
           font-family: monospace;
           padding: 5px;
           font-size: 10px;
           border-radius: 4px;
           z-index: 1000;
           display: none;
       }
   </style>
</head>

<body>
   <div class="game-container">
       <div class="game-header">
           <h1 class="game-title">Blackjack</h1>
           <p class="game-subtitle">Beat the dealer to 21</p>
           <div class="coin-tracker">
               <div class="coin-icon"></div>
               <span class="coin-amount" id="coinDisplay">0</span>
           </div>
       </div>

       <div class="game-board">
           <canvas id="game-canvas"></canvas>
           <div id="blackjack-container" style="display: none;">
               <div class="dealer-area">
                   <div class="area-label">Dealer</div>
                   <div class="hand-value" id="dealer-value">0</div>
                   <div class="cards-container" id="dealer-cards"></div>
               </div>
               
               <div class="bet-controls" id="bet-controls">
                   <div class="game-status" id="game-status">Place your bet to start</div>
                   <div class="bet-amount">Bet: <span id="bet-amount">0</span> coins</div>
                   
                   <!-- Deal button now above the betting buttons -->
                   <button class="deal-btn" id="deal-btn">Deal</button>
                   
                   <div class="bet-btns">
                       <button class="bet-btn" data-amount="5">+5</button>
                       <button class="bet-btn" data-amount="10">+10</button>
                       <button class="bet-btn" data-amount="50">+50</button>
                       <button class="bet-btn" data-amount="100">+100</button>
                       <button class="bet-btn" data-amount="500">+500</button>
                       <button class="bet-btn" data-amount="1000">+1000</button>
                       <button class="bet-btn" data-amount="max">Max</button>
                       <button class="bet-btn" data-amount="clear">Clear</button>
                   </div>
               </div>
               
               <div class="action-controls" id="action-controls" style="display: none;">
                   <button class="action-btn" id="hit-btn">Hit</button>
                   <button class="action-btn" id="stand-btn">Stand</button>
                   <button class="action-btn" id="double-btn">Double</button>
               </div>
               
               <div class="player-area">
                   <div class="area-label">Player</div>
                   <div class="hand-value" id="player-value">0</div>
                   <div class="cards-container" id="player-cards"></div>
               </div>
           </div>

           <!-- Start Screen Overlay -->
           <div class="game-overlay visible" id="start-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title">Blackjack</h2>
                   <p class="overlay-message">
                       Try to beat the dealer by getting a hand value closer to 21 without going over.<br>
                       • Blackjack pays 3:2<br>
                       • Dealer stands on all 17s<br>
                       • Double down on any two cards<br>
                       • No splitting or insurance
                   </p>
                   <button id="start-btn" class="game-btn">Start Game</button>
               </div>
           </div>

           <!-- Login Required Overlay -->
           <div class="game-overlay" id="login-required-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title" style="background: linear-gradient(45deg, #FF9800, #F44336); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Login Required</h2>
                   <p class="overlay-message">
                       You need to be logged in to play Blackjack.<br>
                       Please sign in to your Void Games account.
                   </p>
                   <button id="login-btn" class="game-btn">Go to Login</button>
                   <button id="play-offline-btn" class="game-btn" style="background: linear-gradient(135deg, #455a64, #263238);">Play Offline</button>
               </div>
           </div>

           <!-- Game Result Overlay -->
           <div class="game-overlay" id="result-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title" id="result-title">You Win!</h2>
                   <p class="overlay-message" id="result-message">
                       You beat the dealer!<br>
                       You won: <span class="win-amount">0</span> coins!
                   </p>
                   <button id="play-again-btn" class="game-btn">Play Again</button>
               </div>
           </div>
           
           <!-- New Connection Issue Overlay -->
           <div class="game-overlay" id="connection-issue-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title" style="background: linear-gradient(45deg, #FFC107, #FF9800); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Connection Issue</h2>
                   <p class="overlay-message">
                       We're having trouble connecting to the server.<br>
                       Would you like to continue in offline mode?
                   </p>
                   <button id="offline-continue-btn" class="game-btn">Continue Offline</button>
                   <button id="retry-connection-btn" class="game-btn" style="background: linear-gradient(135deg, #455a64, #263238);">Retry Connection</button>
               </div>
           </div>
       </div>

       <div class="controls">
           <button id="back-btn" class="restart-btn">Back to Beta Games</button>
       </div>
   </div>
   
   <!-- Debug display (hidden by default) -->
   <div id="debug-display" class="debug-display"></div>

   <!-- Firebase SDK -->
   <script type="module">
       // Firebase Imports
       import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
       import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
       import { getFirestore, doc, getDoc, updateDoc, setDoc, collection, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore.js";

       // Firebase Configuration - UPDATED
       const firebaseConfig = {
           apiKey: "AIzaSyCkAp_GCGCtw4zv7GgHJOE9GPgIaPEuOvQ",
           authDomain: "void-games-c8d9e.firebaseapp.com",
           projectId: "void-games-c8d9e",
           storageBucket: "void-games-c8d9e.firebasestorage.app",
           messagingSenderId: "1063089929776",
           appId: "1:1063089929776:web:8e226a23a4f3ab9c5777f5"
       };

       // Initialize Firebase
       let app, auth, db;
       
       // Flag for offline mode
       window.guestMode = false;
       
       try {
           app = initializeApp(firebaseConfig);
           auth = getAuth(app);
           db = getFirestore(app);
           console.log("Firebase initialized successfully");
       } catch (error) {
           console.error("Firebase initialization error:", error);
           // Set guest mode if Firebase fails to initialize
           window.guestMode = true;
           window.voidGameUser = null;
       }

       // Secure game session with a unique token
       const sessionToken = generateSecureToken();
       
       // Authentication and Coin Management with security improvements
       let currentUser = null;
       let firebaseCoinBalance = 0;
       let lastServerBalance = 0; // Track last known server balance
       let lastTransactionTime = Date.now(); // Track transaction timing for rate limiting
       let gameSessionData = { // Store game session data with validation
           initialBalance: 0,
           transactions: [],
           sessionToken: sessionToken
       };
       
       // Expose currentUser to the global scope so game script can access it
       window.voidGameUser = null;

       // Security function - Generate secure token for this session
       function generateSecureToken() {
           const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
           let token = '';
           const randomValues = new Uint32Array(32);
           crypto.getRandomValues(randomValues);
           randomValues.forEach(val => {
               token += chars[val % chars.length];
           });
           return token + Date.now().toString(36);
       }

       // Security function - Validate transaction request
       function validateTransaction(amount, type, currentBalance) {
           try {
               // Skip validation in guest mode
               if (window.guestMode) {
                   return true;
               }
               
               // Rate limiting check - prevent rapid transactions
               const now = Date.now();
               if (now - lastTransactionTime < 300) { // 300ms minimum between transactions
                   console.warn("Transaction rate limit exceeded, will retry after delay");
                   return false;
               }
               
               // Validate the amount makes sense
               if (amount <= 0) {
                   console.warn("Invalid transaction amount: " + amount);
                   return false;
               }
               
               // Validate the amount makes sense for the transaction type
               if (type === 'bet' && amount > currentBalance) {
                   console.warn("Insufficient balance for bet: " + amount);
                   return false;
               }
               
               // Basic integrity check - transaction seems valid
               lastTransactionTime = now;
               return true;
           } catch (error) {
               console.error("Transaction validation error:", error);
               return false;
           }
       }

       // Enable offline mode
       window.enableGuestMode = function() {
           window.guestMode = true;
           window.voidGameUser = { uid: 'guest-' + Date.now() };
           console.log("Guest mode enabled");
           
           // Update coin balance for guest mode
           _secureGameState.updateBalance(1000);
           _secureGameState.updateDisplay();
           
           // Hide login screen if visible
           let loginScreen = document.getElementById('login-required-screen');
           if (loginScreen) {
               loginScreen.classList.remove('visible');
           }
           
           // Show start screen
           let startScreen = document.getElementById('start-screen');
           if (startScreen) {
               startScreen.classList.add('visible');
           }
           
           return true;
       };
       
       // Add click event for offline play button
       document.addEventListener('DOMContentLoaded', function() {
           const offlineBtn = document.getElementById('play-offline-btn');
           if (offlineBtn) {
               offlineBtn.addEventListener('click', function() {
                   window.enableGuestMode();
               });
           }
           
           const offlineContinueBtn = document.getElementById('offline-continue-btn');
           if (offlineContinueBtn) {
               offlineContinueBtn.addEventListener('click', function() {
                   window.enableGuestMode();
                   
                   // Hide connection issue screen
                   const connectionIssueScreen = document.getElementById('connection-issue-screen');
                   if (connectionIssueScreen) {
                       connectionIssueScreen.classList.remove('visible');
                   }
               });
           }
           
           const retryConnectionBtn = document.getElementById('retry-connection-btn');
           if (retryConnectionBtn) {
               retryConnectionBtn.addEventListener('click', function() {
                   // Hide connection issue screen
                   const connectionIssueScreen = document.getElementById('connection-issue-screen');
                   if (connectionIssueScreen) {
                       connectionIssueScreen.classList.remove('visible');
                   }
                   
                   // Try to reconnect
                   window.location.reload();
               });
           }
       });

       // Authentication State Listener
       if (auth) {
           onAuthStateChanged(auth, async (user) => {
               if (user) {
                   // User is signed in
                   currentUser = user;
                   window.voidGameUser = user; // Share with game script
                   console.log("User signed in:", user.uid);
                   
                   try {
                       await loadFirebaseCoinBalance();
                       
                       // Setup session data for this player
                       gameSessionData.initialBalance = firebaseCoinBalance;
                       gameSessionData.userId = user.uid;
                       gameSessionData.sessionStartTime = Date.now();
                       
                       // Store initial game session in Firebase for validation
                       try {
                           const sessionRef = doc(collection(db, 'gameSessions'));
                           await setDoc(sessionRef, {
                               userId: user.uid,
                               gameId: 'blackjack_game',
                               initialBalance: firebaseCoinBalance,
                               sessionToken: sessionToken,
                               startTime: serverTimestamp(),
                               device: {
                                   userAgent: navigator.userAgent,
                                   platform: navigator.platform,
                                   screen: `${window.screen.width}x${window.screen.height}`
                               }
                           });
                           gameSessionData.sessionId = sessionRef.id;
                       } catch (error) {
                           console.error("Error creating game session:", error);
                       }
                   } catch (error) {
                       console.error("Error during user initialization:", error);
                       // Show connection issue screen
                       const connectionIssueScreen = document.getElementById('connection-issue-screen');
                       if (connectionIssueScreen) {
                           connectionIssueScreen.classList.add('visible');
                       }
                   }
               } else {
                   // No user is signed in - use default balance
                   currentUser = null;
                   window.voidGameUser = null; // Share with game script
                   console.log("No user signed in, using default balance");
                   
                   // Use the secure accessor function instead of direct window.coinBalance
                   _secureGameState.updateBalance(1000);
                   _secureGameState.updateDisplay();
               }
           });
       } else {
           // Firebase auth not available - enable guest mode
           console.log("Firebase auth not available, enabling guest mode");
           window.guestMode = true;
           _secureGameState.updateBalance(1000);
           _secureGameState.updateDisplay();
       }

       // Load Coin Balance from Firebase with additional validation
       async function loadFirebaseCoinBalance() {
           if (!currentUser || window.guestMode) {
               console.log("No user available or guest mode enabled");
               return 1000; // Default balance for guests
           }

           try {
               console.log("Loading balance for user:", currentUser.uid);

               // IMPROVED: Add timeout protection
               const timeoutPromise = new Promise((_, reject) => {
                   setTimeout(() => reject(new Error("Balance loading timed out")), 5000);
               });

               try {
                   // Use currentUser.uid with timeout protection
                   const userRef = doc(db, 'users', currentUser.uid);
                   const userDocPromise = getDoc(userRef);
                   
                   const userDoc = await Promise.race([userDocPromise, timeoutPromise]);

                   if (userDoc.exists()) {
                       // Get coin balance from Firestore
                       const userData = userDoc.data();

                       // IMPORTANT: Use accountBalance field for consistency with main page
                       firebaseCoinBalance = userData.accountBalance || 0;
                       lastServerBalance = firebaseCoinBalance; // Store server balance
                       
                       console.log("Loaded balance from Firebase:", firebaseCoinBalance);

                       // Update local game state through secure function
                       _secureGameState.updateBalance(firebaseCoinBalance);
                       _secureGameState.updateDisplay();

                       console.log("Updated local balance:", _secureGameState.getBalance());
                       return firebaseCoinBalance;
                   } else {
                       console.log("User document doesn't exist, creating new one");
                       // Create initial balance if no document exists
                       const initialBalance = 1000;
                       
                       await setDoc(userRef, { 
                         accountBalance: initialBalance,
                         username: currentUser.displayName || "Player",
                         email: currentUser.email,
                         createdAt: serverTimestamp(),
                         totalGamesPlayed: 0,
                         totalMoneySpent: 0,
                         totalMoneyEarned: 0
                       });

                       firebaseCoinBalance = initialBalance;
                       lastServerBalance = initialBalance;
                       
                       _secureGameState.updateBalance(initialBalance);
                       _secureGameState.updateDisplay();
                       return initialBalance;
                   }
               } catch (timeoutError) {
                   console.error("Balance loading timed out:", timeoutError);
                   throw new Error("Connection to server timed out");
               }
           } catch (error) {
               console.error("Error loading coin balance:", error);
               
               // Show connection issue screen
               const connectionIssueScreen = document.getElementById('connection-issue-screen');
               if (connectionIssueScreen) {
                   connectionIssueScreen.classList.add('visible');
               }
               
               // Fallback to default value
               const defaultBalance = 1000;
               _secureGameState.updateBalance(defaultBalance);
               _secureGameState.updateDisplay();
               return defaultBalance;
           }
       }

       // IMPROVED: Record Game Transaction with better error handling
       async function recordGameTransaction(gameId, amount, isWin) {
           if (!currentUser || window.guestMode) return true;

           try {
               // Get current server balance
               const userRef = doc(db, 'users', currentUser.uid);
               
               // IMPROVED: Use faster cache-first approach
               const userDoc = await getDoc(userRef);
               
               if (!userDoc.exists()) {
                   console.error("User document not found");
                   return true;
               }
               
               const userData = userDoc.data();
               const currentServerBalance = userData.accountBalance || 0;
               
               // Pre-calculate new balance
               let newBalance = currentServerBalance;
               if (isWin) {
                   newBalance += amount;
               } else {
                   if (currentServerBalance < amount) {
                       console.error("Insufficient funds");
                       return true;
                   }
                   newBalance -= amount;
               }
               
               // IMPROVED: Create combined data for more efficient write
               const transactionData = {
                   userId: currentUser.uid,
                   gameId: gameId,
                   transactionType: isWin ? 'game_win' : 'game_play',
                   amount: amount,
                   timestamp: serverTimestamp(),
                   previousBalance: currentServerBalance,
                   newBalance: newBalance,
                   sessionToken: sessionToken,
                   sessionId: gameSessionData.sessionId || null,
                   status: 'complete' // Mark as complete immediately
               };
               
               // Create transaction record directly with complete status
               const transactionRef = doc(collection(db, 'transactions'));
               await setDoc(transactionRef, transactionData);
               
               // Update user document
               await updateDoc(userRef, {
                   accountBalance: newBalance,
                   lastUpdated: serverTimestamp()
               });
               
               // Update local tracking
               lastServerBalance = newBalance;
               _secureGameState.updateBalance(newBalance);
               _secureGameState.updateDisplay();
               
               return {
                   transactionId: transactionRef.id,
                   newBalance: newBalance
               };
           } catch (error) {
               console.error("Transaction Error:", error);
               // Return true to continue the game
               return true;
           }
       }

       // Create a secure encapsulated game state manager (using IIFE pattern)
       // Create this early to ensure it's available throughout the app lifecycle
       const _secureGameState = (function() {
           // Private variables that can't be accessed directly from console
           let _balance = 1000; // Default starting balance to avoid showing 0
           let _coinDisplay = null;
           let _transactionLock = false;
           let _transactionQueue = [];
           let _processingQueue = false;
           
           // IMPROVED: Process transaction queue with better timeout handling
           async function _processTransactionQueue() {
               if (_processingQueue || _transactionQueue.length === 0) return;
               
               _processingQueue = true;
               
               while (_transactionQueue.length > 0) {
                   const transaction = _transactionQueue.shift();
                   
                   try {
                       // Process the transaction
                       const { amount, isWin, resolve, reject } = transaction;
                       
                       // Apply transaction to local state immediately
                       let newBalance = _balance;
                       if (isWin) {
                           newBalance += amount;
                       } else {
                           newBalance -= amount;
                       }
                       
                       // Update local balance immediately for UI responsiveness
                       _balance = newBalance;
                       _updateDisplay();
                       
                       // Skip Firebase in guest mode
                       if (window.guestMode) {
                           resolve(true);
                           continue;
                       }
                       
                       // IMPROVED: Add timeout protection
                       let timeoutId;
                       const timeoutPromise = new Promise((_, rej) => {
                           timeoutId = setTimeout(() => {
                               rej(new Error("Transaction timed out"));
                           }, 5000); // 5 second timeout
                       });
                       
                       try {
                           // Try to process the server-side transaction with timeout
                           const result = await Promise.race([
                               recordGameTransaction('blackjack_game', amount, isWin),
                               timeoutPromise
                           ]);
                           
                           clearTimeout(timeoutId);
                           
                           if (result) {
                               resolve(true);
                           } else {
                               // We'll still resolve the promise even if Firebase failed
                               // This prevents the game from hanging
                               console.warn("Server transaction failed, using local state");
                               resolve(true);
                           }
                       } catch (err) {
                           clearTimeout(timeoutId);
                           console.error("Transaction error with timeout:", err);
                           
                           // Game should continue even if Firebase fails
                           console.warn("Transaction timed out, using local state");
                           resolve(true);
                       }
                   } catch (error) {
                       console.error("Error processing transaction:", error);
                       // Resolve the promise to prevent blocking the game
                       transaction.resolve(true);
                   }
               }
               
               _processingQueue = false;
           }
           
           // Initialize the display element reference
           function _initDisplay() {
               _coinDisplay = document.getElementById('coinDisplay');
               if (_coinDisplay) {
                   _coinDisplay.textContent = _balance.toLocaleString();
               }
           }
           
           // Update the display with current balance
           function _updateDisplay() {
               if (!_coinDisplay) _initDisplay();
               if (_coinDisplay) {
                   _coinDisplay.textContent = _balance.toLocaleString();
               }
           }
           
           // Call init on document ready
           document.addEventListener('DOMContentLoaded', function() {
               _initDisplay();
           });
           
           // Return only the methods we want to expose
           return {
               getBalance: function() {
                   return _balance;
               },
               updateBalance: function(newBalance) {
                   if (typeof newBalance !== 'number' || isNaN(newBalance)) {
                       console.error("Invalid balance update attempted");
                       return false;
                   }
                   _balance = newBalance;
                   _updateDisplay(); // Update display immediately
                   return true;
               },
               updateDisplay: function() {
                   _updateDisplay();
               },
               applyTransaction: function(amount, isWin) {
                   // Return a promise that resolves when the transaction is complete
                   return new Promise((resolve, reject) => {
                       // Add to transaction queue
                       _transactionQueue.push({ amount, isWin, resolve, reject });
                       
                       // Start processing queue if not already processing
                       if (!_processingQueue) {
                           _processTransactionQueue();
                       }
                   });
               }
           };
       })();

       // Create and expose methods only through secure wrapper functions
       // Define this early to ensure availability
       window.gameInterface = {
           getBalance: function() {
               return _secureGameState.getBalance();
           },
           processTransaction: async function(amount, isWin) {
               return await _secureGameState.applyTransaction(amount, isWin);
           },
           updateDisplay: function() {
               _secureGameState.updateDisplay();
           },
           refreshBalance: async function() {
               return await loadFirebaseCoinBalance();
           }
       };

       // Anti-debugging measure - detect console open
       (function() {
           let devtoolsOpen = false;
           
           // Method 1: Check for firebug
           if (window.Firebug && window.Firebug.chrome && window.Firebug.chrome.isInitialized) {
               devtoolsOpen = true;
           }
           
           // Method 2: Console timing method
           const threshold = 160;
           const start = Date.now();
           
           function checkTime() {
               // Check time spent executing this function
               // If debugger is open, this takes longer to execute
               const end = Date.now();
               if (end - start > threshold) {
                   console.warn("Developer tools detected");
                   // Additional security measures could be taken here
               }
           }
           
           checkTime();
           
           // Method 3: Monitor console logging (limited protection)
           const originalLog = console.log;
           console.log = function() {
               originalLog.apply(console, arguments);
               
               // Check if someone is trying to inspect the game state
               const logString = Array.from(arguments).join(" ").toLowerCase();
               if (logString.includes("coin") || logString.includes("balance") || 
                   logString.includes("firebase") || logString.includes("cheat")) {
                   console.warn("Suspicious console activity detected");
               }
           };
       })();
       
       // Add protection against tampering
       // Only lock down window.gameInterface properties instead of freezing the whole object
       if (window.gameInterface) {
           Object.defineProperties(window.gameInterface, {
               getBalance: { writable: false, configurable: false },
               processTransaction: { writable: false, configurable: false },
               updateDisplay: { writable: false, configurable: false },
               refreshBalance: { writable: false, configurable: false }
           });
       }
       
       // Check connection state immediately
       if (!navigator.onLine) {
           console.log("Starting in offline mode");
           window.guestMode = true;
       }
   </script>

   <script>
// SECURE BLACKJACK GAME IMPLEMENTATION
// All game logic is encapsulated in an IIFE to prevent direct access from console

// SECURE BLACKJACK GAME IMPLEMENTATION
// All game logic is encapsulated in an IIFE to prevent direct access from console

(function() {
    // Game Configuration
    const GAME_CONFIG = {
        gameId: 'blackjack_game', // ID for Firebase transactions
        minBet: 5,            // Minimum bet amount (changed from 10 to 5)
        maxBet: 1000000,      // Very high maximum bet (will be limited by player balance)
        blackjackPayout: 1.5, // Blackjack pays 3:2
        hiddenEntryFee: 0,    // Small hidden fee per hand (not shown to user) - set to 0 to fix games
        dealerStandValue: 17, // Dealer stands on all 17s
        enableDebug: true     // Show debug information
    };

    // Game state
    let canvas, ctx;
    let canvasWidth, canvasHeight;
    let animationFrame;
    let gameActive = false;
    let currentBet = 0;
    let dealerCards = [];
    let playerCards = [];
    let isDealerTurn = false;
    let gameResult = null; // 'win', 'lose', 'push', 'blackjack'
    let canDouble = false;

    // Security - Hash of the game state for validation
    let gameStateHash = '';
    let lastGameAction = '';
    let actionCounter = 0;
    let initializationMode = true; // Allow initialization without validation errors

    // Deck state
    let deck = [];
    const suits = ['♥', '♦', '♠', '♣'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

    // DOM elements
    let startScreen;
    let resultScreen;
    let startBtn;
    let playAgainBtn;
    let backBtn;
    let blackjackContainer;
    let dealerCardsContainer;
    let playerCardsContainer;
    let dealerValueDisplay;
    let playerValueDisplay;
    let betAmount;
    let betControls;
    let actionControls;
    let dealBtn;
    let hitBtn;
    let standBtn;
    let doubleBtn;
    let gameStatus;
    let resultTitle;
    let resultMessage;
    let debugDisplay;

    // Debug function for development
    function debugLog(message) {
        if (!GAME_CONFIG.enableDebug) return;
        
        console.log('[DEBUG] ' + message);
        
        if (!debugDisplay) {
            debugDisplay = document.getElementById('debug-display');
            if (debugDisplay) {
                debugDisplay.style.display = 'block';
            }
        }
        
        if (debugDisplay) {
            const now = new Date();
            const timestamp = `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`;
            debugDisplay.innerHTML += `[${timestamp}] ${message}<br>`;
            debugDisplay.scrollTop = debugDisplay.scrollHeight;
        }
    }

    // Security function - Generate a hash for game state validation
    function hashGameState() {
        try {
            // Create a string representing critical game state
            // Use a simpler representation that's less prone to false positives
            const stateString = JSON.stringify({
                playerCardCount: playerCards.length,
                dealerCardCount: dealerCards.length,
                betPhase: actionControls ? actionControls.style.display === 'none' : true,
                gameActive: gameActive
            });
            
            // Simple hash function
            let hash = 0;
            for (let i = 0; i < stateString.length; i++) {
                const char = stateString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            
            return hash.toString(16);
        } catch (error) {
            console.error("Error generating hash:", error);
            return "error";
        }
    }
    
    // Security function - Validate game state integrity
    function validateGameState() {
        // Skip validation during initialization to prevent false positives
        if (initializationMode) {
            return true;
        }
        
        // Skip validation during bet phase which has frequent small changes
        if (betControls && betControls.style.display === 'block') {
            // During betting, we'll just update the hash without validation
            gameStateHash = hashGameState();
            return true;
        }
        
        const currentHash = hashGameState();
        
        // If we have a previous hash to compare against and it's not equal
        if (gameStateHash && gameStateHash !== currentHash && gameStateHash !== "error" && currentHash !== "error") {
            console.error("Game state tampering detected");
            // Could implement additional security measures here
            return false;
        }
        
        // Update the hash
        gameStateHash = currentHash;
        return true;
    }

    // Helper function to clear all timeouts
    function clearAllTimeouts() {
        // Create a very large number (bigger than any reasonable timeout id)
        const highestTimeoutId = setTimeout(() => {}, 0);
        
        // Clear all timeout IDs from 0 to the highest one
        for (let i = 0; i < highestTimeoutId; i++) {
            clearTimeout(i);
        }
    }

    // Initialize DOM elements
    function initDomElements() {
        debugLog("Initializing DOM elements");
        
        startScreen = document.getElementById('start-screen');
        resultScreen = document.getElementById('result-screen');
        startBtn = document.getElementById('start-btn');
        playAgainBtn = document.getElementById('play-again-btn');
        backBtn = document.getElementById('back-btn');
        blackjackContainer = document.getElementById('blackjack-container');
        dealerCardsContainer = document.getElementById('dealer-cards');
        playerCardsContainer = document.getElementById('player-cards');
        dealerValueDisplay = document.getElementById('dealer-value');
        playerValueDisplay = document.getElementById('player-value');
        betAmount = document.getElementById('bet-amount');
        betControls = document.getElementById('bet-controls');
        actionControls = document.getElementById('action-controls');
        dealBtn = document.getElementById('deal-btn');
        hitBtn = document.getElementById('hit-btn');
        standBtn = document.getElementById('stand-btn');
        doubleBtn = document.getElementById('double-btn');
        gameStatus = document.getElementById('game-status');
        resultTitle = document.getElementById('result-title');
        resultMessage = document.getElementById('result-message');
        debugDisplay = document.getElementById('debug-display');
        
        if (!startBtn) debugLog("WARNING: Start button not found");
        if (!dealBtn) debugLog("WARNING: Deal button not found");
        if (!betControls) debugLog("WARNING: Bet controls not found");
        
        // Ensure balance display is up to date - with error handling
        try {
            if (window.gameInterface && typeof window.gameInterface.updateDisplay === 'function') {
                window.gameInterface.updateDisplay();
            } else {
                console.log("Game interface not ready yet, display will update when ready");
                // Fallback direct update
                const coinDisplay = document.getElementById('coinDisplay');
                if (coinDisplay) {
                    coinDisplay.textContent = "1000";
                }
            }
        } catch (err) {
            console.error("Error updating coin display:", err);
        }
    }

    // IMPROVED: Simplified updateCoins function for better reliability
    async function updateCoins(amount, isWin = true) {
        try {
            // Log the attempt for debugging
            debugLog(`Updating coins: current=${window.gameInterface.getBalance()}, change=${amount}, isWin=${isWin}`);
            
            // Check for unrealistic values that might indicate a hack attempt
            if (Math.abs(amount) > 100000) {
                console.error("Unusually large transaction detected");
                return false;
            }
            
            // Validate transaction amount
            if (amount <= 0) {
                console.error("Invalid transaction amount:", amount);
                return false;
            }
            
            // Check current balance for bets
            if (!isWin && window.gameInterface.getBalance() < amount) {
                console.error("Insufficient funds for bet:", amount);
                return false;
            }
            
            // IMPROVED: Add a timeout to prevent hanging on Firebase operations
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error("Transaction timed out")), 8000);
            });
            
            // Try to process the transaction with a timeout
            try {
                const result = await Promise.race([
                    window.gameInterface.processTransaction(amount, isWin),
                    timeoutPromise
                ]);
                
                if (!result) {
                    console.error("Transaction failed but continuing game");
                    // We'll continue with local state for better user experience
                    return true;
                }
                
                return true;
            } catch (err) {
                console.error("Transaction error:", err);
                // Continue with local state
                return true;
            }
        } catch (error) {
            console.error("Error in updateCoins:", error);
            return false;
        }
    }
    
    // FIXED BETTING: Directly place a bet without using secureAction wrapper
    function placeBet(amount) {
        try {
            debugLog(`Placing bet: ${amount}`);
            
            // Always set initialization mode during betting to avoid validation errors
            initializationMode = true;
            
            // Track the action
            lastGameAction = 'placeBet';
            actionCounter++;
            
            // Clear bet if requested
            if (amount === 'clear') {
                currentBet = 0;
                if (betAmount) {
                    betAmount.textContent = '0';
                }
                
                // Update hash without validation
                gameStateHash = hashGameState();
                
                // Disable deal button if bet is cleared
                if (dealBtn) {
                    dealBtn.disabled = true;
                }
                
                debugLog("Bet cleared");
                return;
            }
            
            // Handle "Max" bet option to bet all available coins
            if (amount === 'max') {
                // Get current player balance and set as the bet
                amount = window.gameInterface.getBalance();
                debugLog(`Max bet: ${amount}`);
            }
            
            // Add to current bet
            const newBet = currentBet + amount;
            debugLog(`New bet would be: ${newBet}`);
            
            // Validate bet against player balance - use current balance as maximum
            const currentBalance = window.gameInterface.getBalance();
            if (newBet > currentBalance) {
                alert("You don't have enough coins for that bet!");
                return;
            }
            
            // Update current bet
            currentBet = newBet;
            if (betAmount) {
                betAmount.textContent = currentBet.toLocaleString();
            }
            
            // Enable deal button if bet meets minimum
            if (dealBtn) {
                dealBtn.disabled = currentBet < GAME_CONFIG.minBet;
            }
            
            // Update hash without validation since this is a valid bet action
            gameStateHash = hashGameState();
            
            debugLog(`Bet placed. Current bet: ${currentBet}`);
            
            // Turn off initialization mode to allow normal game flow
            setTimeout(() => {
                initializationMode = false;
            }, 300);
        } catch (error) {
            console.error("Error in placeBet:", error);
            alert("Error placing bet. Please try again.");
            
            // Reset to a safe state
            currentBet = 0;
            if (betAmount) {
                betAmount.textContent = '0';
            }
            if (dealBtn) {
                dealBtn.disabled = true;
            }
        }
    }

    // IMPROVED: Start dealing cards with better performance and feedback
    async function startDeal() {
        try {
            debugLog("Starting deal");
            
            // Enable initialization mode during dealing phase
            initializationMode = true;
            
            // IMPROVED: Show visual feedback immediately
            updateGameStatus("Dealing cards...");
            if (dealBtn) {
                dealBtn.disabled = true;
                dealBtn.textContent = "Dealing...";
            }
            
            // Track the action
            lastGameAction = 'startDeal';
            actionCounter++;
            
            // Check minimum bet
            if (currentBet < GAME_CONFIG.minBet) {
                alert(`Minimum bet is ${GAME_CONFIG.minBet} coins!`);
                if (dealBtn) {
                    dealBtn.disabled = false;
                    dealBtn.textContent = "Deal";
                }
                return;
            }
            
            // Check if player has enough balance
            if (currentBet > window.gameInterface.getBalance()) {
                alert("You don't have enough coins for that bet!");
                if (dealBtn) {
                    dealBtn.disabled = false;
                    dealBtn.textContent = "Deal";
                }
                return;
            }
            
            // IMPROVED: Add timeout protection to prevent hanging
            const dealTimeoutId = setTimeout(() => {
                console.error("Deal operation timed out");
                updateGameStatus("Connection issue. Try again.");
                if (dealBtn) {
                    dealBtn.disabled = false;
                    dealBtn.textContent = "Deal";
                }
                initializationMode = false;
            }, 10000); // 10 second timeout
            
            // IMPROVED: Apply bet to local UI immediately for responsiveness
            const originalBalance = window.gameInterface.getBalance();
            window._secureGameState.updateBalance(originalBalance - currentBet);
            window._secureGameState.updateDisplay();
            
            // Deal cards immediately without waiting for Firebase
            // This makes the game feel responsive even if Firebase is slow
            playerCards = [];
            dealerCards = [];
            
            // Deal cards
            playerCards.push(drawCard());
            dealerCards.push(drawCard());
            playerCards.push(drawCard());
            dealerCards.push(drawCard());
            
            // Render cards immediately
            renderCards();
            
            // IMPROVED: Clear the timeout since UI is now responsive
            clearTimeout(dealTimeoutId);
            
            // Process the bet transaction in the background
            updateCoins(currentBet, false).then(betSuccess => {
                if (!betSuccess) {
                    console.error("Transaction failed, but game continues with local state");
                    // Game continues anyway to prevent blocking
                }
            }).catch(error => {
                console.error("Error processing bet:", error);
                // Game continues anyway to prevent blocking
            });
            
            // IMPROVED: Check for blackjack
            const playerHasBlackjack = isBlackjack(playerCards);
            const dealerHasBlackjack = isBlackjack(dealerCards);
            
            if (playerHasBlackjack || dealerHasBlackjack) {
                // Reveal dealer's cards for blackjack
                isDealerTurn = true;
                renderCards();
                
                if (playerHasBlackjack && dealerHasBlackjack) {
                    // Both have blackjack - push
                    gameResult = 'push';
                    updateGameStatus("Both have Blackjack! Push!");
                    setTimeout(() => {
                        endGame();
                    }, 1500); // Reduced from 2000ms
                } else if (playerHasBlackjack) {
                    // Player has blackjack
                    gameResult = 'blackjack';
                    updateGameStatus("Blackjack! You win!");
                    setTimeout(() => {
                        endGame();
                    }, 1500); // Reduced from 2000ms
                } else {
                    // Dealer has blackjack
                    gameResult = 'lose';
                    updateGameStatus("Dealer has Blackjack! You lose.");
                    setTimeout(() => {
                        endGame();
                    }, 1500); // Reduced from 2000ms
                }
            } else {
                // Game continues - enable player actions
                enablePlayerActions();
                
                // Check if player can double down
                canDouble = window.gameInterface.getBalance() >= currentBet;
                if (doubleBtn) {
                    doubleBtn.disabled = !canDouble;
                }
            }
            
            // Reset hash and disable initialization mode after cards dealt
            gameStateHash = hashGameState();
            setTimeout(() => {
                initializationMode = false;
                if (dealBtn) {
                    dealBtn.disabled = false;
                    dealBtn.textContent = "Deal";
                }
            }, 500); // Reduced from 1000ms
        } catch (error) {
            console.error("Error in startDeal:", error);
            updateGameStatus("Error starting game. Try again.");
            if (dealBtn) {
                dealBtn.disabled = false;
                dealBtn.textContent = "Deal";
            }
            initializationMode = false;
        }
    }

    // IMPROVED: Simplified dealInitialCards function that just forwards to startDeal
    async function dealInitialCards() {
        // Now just a stub for compatibility, actual dealing is done in startDeal
        return true;
    }

    // Create a card element
    function createCardElement(card, isHidden = false) {
        const cardElement = document.createElement('div');
        cardElement.className = 'card';
        
        if (isHidden) {
            cardElement.classList.add('hidden');
            return cardElement;
        }
        
        // Add red/black class based on suit
        if (card.suit === '♥' || card.suit === '♦') {
            cardElement.classList.add('red');
        } else {
            cardElement.classList.add('black');
        }
        
        // Create card layout
        const topSection = document.createElement('div');
        topSection.className = 'card-top';
        
        const valueTop = document.createElement('div');
        valueTop.className = 'card-value';
        valueTop.textContent = card.value;
        
        const suitTop = document.createElement('div');
        suitTop.className = 'card-suit';
        suitTop.textContent = card.suit;
        
        topSection.appendChild(valueTop);
        topSection.appendChild(suitTop);
        
        const centerSection = document.createElement('div');
        centerSection.className = 'card-center';
        centerSection.textContent = card.suit;
        
        const bottomSection = document.createElement('div');
        bottomSection.className = 'card-bottom';
        
        const valueBottom = document.createElement('div');
        valueBottom.className = 'card-value';
        valueBottom.textContent = card.value;
        
        const suitBottom = document.createElement('div');
        suitBottom.className = 'card-suit';
        suitBottom.textContent = card.suit;
        
        bottomSection.appendChild(valueBottom);
        bottomSection.appendChild(suitBottom);
        
        cardElement.appendChild(topSection);
        cardElement.appendChild(centerSection);
        cardElement.appendChild(bottomSection);
        
        // Add animation
        cardElement.style.animation = 'dealCard 0.5s forwards';
        
        return cardElement;
    }

    // Update the displayed hand value
    function updateHandValues() {
        if (playerValueDisplay) {
            playerValueDisplay.textContent = calculateHandValue(playerCards);
        }
        
        // Only show dealer's visible cards value if it's not dealer's turn
        if (dealerValueDisplay) {
            if (isDealerTurn) {
                dealerValueDisplay.textContent = calculateHandValue(dealerCards);
            } else {
                // Show value of visible cards only
                const visibleCards = dealerCards.slice(1);
                dealerValueDisplay.textContent = calculateHandValue(visibleCards);
            }
        }
    }

    // Render cards to the containers
    function renderCards() {
        // Clear containers
        if (playerCardsContainer) {
            playerCardsContainer.innerHTML = '';
        }
        if (dealerCardsContainer) {
            dealerCardsContainer.innerHTML = '';
        }
        
        // Render player cards
        playerCards.forEach(card => {
            const cardElement = createCardElement(card);
            playerCardsContainer.appendChild(cardElement);
        });
        
        // Render dealer cards
        dealerCards.forEach((card, index) => {
            // First card is hidden if not dealer's turn
            const isHidden = index === 0 && !isDealerTurn;
            const cardElement = createCardElement(card, isHidden);
            dealerCardsContainer.appendChild(cardElement);
        });
        
        // Update hand values
        updateHandValues();
        
        // Validate game state after rendering
        validateGameState();
    }

    // Create a new shuffled deck
    function createDeck() {
        deck = [];
        for (let suit of suits) {
            for (let value of values) {
                deck.push({ suit, value });
            }
        }
        shuffleDeck();
    }

    // Shuffle the deck with cryptographically secure randomness
    function shuffleDeck() {
        // Get cryptographically secure random values if available
        const getSecureRandom = () => {
            if (window.crypto && window.crypto.getRandomValues) {
                const rand = new Uint32Array(1);
                window.crypto.getRandomValues(rand);
                return rand[0] / (0xFFFFFFFF + 1);
            } else {
                return Math.random();
            }
        };
        
        // Fisher-Yates shuffle with secure randomness
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(getSecureRandom() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        
        // Track the shuffle in game state
        lastGameAction = 'shuffle';
        actionCounter++;
        validateGameState();
    }

    // Draw a card from the deck
    function drawCard() {
        // If deck is running low, create a new one
        if (deck.length < 10) {
            createDeck();
        }
        
        const card = deck.pop();
        
        // Track the action
        lastGameAction = 'draw';
        actionCounter++;
        validateGameState();
        
        return card;
    }

    // Get the value of a card
    function getCardValue(card) {
        if (card.value === 'A') {
            return 11; // Ace is initially 11, will be adjusted for soft hands
        } else if (['K', 'Q', 'J'].includes(card.value)) {
            return 10;
        } else {
            return parseInt(card.value);
        }
    }

    // Calculate the total value of a hand
    function calculateHandValue(cards) {
        try {
            if (!cards || !Array.isArray(cards) || cards.length === 0) {
                return 0;
            }
            
            let total = 0;
            let aces = 0;
            
            // Sum up all cards
            for (let card of cards) {
                if (!card || !card.value) {
                    console.error("Invalid card in hand:", card);
                    continue;
                }
                
                if (card.value === 'A') {
                    aces++;
                    total += 11;
                } else if (['K', 'Q', 'J'].includes(card.value)) {
                    total += 10;
                } else {
                    const value = parseInt(card.value);
                    if (isNaN(value)) {
                        console.error("Invalid card value:", card.value);
                        continue;
                    }
                    total += value;
                }
            }
            
            // Adjust for aces if needed (convert from 11 to 1)
            while (total > 21 && aces > 0) {
                total -= 10; // Change one ace from 11 to 1
                aces--;
            }
            
            return total;
        } catch (error) {
            console.error("Error calculating hand value:", error);
            // Return a safe fallback value
            return 0;
        }
    }

    // Check if a hand is a blackjack
    function isBlackjack(cards) {
        try {
            // Must have exactly 2 cards
            if (!cards || !Array.isArray(cards) || cards.length !== 2) {
                return false;
            }
            
            // Check if one card is an Ace
            const hasAce = cards.some(card => card && card.value === 'A');
            
            // Check if one card is a 10, J, Q, or K
            const hasTenValue = cards.some(card => 
                card && (card.value === '10' || ['J', 'Q', 'K'].includes(card.value))
            );
            
            // Both conditions must be true for blackjack
            return hasAce && hasTenValue;
        } catch (error) {
            console.error("Error checking for blackjack:", error);
            return false;
        }
    }

    // Check if a hand is busted
    function isBusted(cards) {
        return calculateHandValue(cards) > 21;
    }

    // Enable player action buttons
    function enablePlayerActions() {
        if (actionControls) {
            actionControls.style.display = 'flex';
        }
        if (betControls) {
            betControls.style.display = 'none';
        }
        
        // Update game status
        updateGameStatus("Your turn");
        
        // Track the action
        lastGameAction = 'enableActions';
        actionCounter++;
        validateGameState();
    }

    // Disable player action buttons
    function disablePlayerActions() {
        if (actionControls) {
            actionControls.style.display = 'none';
        }
        
        // Track the action
        lastGameAction = 'disableActions';
        actionCounter++;
        validateGameState();
    }

    // Update the game status message
    function updateGameStatus(message) {
        if (gameStatus) {
            gameStatus.textContent = message;
        }
    }

    // Player hits - take another card
    function playerHit() {
        // Enable initialization mode during action to prevent validation errors
        initializationMode = true;
        
        // Validate current game state
        if (!validateGameState()) {
            console.error("Game state validation failed during hit");
            resetGame();
            return;
        }
        
        // Track the action
        lastGameAction = 'hit';
        actionCounter++;
        
        // Draw a card and add to player's hand
        const card = drawCard();
        playerCards.push(card);
        
        // Render cards
        renderCards();
        
        // Check if player busts
        if (isBusted(playerCards)) {
            gameResult = 'lose';
            updateGameStatus("Busted! You went over 21.");
            disablePlayerActions();
            setTimeout(() => {
                endGame();
            }, 1500); // Reduced delay
        }
        
        // Return to normal validation after a short delay
        setTimeout(() => {
            initializationMode = false;
            // Validate state after action
            gameStateHash = hashGameState();
        }, 300); // Reduced delay
    }

    // Player stands - end turn and dealer plays
    function playerStand() {
        // Enable initialization mode during action to prevent validation errors
        initializationMode = true;
        
        // Validate current game state
        if (!validateGameState()) {
            console.error("Game state validation failed during stand");
            resetGame();
            return;
        }
        
        // Track the action
        lastGameAction = 'stand';
        actionCounter++;
        
        disablePlayerActions();
        dealerPlay();
        
        // Return to normal validation after dealer finishes playing
        setTimeout(() => {
            initializationMode = false;
            // Validate state after action
            gameStateHash = hashGameState();
        }, 2000); // Reduced delay
    }

    // Player doubles down
    async function playerDoubleDown() {
        // Enable initialization mode during action to prevent validation errors
        initializationMode = true;
        
        // Validate current game state
        if (!validateGameState()) {
            console.error("Game state validation failed during double down");
            resetGame();
            return;
        }
        
        // Track the action
        lastGameAction = 'double';
        actionCounter++;
        
        try {
            // IMPROVED: Apply double to local UI immediately
            const originalBalance = window.gameInterface.getBalance();
            window._secureGameState.updateBalance(originalBalance - currentBet);
            window._secureGameState.updateDisplay();
            
            // Double the bet
            currentBet *= 2;
            
            // Update bet display
            if (betAmount) {
                betAmount.textContent = currentBet.toLocaleString();
            }
            
            // Process the bet transaction in the background
            updateCoins(currentBet/2, false).then(betSuccess => {
                if (!betSuccess) {
                    console.error("Double down transaction failed, but game continues");
                }
            });
            
            // Take only one card
            playerHit();
            
            // If not busted, stand
            if (!isBusted(playerCards)) {
                setTimeout(() => {
                    playerStand();
                }, 1000); // Reduced delay
            }
        } catch (error) {
            console.error("Error during double down:", error);
        }
        
        // Return to normal validation after a delay
        setTimeout(() => {
            initializationMode = false;
            // Validate state after action
            gameStateHash = hashGameState();
        }, 500); // Reduced delay
    }

    // Dealer plays their turn
    function dealerPlay() {
        // Enable initialization mode during dealer's turn
        initializationMode = true;
        
        // Track the action
        lastGameAction = 'dealerPlay';
        actionCounter++;
        
        isDealerTurn = true;
        renderCards();
        updateGameStatus("Dealer's turn");
        
        // Function to add cards to dealer with delay
        function dealerDraw() {
            // Get current dealer hand value
            const dealerValue = calculateHandValue(dealerCards);
            
            if (dealerValue < GAME_CONFIG.dealerStandValue) {
                // Dealer hits
                setTimeout(() => {
                    const card = drawCard();
                    dealerCards.push(card);
                    renderCards();
                    
                    // Continue drawing if needed
                    dealerDraw();
                }, 800); // Reduced delay between dealer draws
            } else {
                // Dealer stands - evaluate result
                setTimeout(() => {
                    evaluateResult();
                }, 1000); // Reduced delay
            }
        }
        
        // Start dealer drawing after a short delay
        setTimeout(() => {
            dealerDraw();
        }, 600); // Reduced delay
        
        // Update hash without validation since dealer play has many state changes
        gameStateHash = hashGameState();
    }

    // Evaluate the game result
    function evaluateResult() {
        // Track the action
        lastGameAction = 'evaluate';
        actionCounter++;
        
        // Temporarily enable initialization mode to prevent false tampering alerts
        initializationMode = true;
        
        const playerValue = calculateHandValue(playerCards);
        const dealerValue = calculateHandValue(dealerCards);
        
        if (isBusted(dealerCards)) {
            // Dealer busts, player wins
            gameResult = 'win';
            updateGameStatus("Dealer busts! You win!");
        } else if (playerValue > dealerValue) {
            // Player has higher value
            gameResult = 'win';
            updateGameStatus("You win!");
        } else if (playerValue < dealerValue) {
            // Dealer has higher value
            gameResult = 'lose';
            updateGameStatus("Dealer wins!");
        } else {
            // Equal values - push
            gameResult = 'push';
            updateGameStatus("Push!");
        }
        
        // Use shorter delay for better responsiveness 
        setTimeout(() => {
            endGame();
            // Disable initialization mode after ending game
            setTimeout(() => {
                initializationMode = false;
            }, 300); // Reduced delay
        }, 1000); // Reduced delay
        
        // Validate state after action
        gameStateHash = hashGameState();
    }

    // End the game and show result
    async function endGame() {
        // Set initialization mode to prevent validation errors during result screen
        initializationMode = true;
        
        // Track the action
        lastGameAction = 'endGame';
        actionCounter++;
        
        // Make sure other code doesn't interfere with game ending
        gameActive = false;
        
        // Hide action controls immediately
        if (actionControls) {
            actionControls.style.display = 'none';
        }
        
        // Hide bet controls until player clicks play again
        if (betControls) {
            betControls.style.display = 'none';
        }
        
        let winAmount = 0;
        
        try {
            switch (gameResult) {
                case 'blackjack':
                    // Blackjack pays 3:2
                    winAmount = Math.floor(currentBet * GAME_CONFIG.blackjackPayout);
                    
                    // IMPROVED: Apply winnings locally first, then update server in background
                    const blackjackTotal = currentBet + winAmount;
                    
                    // Update local UI immediately
                    const originalBalance = window.gameInterface.getBalance();
                    window._secureGameState.updateBalance(originalBalance + blackjackTotal);
                    window._secureGameState.updateDisplay();
                    
                    // Process the win transaction in the background
                    updateCoins(blackjackTotal, true).then(winSuccess => {
                        if (!winSuccess) {
                            console.error("Blackjack winnings transaction failed, but game continues");
                        }
                    });
                    
                    showResult("Blackjack!", `You hit 21 with two cards!<br>You won: <span class="win-amount">${winAmount}</span> coins!`, 'win');
                    break;
                    
                case 'win':
                    // Regular win pays 1:1
                    winAmount = currentBet;
                    
                    // IMPROVED: Apply winnings locally first, then update server in background
                    const winTotal = currentBet + winAmount;
                    
                    // Update local UI immediately
                    const origBalance = window.gameInterface.getBalance();
                    window._secureGameState.updateBalance(origBalance + winTotal);
                    window._secureGameState.updateDisplay();
                    
                    // Process the win transaction in the background
                    updateCoins(winTotal, true).then(winSuccess => {
                        if (!winSuccess) {
                            console.error("Win transaction failed, but game continues");
                        }
                    });
                    
                    showResult("You Win!", `You beat the dealer!<br>You won: <span class="win-amount">${winAmount}</span> coins!`, 'win');
                    break;
                    
                case 'lose':
                    // Player already paid bet at start
                    showResult("You Lose!", `The dealer won this round.<br>You lost: <span class="lose-amount">${currentBet}</span> coins.`, 'lose');
                    break;
                    
                case 'push':
                    // Return the original bet
                    
                    // IMPROVED: Apply push return locally first, then update server in background
                    // Update local UI immediately
                    const pushBalance = window.gameInterface.getBalance();
                    window._secureGameState.updateBalance(pushBalance + currentBet);
                    window._secureGameState.updateDisplay();
                    
                    // Process the push transaction in the background
                    updateCoins(currentBet, true).then(pushSuccess => {
                        if (!pushSuccess) {
                            console.error("Push transaction failed, but game continues");
                        }
                    });
                    
                    showResult("Push!", "It's a tie! Your bet has been returned.", 'push');
                    break;
            }
        } catch (error) {
            console.error("Error during game end:", error);
            // Make sure the result is still shown even if there's an error
            showResult(gameResult === 'win' ? "You Win!" : gameResult === 'lose' ? "You Lose!" : "Push!", 
                      "Game completed.", gameResult === 'win' ? 'win' : gameResult === 'lose' ? 'lose' : 'push');
        }
        
        // Don't clear cards yet - let player see the final state
        // They will be cleared when the player clicks "Play Again"
        
        // Make sure the result screen is visible
        setTimeout(() => {
            if (resultScreen && !resultScreen.classList.contains('visible')) {
                resultScreen.style.display = 'flex';
                resultScreen.classList.add('visible');
            }
        }, 300); // Reduced delay
        
        // Validate final state
        gameStateHash = hashGameState();
    }

    // Show the result screen
    function showResult(title, message, resultClass) {
        if (!resultScreen || !resultTitle || !resultMessage) {
            console.error("Result screen elements not found!");
            return;
        }
        
        // Set the result screen content
        resultTitle.textContent = title;
        resultTitle.className = `overlay-title ${resultClass}`;
        resultMessage.innerHTML = message;
        
        // Make sure the result screen is visible
        resultScreen.style.display = 'flex';
        resultScreen.classList.add('visible');
        
        // Force coin display update
        window.gameInterface.updateDisplay();
    }

    // FIXED: Setup bet buttons with direct handlers instead of using secureAction
    function setupBetButtons() {
        debugLog("Setting up bet buttons");
        
        const betButtons = document.querySelectorAll('.bet-btn');
        
        // First remove any existing event listeners by cloning and replacing each button
        betButtons.forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
        });
        
        // Get fresh references
        const freshBetButtons = document.querySelectorAll('.bet-btn');
        
        // Now attach new event listeners
        freshBetButtons.forEach(button => {
            button.addEventListener('click', function() {
                const betValue = this.getAttribute('data-amount');
                debugLog(`Bet button clicked: ${betValue}`);
                
                if (betValue === 'clear') {
                    placeBet('clear');
                } else if (betValue === 'max') {
                    placeBet('max');
                } else {
                    placeBet(parseInt(betValue));
                }
            });
        });
        
        // Setup deal button specifically
        if (dealBtn) {
            // Remove old listeners
            const newDealBtn = dealBtn.cloneNode(true);
            dealBtn.parentNode.replaceChild(newDealBtn, dealBtn);
            dealBtn = newDealBtn;
            
            // Add fresh listener
            dealBtn.addEventListener('click', function() {
                // Check if already dealing to prevent double-clicks
                if (this.disabled) return;
                
                debugLog("Deal button clicked");
                
                // Add loading indicator
                this.innerHTML = 'Dealing... <div class="loading-spinner"></div>';
                this.disabled = true;
                
                // Start the deal process
                startDeal();
            });
        }
        
        debugLog(`Set up ${freshBetButtons.length} bet buttons`);
    }

    // Fixed Start Button handler code
    function setupStartButtonHandler() {
        console.log("Setting up start button handler");
        const startBtn = document.getElementById('start-btn');
        
        if (startBtn) {
            // Remove any existing event listeners to avoid duplicates
            const newStartBtn = startBtn.cloneNode(true);
            startBtn.parentNode.replaceChild(newStartBtn, startBtn);
            
            // Get the fresh reference after replacement
            startBtn = newStartBtn;
            
            // Add event listener with direct function instead of using secureAction wrapper
            startBtn.addEventListener('click', function() {
                console.log("Start button clicked");
                debugLog("Start button clicked");
                
                // Show immediate feedback
                this.disabled = true;
                this.innerHTML = 'Starting... <div class="loading-spinner"></div>';
                
                // Initialize game with a short delay to allow UI update
                setTimeout(function() {
                    try {
                        // Enable guest mode automatically if not logged in
                        if (!window.voidGameUser && !window.guestMode) {
                            console.log("Enabling guest mode for start");
                            window.enableGuestMode();
                        }
                        
                        // Initialize game
                        initGame();
                        startBtn.innerHTML = 'Start Game';
                        startBtn.disabled = false;
                    } catch (error) {
                        console.error("Error starting game:", error);
                        startBtn.innerHTML = 'Start Game';
                        startBtn.disabled = false;
                        alert("Error starting game. Please try again.");
                    }
                }, 100);
            });
            
            console.log("Start button handler attached");
        } else {
            console.error("Start button not found");
        }
    }

    // Update your initGame function
    function initGame() {
        try {
            debugLog("Initializing game");
            
            // If guestMode is enabled, skip login check
            if (!window.voidGameUser && !window.guestMode) {
                console.log("User not logged in, showing login screen");
                let loginScreen = document.getElementById('login-required-screen');
                let startScreen = document.getElementById('start-screen');
                
                if (startScreen) {
                    startScreen.classList.remove('visible');
                }
                if (loginScreen) {
                    loginScreen.classList.add('visible');
                }
                return;
            }
        
            // Set initialization mode to avoid false tampering detection
            initializationMode = true;
            
            // Reset game state
            gameActive = true;
            currentBet = 0;
            playerCards = [];
            dealerCards = [];
            isDealerTurn = false;
            gameResult = null;
            canDouble = false;
            actionCounter = 0;
            lastGameAction = 'init';
            
            // Create and shuffle the deck
            createDeck();
            
            // Update UI
            if (betAmount) {
                betAmount.textContent = '0';
            }
            
            // Hide start screen
            if (startScreen) {
                startScreen.classList.remove('visible');
            }
            
            // Show blackjack container
            if (blackjackContainer) {
                blackjackContainer.style.display = 'flex';
            }
            
            // Show bet controls, hide action controls
            if (betControls) {
                betControls.style.display = 'block';
            }
            if (actionControls) {
                actionControls.style.display = 'none';
            }
            
            // Disable deal button until a valid bet is placed
            if (dealBtn) {
                dealBtn.disabled = true;
            }
            
            // Update game status
            updateGameStatus("Place your bet to start");
            
            // Setup bet buttons again to ensure they work
            setupBetButtons();
            
            // Start game loop for background effects
            window.cancelAnimationFrame(animationFrame);
            gameLoop();
            
            // Set initial game state hash
            gameStateHash = hashGameState();
            
            // Turn off initialization mode after setup
            setTimeout(() => {
                initializationMode = false;
            }, 500);
            
            debugLog("Game initialized successfully");
        } catch (error) {
            console.error("Error in initGame:", error);
            alert("Failed to initialize game. Please refresh the page and try again.");
        }
    }

    // Reset the game
    function resetGame() {
        // Clear any pending timeouts
        clearAllTimeouts();
        
        // Set initialization mode to prevent validation errors
        initializationMode = true;
        
        // Hide result screen if visible
        if (resultScreen) {
            resultScreen.classList.remove('visible');
        }
        
        // Make sure card containers are empty
        if (playerCardsContainer) {
            playerCardsContainer.innerHTML = '';
        }
        if (dealerCardsContainer) {
            dealerCardsContainer.innerHTML = '';
        }
        
        // Reset hand value displays
        if (playerValueDisplay) {
            playerValueDisplay.textContent = '0';
        }
        if (dealerValueDisplay) {
            dealerValueDisplay.textContent = '0';
        }
        
        // Show bet controls, hide action controls
        if (betControls) {
            betControls.style.display = 'block';
        }
        if (actionControls) {
            actionControls.style.display = 'none';
        }
        
        // Reset game state
        currentBet = 0;
        if (betAmount) {
            betAmount.textContent = '0';
        }
        actionCounter = 0;
        gameStateHash = ''; // Clear hash state
        
        // Reset game state for a new round
        initGame();
        
        // Return to normal validation after a delay
        setTimeout(() => {
            initializationMode = false;
        }, 1000); // Reduced delay
    }

    // Draw stars in background
    function drawStars() {
        if (!ctx || !canvas) return;
        
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = '#FFFFFF';
        
        for (let i = 0; i < 100; i++) {
            // Create a deterministic but varied star pattern
            const seed = i * 12437; // Large prime number
            const x = (seed % canvasWidth) % canvasWidth;
            const y = (seed * 23 % canvasHeight) % canvasHeight;
            
            // Vary the star sizes
            const size = (i % 3) + 1;
            
            // Make stars twinkle
            const alpha = 0.3 + 0.7 * Math.sin(Date.now() * 0.001 + i);
            
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1.0;
    }

    // Game loop
    function gameLoop() {
        // Draw background
        drawStars();
        
        // Continue game loop
        animationFrame = requestAnimationFrame(gameLoop);
    }

    // Initialize canvas for background
    function initCanvas() {
        canvas = document.getElementById('game-canvas');
        if (!canvas) {
            console.error("Canvas element not found!");
            return;
        }

        ctx = canvas.getContext('2d');

        const gameBoard = document.querySelector('.game-board');
        if (!gameBoard) {
            console.error("Game board element not found!");
            return;
        }

        // Get actual dimensions of the game board
        canvasWidth = gameBoard.clientWidth;
        canvasHeight = gameBoard.clientHeight;

        // Set canvas dimensions
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = canvasWidth + "px";
        canvas.style.height = canvasHeight + "px";
    }

    // Setup event listeners with security checks
    function setupEventListeners() {
        // Add a security check for all game actions
        const secureAction = (action) => {
            return function(event) {
                try {
                    // Check if user is logged in for game actions
                    if (!window.voidGameUser && !window.guestMode && this.id !== 'login-btn' && 
                        this.id !== 'back-btn' && this.id !== 'play-offline-btn' && 
                        this.id !== 'offline-continue-btn' && this.id !== 'retry-connection-btn') {
                        console.log("User not logged in, showing login screen");
                        let loginScreen = document.getElementById('login-required-screen');
                        let startScreen = document.getElementById('start-screen');
                        
                        if (startScreen) {
                            startScreen.classList.remove('visible');
                        }
                        if (loginScreen) {
                            loginScreen.classList.add('visible');
                        }
                        return;
                    }
                    
                    // Check if we're in initialization mode
                    if (initializationMode) {
                        action.call(this, event);
                    } else {
                        // Verify game hasn't been tampered with
                        if (validateGameState()) {
                            action.call(this, event);
                        } else {
                            console.error("Game state validation failed");
                            // Prevent infinite reset loops by setting initialization mode
                            initializationMode = true;
                            resetGame();
                            setTimeout(() => {
                                initializationMode = false;
                            }, 500); // Reduced timeout
                        }
                    }
                } catch (error) {
                    console.error("Error in game action:", error);
                    // Safe recovery
                    initializationMode = true;
                    resetGame();
                    setTimeout(() => {
                        initializationMode = false;
                    }, 500); // Reduced timeout
                }
            };
        };

        // Play again button
        if (playAgainBtn) {
            playAgainBtn.addEventListener('click', secureAction(function() {
                // First clear the game board before resetting
                // Clear cards from view
                if (playerCardsContainer) {
                    playerCardsContainer.innerHTML = '';
                }
                if (dealerCardsContainer) {
                    dealerCardsContainer.innerHTML = '';
                }
                
                // Clear card data arrays
                playerCards = [];
                dealerCards = [];
                
                // Hide the result screen
                if (resultScreen) {
                    resultScreen.classList.remove('visible');
                }
                
                // Then reset the game
                resetGame();
            }));
        }
        
        // Back button
        if (backBtn) {
            backBtn.addEventListener('click', function() {
                window.location.href = '/voidgms.html';
            });
        }
        
        // Action buttons
        if (hitBtn) {
            hitBtn.addEventListener('click', secureAction(playerHit));
        }
        
        if (standBtn) {
            standBtn.addEventListener('click', secureAction(playerStand));
        }
        
        if (doubleBtn) {
            doubleBtn.addEventListener('click', secureAction(playerDoubleDown));
        }
        
        // Add resize event listener
        window.addEventListener('resize', function() {
            initCanvas();
            if (gameActive) {
                drawStars();
            }
        });
    }

    // Check if user is logged in
    function checkLoginStatus() {
        let loginScreen = document.getElementById('login-required-screen');
        let startScreen = document.getElementById('start-screen');
        let loginBtn = document.getElementById('login-btn');
        
        if (loginBtn) {
            loginBtn.addEventListener('click', function() {
                window.location.href = '/voidgms.html'; // Redirect to login page
            });
        }
        
        // Add offline button handlers
        const playOfflineBtn = document.getElementById('play-offline-btn');
        if (playOfflineBtn) {
            playOfflineBtn.addEventListener('click', function() {
                window.enableGuestMode();
            });
        }
        
        setTimeout(() => {
            // Check after a short delay to ensure Firebase auth has initialized
            if (!window.voidGameUser && !window.guestMode) {
                console.log("No user logged in, showing login screen");
                if (startScreen) {
                    startScreen.classList.remove('visible');
                }
                if (loginScreen) {
                    loginScreen.classList.add('visible');
                }
            } else {
                console.log("User is logged in, game can start");
                if (loginScreen) {
                    loginScreen.classList.remove('visible');
                }
            }
            
            // Make sure start screen is visible in guest mode
            if (window.guestMode) {
                if (startScreen && !startScreen.classList.contains('visible')) {
                    startScreen.classList.add('visible');
                }
                if (loginScreen) {
                    loginScreen.classList.remove('visible');
                }
            }
        }, 500); // Reduced timeout
    }

    // Handle page visibility changes to prevent cheating via tab switching
    document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'hidden') {
            lastGameAction = 'pageHidden';
            actionCounter++;
        } else {
            lastGameAction = 'pageVisible';
            actionCounter++;
            // Re-validate when the page becomes visible again
            validateGameState();
        }
    });

    // Check connection status periodically
    function checkConnectionStatus() {
        if (!navigator.onLine && !window.guestMode) {
            console.log("Connection lost - switching to offline mode");
            
            // Show connection issue screen if not already in guest mode
            const connectionIssueScreen = document.getElementById('connection-issue-screen');
            if (connectionIssueScreen && !connectionIssueScreen.classList.contains('visible')) {
                connectionIssueScreen.classList.add('visible');
            }
        }
    }

    // Set up periodic connection checking
    setInterval(checkConnectionStatus, 30000); // Check every 30 seconds

    // Initialize the game after DOM is fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize DOM elements
        initDomElements();
        
        // Initialize canvas
        initCanvas();
        
        // Setup start button specifically
        setupStartButtonHandler();
        
        // Setup bet buttons
        setupBetButtons();
        
        // Setup other event listeners
        setupEventListeners();
        
        // Check user login status
        checkLoginStatus();
        
        // Initialize with default coin balance and check Firebase
        setTimeout(() => {
            // Delayed initialization to ensure firebase is fully loaded
            try {
                if (window.gameInterface && window.gameInterface.refreshBalance) {
                    window.gameInterface.refreshBalance().then(() => {
                        window.gameInterface.updateDisplay();
                    }).catch(err => {
                        console.error("Error refreshing balance:", err);
                        // Ensure a fallback value is displayed
                        const coinDisplay = document.getElementById('coinDisplay');
                        if (coinDisplay && coinDisplay.textContent === "0") {
                            coinDisplay.textContent = "1000";
                        }
                    });
                } else {
                    // Direct fallback if interface isn't ready
                    const coinDisplay = document.getElementById('coinDisplay');
                    if (coinDisplay && coinDisplay.textContent === "0") {
                        coinDisplay.textContent = "1000";
                    }
                }
            } catch (err) {
                console.error("Error in balance initialization:", err);
            }
        }, 300); // Reduced timeout
        
        // Make doubly sure the result screen is initially hidden
        const resultScreen = document.getElementById('result-screen');
        if (resultScreen) {
            resultScreen.classList.remove('visible');
        }
        
        // Set initial game state hash
        validateGameState();
        
        // Activate debug mode
        if (GAME_CONFIG.enableDebug) {
            const debugDisplay = document.getElementById('debug-display');
            if (debugDisplay) {
                debugDisplay.style.display = 'block';
                debugLog("Debug mode enabled");
            }
        }
    });

    // Security measures to prevent access to game internals
    (function() {
        // Override common console methods used for cheating
        const originalSetInterval = window.setInterval;
        const originalSetTimeout = window.setTimeout;
        const originalEval = window.eval;
        
        // Override eval to prevent potential injection attacks
        window.eval = function(code) {
            if (typeof code === 'string') {
                // Detect attempts to manipulate coins/balance
                const suspiciousPatterns = [
                    'coin', 'balance', 'firebase', 'update', 
                    'gameInterface', 'secureGameState', 'transaction'
                ];
                
                const lowerCode = code.toLowerCase();
                const isSuspicious = suspiciousPatterns.some(pattern => 
                    lowerCode.includes(pattern.toLowerCase())
                );
                
                if (isSuspicious) {
                    console.warn("Suspicious eval() detected and blocked");
                    return null;
                }
            }
            
            return originalEval.apply(window, arguments);
        };
        
        // Override setTimeout and setInterval to prevent timing attacks
        const monitorTimers = (originalFn) => {
            return function(handler, timeout, ...args) {
                if (typeof handler === 'string') {
                    // Check for suspicious code in string handlers
                    const lowerHandler = handler.toLowerCase();
                    if (lowerHandler.includes('coin') || 
                        lowerHandler.includes('balance') || 
                        lowerHandler.includes('firebase')) {
                        console.warn("Suspicious timer code detected and blocked");
                        return null;
                    }
                } else if (typeof handler === 'function') {
                    // Wrap function handlers to detect suspicious patterns
                    const wrappedHandler = function() {
                        try {
                            return handler.apply(this, arguments);
                        } catch (e) {
                            console.error("Timer function error:", e);
                            return null;
                        }
                    };
                    return originalFn.call(window, wrappedHandler, timeout, ...args);
                }
                
                return originalFn.apply(window, arguments);
            };
        };
        
        // Apply timer monitoring
        window.setTimeout = monitorTimers(originalSetTimeout);
        window.setInterval = monitorTimers(originalSetInterval);
        
        // Protect gameInterface from modification, but don't freeze prototypes
        // as that can cause conflicts with browser functions
        
        // Only lock down window.gameInterface properties instead of freezing the whole object
        if (window.gameInterface) {
            Object.defineProperties(window.gameInterface, {
                getBalance: { writable: false, configurable: false },
                processTransaction: { writable: false, configurable: false },
                updateDisplay: { writable: false, configurable: false },
                refreshBalance: { writable: false, configurable: false }
            });
        }
    })();
})();
</script>
</body>
</html>
