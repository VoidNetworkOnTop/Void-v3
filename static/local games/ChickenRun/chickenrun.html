<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>The Void Games - Chicken Run</title>

   <!-- Favicon -->
   <link rel="shortcut icon" href="./assets/favicon.png" type="image/png">

   <style>
       body, html {
           margin: 0;
           padding: 0;
           width: 100%;
           height: 100%;
           background: #000;
           color: #fff;
           font-family: 'Arial', sans-serif;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
       }

       .game-container {
           background: linear-gradient(180deg, #000000, #0c0c1f, #000018);
           border-radius: 10px;
           width: 90%;
           max-width: 800px;
           height: 90vh;
           max-height: 800px;
           display: flex;
           flex-direction: column;
           position: relative;
           padding: 1rem;
           box-shadow: 
               0 0 2px #fff,
               0 0 4px #fff,
               0 0 6px #4d7cff,
               0 0 8px #4d7cff,
               inset 0 0 2px rgba(255, 255, 255, 0.2);
           z-index: 3;
           overflow: hidden;
       }

       .game-header {
           text-align: center;
           padding-bottom: 1rem;
           border-bottom: 1px solid rgba(77, 124, 255, 0.2);
           position: relative;
           background: linear-gradient(90deg, transparent, rgba(77, 124, 255, 0.05), transparent);
           z-index: 10;
       }

       .game-title {
           font-size: 2.2rem;
           margin: 0 0 0.5rem 0;
           background: linear-gradient(45deg, #fff, #4d7cff);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           font-weight: bold;
           text-transform: uppercase;
           letter-spacing: 3px;
           text-shadow: 0 0 10px rgba(77, 124, 255, 0.7);
           animation: titleGlow 2s infinite alternate;
       }

       @keyframes titleGlow {
           0% { text-shadow: 0 0 5px rgba(77, 124, 255, 0.7); }
           100% { text-shadow: 0 0 15px rgba(77, 124, 255, 0.9), 0 0 30px rgba(77, 124, 255, 0.5); }
       }

       .game-subtitle {
           font-size: 1rem;
           color: #aac4ff;
           margin: 0;
           text-transform: uppercase;
           letter-spacing: 2px;
           opacity: 0.8;
       }

       .coin-tracker {
           position: absolute;
           top: 0;
           right: 0;
           background: linear-gradient(135deg, rgba(77, 124, 255, 0.1), rgba(20, 30, 60, 0.5));
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           padding: 0.5rem 1rem;
           display: flex;
           align-items: center;
           gap: 0.5rem;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.3);
           animation: glow 2s infinite;
           backdrop-filter: blur(5px);
           z-index: 10;
       }

       .coin-icon {
           width: 20px;
           height: 20px;
           background: linear-gradient(135deg, #FFD700, #FFA500);
           border-radius: 50%;
           box-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
           position: relative;
           overflow: hidden;
       }

       .coin-icon::after {
           content: '';
           position: absolute;
           top: 3px;
           left: 3px;
           width: 6px;
           height: 6px;
           background: rgba(255, 255, 255, 0.8);
           border-radius: 50%;
       }

       .coin-amount {
           font-weight: bold;
           font-size: 1.1rem;
           color: #FFD700;
           text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
       }

       .game-board {
           flex-grow: 1;
           position: relative;
           overflow: hidden;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           background: #1a1a2e;
           border-radius: 8px;
           margin: 1rem 0;
           min-height: 60vh;
           border: 1px solid rgba(77, 124, 255, 0.2);
           box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
           padding: 20px;
       }

       #game-canvas {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: transparent;
           z-index: 1;
           display: block;
       }

       .game-overlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           background: rgba(0, 8, 30, 0.85);
           z-index: 100; /* Higher z-index to ensure it's above everything */
           opacity: 0;
           pointer-events: none;
           transition: opacity 0.3s ease;
           backdrop-filter: blur(4px);
       }

       .game-overlay.visible {
           opacity: 1;
           pointer-events: all;
           animation: fadeIn 0.5s ease-out;
       }

       @keyframes fadeIn {
           from { opacity: 0; }
           to { opacity: 1; }
       }

       .overlay-content {
           text-align: center;
           padding: 2.5rem;
           background: linear-gradient(135deg, rgba(13, 21, 40, 0.9), rgba(5, 10, 30, 0.9));
           border-radius: 10px;
           border: 1px solid rgba(77, 124, 255, 0.3);
           box-shadow: 0 0 30px rgba(77, 124, 255, 0.2);
           max-width: 80%;
           animation: floatEffect 4s infinite ease-in-out;
       }

       @keyframes floatEffect {
           0%, 100% { transform: translateY(0); }
           50% { transform: translateY(-10px); }
       }

       .overlay-title {
           font-size: 2.5rem;
           margin-bottom: 1rem;
           text-transform: uppercase;
           letter-spacing: 3px;
           font-weight: bold;
       }

       .overlay-title.win {
           background: linear-gradient(45deg, #4CAF50, #8BC34A);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
       }

       .overlay-title.lose {
           background: linear-gradient(45deg, #f44336, #E91E63);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           text-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
       }

       .overlay-message {
           font-size: 1.2rem;
           margin-bottom: 2rem;
           color: #aac4ff;
           line-height: 1.6;
       }

       .game-btn {
           padding: 0.75rem 2rem;
           font-size: 1.2rem;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           color: #fff;
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           cursor: pointer;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.2);
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 2px;
           font-weight: bold;
           position: relative;
           overflow: hidden;
           margin: 0.5rem;
       }

       .game-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
           transition: all 0.6s ease;
       }

       .game-btn:hover::before {
           left: 100%;
       }

       .game-btn:hover {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: translateY(-2px);
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.3);
       }

       .game-btn:active {
           transform: translateY(1px);
       }

       .game-btn:disabled {
           opacity: 0.5;
           cursor: not-allowed;
           background: linear-gradient(135deg, #444, #333);
       }

       .game-btn.insufficient {
           background: linear-gradient(135deg, #70283f, #350f1a);
           color: #ffcccc;
           border-color: rgba(244, 67, 54, 0.4);
       }

       /* Level selection styles */
       .level-selection {
           display: flex;
           flex-wrap: wrap;
           justify-content: center;
           margin: 1rem 0;
           gap: 0.5rem;
       }

       .level-btn {
           padding: 0.6rem 1.5rem;
           background: linear-gradient(135deg, #1f3a70, #0a1835);
           border: 1px solid rgba(77, 124, 255, 0.4);
           border-radius: 30px;
           cursor: pointer;
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 1px;
           font-weight: bold;
           color: #aac4ff;
       }

       .level-btn.selected {
           background: linear-gradient(135deg, #4d7cff, #2a4b8d);
           color: #fff;
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.4);
       }

       .level-btn:hover:not(.selected) {
           background: linear-gradient(135deg, #2a4b8d, #132345);
           transform: translateY(-2px);
       }

       .cashout-btn {
           padding: 0.75rem 2rem;
           font-size: 1.2rem;
           background: linear-gradient(135deg, #2e7d32, #1b5e20);
           color: #fff;
           border: 1px solid rgba(76, 175, 80, 0.4);
           border-radius: 30px;
           cursor: pointer;
           box-shadow: 0 0 10px rgba(76, 175, 80, 0.2);
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 2px;
           font-weight: bold;
           position: relative;
           overflow: hidden;
           margin-top: 15px;
           margin-bottom: 10px;
           z-index: 20;
           width: 200px;
           text-align: center;
       }

       .cashout-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
           transition: all 0.6s ease;
       }

       .cashout-btn:hover::before {
           left: 100%;
       }

       .cashout-btn:hover {
           background: linear-gradient(135deg, #388e3c, #2e7d32);
           transform: translateY(-2px);
           box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
       }

       .cashout-btn:active {
           transform: translateY(1px);
       }

       .cashout-btn:disabled {
           background: linear-gradient(135deg, #1b5e20, #0f3013);
           opacity: 0.7;
           cursor: not-allowed;
       }

       .controls {
           display: flex;
           justify-content: center;
           align-items: center;
           padding: 1rem 0;
           gap: 1rem;
           z-index: 10;
       }

       .restart-btn {
           padding: 0.75rem 1.5rem;
           font-size: 1rem;
           background: linear-gradient(135deg, #192238, #0d1526);
           color: #aac4ff;
           border: 1px solid rgba(77, 124, 255, 0.2);
           border-radius: 30px;
           cursor: pointer;
           transition: all 0.3s ease;
           text-transform: uppercase;
           letter-spacing: 1px;
           position: relative;
           overflow: hidden;
       }

       .restart-btn::before {
           content: '';
           position: absolute;
           top: 0;
           left: -100%;
           width: 100%;
           height: 100%;
           background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
           transition: all 0.6s ease;
       }

       .restart-btn:hover::before {
           left: 100%;
       }

       .restart-btn:hover {
           color: #fff;
           border-color: rgba(77, 124, 255, 0.4);
           background: linear-gradient(135deg, #243252, #131e36);
       }

       .score-display {
           text-align: center;
           margin-top: 1rem;
           font-size: 1.2rem;
           height: 1.5rem;
           color: #aac4ff;
           text-shadow: 0 0 5px rgba(77, 124, 255, 0.5);
           background: linear-gradient(90deg, transparent, rgba(77, 124, 255, 0.05), transparent);
           padding: 0.2rem 0;
           border-radius: 20px;
           z-index: 10;
       }

       .win-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #4caf50;
           text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
       }

       .lose-amount {
           font-weight: bold;
           font-size: 1.4rem;
           color: #f44336;
           text-shadow: 0 0 5px rgba(244, 67, 54, 0.5);
       }

       /* Chicken Run specific styles */
       #chicken-run-container {
           z-index: 10;
           width: 100%;
           height: 100%;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           overflow: hidden;
           position: relative;
       }

       .game-info {
           background: rgba(10, 20, 40, 0.6);
           border-radius: 20px;
           border: 1px solid rgba(77, 124, 255, 0.2);
           padding: 10px 20px;
           color: white;
           font-size: 1.1rem;
           text-align: center;
           margin-bottom: 15px;
           max-width: 90%;
           z-index: 10;
       }

       .chicken-path {
           display: flex;
           justify-content: space-between;
           align-items: center;
           width: 90%;
           max-width: 700px;
           height: 150px;
           position: relative;
           margin: 20px auto;
           background: rgba(10, 20, 40, 0.3);
           border-radius: 20px;
           border: 1px solid rgba(77, 124, 255, 0.2);
           padding: 10px;
       }

       .path-circle {
           width: 40px;
           height: 40px;
           border-radius: 50%;
           background: rgba(77, 124, 255, 0.3);
           border: 2px solid rgba(77, 124, 255, 0.6);
           cursor: pointer;
           transition: all 0.3s ease;
           display: flex;
           align-items: center;
           justify-content: center;
           font-weight: bold;
           color: white;
           position: relative;
           z-index: 10;
           box-shadow: 0 0 10px rgba(77, 124, 255, 0.4);
       }

       .path-circle:hover {
           transform: scale(1.1);
           background: rgba(77, 124, 255, 0.5);
           box-shadow: 0 0 15px rgba(77, 124, 255, 0.7);
       }

       .path-circle.active {
           background: rgba(76, 175, 80, 0.5);
           border-color: rgba(76, 175, 80, 0.8);
           box-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
       }

       .path-circle.danger {
           animation: dangerPulse 1s infinite alternate;
       }

       @keyframes dangerPulse {
           0% { background: rgba(244, 67, 54, 0.3); border-color: rgba(244, 67, 54, 0.6); }
           100% { background: rgba(244, 67, 54, 0.6); border-color: rgba(244, 67, 54, 0.9); box-shadow: 0 0 15px rgba(244, 67, 54, 0.7); }
       }

       .path-line {
           height: 3px;
           flex-grow: 1;
           background: linear-gradient(90deg, rgba(77, 124, 255, 0.3), rgba(77, 124, 255, 0.5));
           margin: 0 5px;
       }

       .chicken {
           width: 50px;
           height: 50px;
           background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36"><path fill="%23FFCC4D" d="M36 18c0 9.941-8.059 18-18 18-9.94 0-18-8.059-18-18C0 8.06 8.06 0 18 0c9.941 0 18 8.06 18 18"/><path fill="%23F4900C" d="M18 21.849c-2.966 0-4.935-.346-7.369-.819-.557-.108-1.394.817-1.237 1.346.465 1.566 4.018 3.774 8.606 3.774 4.589 0 8.141-2.208 8.606-3.774.157-.529-.681-1.453-1.237-1.346-2.434.474-4.402.819-7.369.819"/><path fill="%23FFFFFF" d="M30.313 17.312c0 .803-.652 1.455-1.455 1.455-1.318 0-1.746-.059-2.388-.221-.642-.162-.642-1.795 0-1.957.642-.16 1.07-.22 2.388-.22.803 0 1.455.652 1.455 1.455m-24.626 0c0 .803.652 1.455 1.455 1.455 1.318 0 1.746-.059 2.388-.221.642-.162.642-1.795 0-1.957-.642-.16-1.07-.22-2.388-.22-.803 0-1.455.652-1.455 1.455"/><path fill="%23662113" d="M18 4.942c-2.347 0-2.348 1.667-4.696 2.113-1.594.303-4.525.036-4.525 2.613 0 .901 1.233 1.396 1.233 1.396s-.334.535-.334 1.339c0 .803.386 1.677 1.71 1.677 1.839 0 3.2.881 6.612.881 3.413 0 4.774-.881 6.612-.881 1.325 0 1.71-.874 1.71-1.677 0-.803-.334-1.339-.334-1.339s1.233-.495 1.233-1.396c0-2.577-2.931-2.309-4.525-2.613-2.347-.446-2.349-2.113-4.696-2.113"/><path fill="%23DF1F32" d="M21.219 14.078c-.452 0-1.339.732-3.219.732-1.88 0-2.767-.732-3.219-.732-.324 0-.584.263-.584.588 0 .324.26.732.584.732.452 0 1.532.732 3.219.732 1.687 0 2.767-.732 3.219-.732.324 0 .584-.408.584-.732 0-.325-.26-.588-.584-.588"/><path fill="%23F4900C" d="M17.976 20.697c-3.093 0-4.269-.445-4.269-.445s1.162.756 4.281.756c3.12 0 4.269-.756 4.269-.756s-1.189.445-4.281.445"/></svg>');
           background-size: contain;
           position: absolute;
           top: 50%;
           transform: translateY(-50%);
           left: 10px; /* Starting position */
           transition: left 0.5s ease;
           z-index: 10;
       }

       .chicken.chicken-dead {
           background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36"><path fill="%23FFCC4D" d="M36 18c0 9.941-8.059 18-18 18-9.94 0-18-8.059-18-18C0 8.06 8.06 0 18 0c9.941 0 18 8.06 18 18"/><path fill="%23F4900C" d="M32.755 16.353c-.759 0-1.626 1.318-1.626 2.422 0 .589.369 1.124.961 1.124.592 0 1.069-.38 1.069-.967 0-.79-.92-1.631-1.513-1.631.095-.345.679-.436.679-.947-.001-.213-.202-.329-.405-.329M21.204 28.57c-1.547 0-2.8-1.254-2.8-2.8s1.254-2.8 2.8-2.8 2.8 1.254 2.8 2.8-1.254 2.8-2.8 2.8z"/><path fill="%23292F33" d="M26.954 12.913c0 1.414-1.146 2.561-2.56 2.561-1.414 0-2.56-1.146-2.56-2.561 0-1.413 1.146-2.56 2.56-2.56 1.413 0 2.56 1.147 2.56 2.56m-12.789 0c0 1.414-1.146 2.561-2.56 2.561-1.414 0-2.56-1.146-2.56-2.561 0-1.413 1.146-2.56 2.56-2.56 1.413 0 2.56 1.147 2.56 2.56"/><path fill="%23E1E8ED" d="M25.751 13.203c0 .745-.604 1.349-1.349 1.349-.746 0-1.35-.604-1.35-1.349 0-.746.604-1.35 1.35-1.35.745 0 1.349.604 1.349 1.35m-11.389 0c0 .745-.604 1.349-1.349 1.349-.746 0-1.35-.604-1.35-1.349 0-.746.604-1.35 1.35-1.35.745 0 1.349.604 1.349 1.35"/><path fill="%23662113" d="M25.564 21.384c-.554 0-1.058-.078-1.483-.196-.463-.127-.837-.31-1.085-.554-.151-.148-.257-.319-.311-.515-.05-.182-.063-.367-.037-.562.043-.323.205-.658.478-.994.274-.334.668-.676 1.177-.994 1.015-.636 2.453-1.133 4.073-1.133.743 0 1.282.162 1.653.367.184.102.334.216.443.338.125.139.192.264.25.479.078.292.051.655-.079 1.059-.129.403-.352.842-.656 1.278-.608.872-1.613 1.674-2.932 2.176-.629.239-1.009.349-1.491.251z"/><path fill="%23C1694F" d="M28.376 16.711c.508 0 .873.161 1.064.28.096.06.159.119.192.167.042.06.071.103.103.231.039.146.006.39-.093.703-.097.305-.28.657-.531 1.017-.503.721-1.386 1.427-2.524 1.859-.449.17-.645.207-.9.15-.282 0-.607-.047-.883-.123-.308-.084-.563-.195-.698-.336-.074-.073-.111-.138-.128-.203-.013-.049-.01-.088-.004-.139.02-.149.127-.374.337-.632.21-.257.525-.539.952-.803.854-.527 2.053-.976 3.413-.976m0-1c-1.724 0-3.338.536-4.326 1.191-1.168.734-1.895 1.707-1.895 2.526 0 .608.336 1.083.615 1.358.566.558 1.583.963 2.794.963.337 0 .907-.017 1.764-.447 3.061-1.542 3.932-4.237 3.932-5.191 0-.853-.855-1.4-2.884-1.4z"/><path fill="%23662113" d="M10.435 21.384c.554 0 1.058-.078 1.483-.196.463-.127.837-.31 1.085-.554.151-.148.257-.319.311-.515.05-.182.063-.367.037-.562-.043-.323-.205-.658-.478-.994-.274-.334-.668-.676-1.177-.994-1.015-.636-2.453-1.133-4.073-1.133-.742 0-1.282.162-1.653.367-.184.102-.334.216-.443.338-.125.139-.192.264-.25.479-.078.292-.051.655.079 1.059.129.403.352.842.656 1.278.608.872 1.613 1.674 2.932 2.176.628.239 1.008.349 1.491.251z"/><path fill="%23C1694F" d="M7.624 16.711c-.508 0-.873.161-1.064.28-.096.06-.159.119-.192.167-.042.06-.071.103-.103.231-.039.146-.006.39.093.703.097.305.28.657.531 1.017.503.721 1.386 1.427 2.524 1.859.449.17.645.207.9.15.282 0 .607-.047.883-.123.308-.084.563-.195.698-.336.074-.073.111-.138.128-.203.013-.049.01-.088.004-.139-.02-.149-.127-.374-.337-.632-.21-.257-.525-.539-.952-.803-.854-.527-2.053-.976-3.413-.976m0-1c1.724 0 3.338.536 4.326 1.191 1.168.734 1.895 1.707 1.895 2.526 0 .608-.336 1.083-.615 1.358-.566.558-1.583.963-2.794.963-.337 0-.907-.017-1.764-.447C5.611 19.76 4.74 17.065 4.74 16.111c0-.853.855-1.4 2.884-1.4z"/><path fill="%23FFAC33" d="M20.5 28.471c0 1.974-1.605 3.574-3.578 3.574-1.974 0-3.578-1.6-3.578-3.574 0-1.973 1.604-3.574 3.578-3.574 1.973 0 3.578 1.601 3.578 3.574z"/><path fill="%23C1694F" d="M16.021 24.182c-.305.354-.659.674-1.051.945-1.026-1.732-3.106-2.3-4.794-1.324-.165-1.261-.235-2.556-.235-3.802 0-.557.018-1.112.047-1.667 3.276 1.128 6.169 3.226 8.193 5.914-.773-.159-1.541-.241-2.16-.066z"/></svg>');
           animation: chickenDying 1s forwards;
       }

       @keyframes chickenDying {
           0% { transform: translateY(-50%) rotate(0deg); }
           25% { transform: translateY(-50%) rotate(20deg); }
           50% { transform: translateY(-50%) rotate(-20deg); }
           75% { transform: translateY(-50%) rotate(10deg); }
           100% { transform: translateY(-50%) rotate(-90deg); }
       }

       .blood-splatter {
           position: absolute;
           width: 80px;
           height: 80px;
           background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path fill="%23E81123" d="M50 20c-16.569 0-30 13.431-30 30 0 16.569 13.431 30 30 30 16.569 0 30-13.431 30-30 0-16.569-13.431-30-30-30zm-7.5 15c2.071 0 3.75 1.679 3.75 3.75 0 2.071-1.679 3.75-3.75 3.75-2.071 0-3.75-1.679-3.75-3.75 0-2.071 1.679-3.75 3.75-3.75zm-7.5 7.5c1.381 0 2.5 1.119 2.5 2.5s-1.119 2.5-2.5 2.5-2.5-1.119-2.5-2.5 1.119-2.5 2.5-2.5zm35 27.5c-2.071 0-3.75-1.679-3.75-3.75 0-2.071 1.679-3.75 3.75-3.75 2.071 0 3.75 1.679 3.75 3.75 0 2.071-1.679 3.75-3.75 3.75zm-5-17.5c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5zm-15 15c-2.761 0-5-2.239-5-5s2.239-5 5-5 5 2.239 5 5-2.239 5-5 5z"/></svg>');
           background-size: contain;
           opacity: 0;
           transform: translate(-50%, -50%);
           z-index: 9;
           pointer-events: none;
       }

       .blood-splatter.active {
           animation: bloodSplatter 0.8s forwards;
       }

       @keyframes bloodSplatter {
           0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
           60% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
           100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
       }

       .current-earning {
           font-size: 1.3rem;
           font-weight: bold;
           color: #4caf50;
           margin: 10px 0;
           text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
       }

       .game-actions {
           display: flex;
           flex-direction: column;
           align-items: center;
           margin-top: 20px;
       }

       /* Special Effects */
       @keyframes glow {
           0% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
           50% { filter: drop-shadow(0 0 10px rgba(77, 124, 255, 0.9)); }
           100% { filter: drop-shadow(0 0 2px rgba(77, 124, 255, 0.7)); }
       }

       /* Media queries for better responsiveness */
       @media (max-height: 700px) {
           .chicken-path {
               height: 100px;
           }

           .path-circle {
               width: 30px;
               height: 30px;
           }

           .chicken {
               width: 40px;
               height: 40px;
           }

           .game-info {
               font-size: 0.9rem;
               padding: 5px 15px;
           }

           .overlay-content {
               padding: 1.5rem;
           }

           .overlay-title {
               font-size: 2rem;
               margin-bottom: 0.5rem;
           }

           .overlay-message {
               font-size: 1rem;
               margin-bottom: 1rem;
           }

           .cashout-btn {
               padding: 0.5rem 1.5rem;
               font-size: 1rem;
           }
       }

       @media (max-width: 600px) {
           .path-circle {
               width: 25px;
               height: 25px;
               font-size: 0.8rem;
           }

           .chicken {
               width: 35px;
               height: 35px;
           }

           .chicken-path {
               height: 80px;
           }

           .overlay-title {
               font-size: 1.8rem;
           }

           .overlay-message {
               font-size: 0.9rem;
           }

           .game-title {
               font-size: 1.8rem;
           }

           .level-btn {
               padding: 0.5rem 1rem;
               font-size: 0.8rem;
           }
       }
   </style>
</head>

<body>
   <div class="game-container">
       <div class="game-header">
           <h1 class="game-title">Chicken Run</h1>
           <p class="game-subtitle">How far will you dare to go?</p>
           <div class="coin-tracker">
               <div class="coin-icon"></div>
               <span class="coin-amount" id="coinDisplay">0</span>
           </div>
       </div>

       <div class="game-board">
           <canvas id="game-canvas"></canvas>
           <div id="chicken-run-container" style="display: none;">
               <div class="game-info" id="game-info">
                   Click the next circle to move forward. Each step earns coins but has a chance of failure!
               </div>
               
               <div class="current-earning" id="current-earning">Current: 0 coins</div>
               
               <div class="chicken-path" id="chicken-path">
                   <!-- Path circles will be created by JavaScript -->
                   <div class="chicken" id="chicken"></div>
                   <div class="blood-splatter" id="blood-splatter"></div>
               </div>
               
               <div class="game-actions">
                   <button id="cashout-btn" class="cashout-btn" disabled>Cash Out</button>
               </div>
           </div>

           <!-- Start Screen Overlay -->
           <div class="game-overlay visible" id="start-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title">Chicken Run</h2>
                   <p class="overlay-message">
                       Test your luck with the brave chicken!<br>
                       Choose a level to start playing.<br>
                       You can cash out anytime to keep your earnings.<br>
                       The more circles you choose, the higher the reward per step!<br>
                       But beware, the risk increases as you progress!
                   </p>
                   
                   <div class="level-selection">
                       <button id="level-10" class="level-btn selected" data-level="10">10 Circles</button>
                       <button id="level-20" class="level-btn" data-level="20">20 Circles</button>
                       <button id="level-30" class="level-btn" data-level="30">30 Circles</button>
                   </div>
                   
                   <button id="start-btn" class="game-btn">Start Game</button>
               </div>
           </div>

           <!-- Game Result Overlay -->
           <div class="game-overlay" id="result-screen">
               <div class="overlay-content">
                   <h2 class="overlay-title" id="result-title">Chicken Died!</h2>
                   <p class="overlay-message" id="result-message">
                       You lost! The chicken didn't make it...<br>
                       Better luck next time!
                   </p>
                   <button id="play-again-btn" class="game-btn">Play Again</button>
               </div>
           </div>
       </div>

       <div class="controls">
           <button id="back-btn" class="restart-btn">Back to Beta Games</button>
       </div>
   </div>

   <!-- Firebase SDK -->
   <script type="module">
       // Firebase Imports
       import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
       import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
       import { 
           getFirestore, 
           doc, 
           getDoc, 
           updateDoc, 
           setDoc, 
           collection,
           serverTimestamp,
           increment,
           runTransaction
       } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore.js";

       // Firebase Configuration
       const firebaseConfig = {
           apiKey: "AIzaSyCkAp_GCGCtw4zv7GgHJOE9GPgIaPEuOvQ",
           authDomain: "void-games-c8d9e.firebaseapp.com",
           projectId: "void-games-c8d9e",
           storageBucket: "void-games-c8d9e.firebasestorage.app",
           messagingSenderId: "1063089929776",
           appId: "1:1063089929776:web:8e226a23a4f3ab9c5777f5"
       };

       // Initialize Firebase
       const app = initializeApp(firebaseConfig);
       const auth = getAuth(app);
       const db = getFirestore(app);

       /* Create Secure Game Interface - Encapsulated from global scope */
       const createSecureGameInterface = () => {
           // Private variables - inaccessible from console
           let _coinBalance = 0;
           let _securityToken = '';
           let _gameSessionId = '';
           let _transactionLock = false;
           let _pendingTransactions = [];
           let _lastServerSync = 0;
           let _sessionStartTime = Date.now();
           let _securityChecks = {
               lastCheck: Date.now(),
               domIntegrityPassed: true,
               windowObjectsClean: true
           };
           let _previousActions = [];
           
           // Generate a unique session ID for this game instance
           const generateSessionId = () => {
               const buffer = new Uint8Array(16);
               window.crypto.getRandomValues(buffer);
               return Array.from(buffer, b => b.toString(16).padStart(2, '0')).join('');
           };
           
           // Create a security token with the Web Crypto API
           const generateSecurityToken = async (userId) => {
               if (!userId) return '';
               
               const timestamp = Date.now();
               const rawToken = `${userId}:${timestamp}:${_gameSessionId}`;
               
               // Use SubtleCrypto for strong token generation
               const encoder = new TextEncoder();
               const data = encoder.encode(rawToken);
               const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
               const hashArray = Array.from(new Uint8Array(hashBuffer));
               const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
               
               return `${timestamp.toString(36)}.${hashHex}`;
           };
           
           // Initialize security systems
           const initSecurity = async (userId) => {
               // Generate a unique session ID
               _gameSessionId = generateSessionId();
               _securityToken = await generateSecurityToken(userId);
               _sessionStartTime = Date.now();
               _lastServerSync = Date.now();
               
               // Set up anti-debugging and anti-cheat measures
               setupAntiTampering();
               
               // Start periodic security checks
               scheduleSecurityChecks();
           };
           
           // Setup anti-tampering protection
           const setupAntiTampering = () => {
               // Create trap properties on window that detect tampering attempts
               Object.defineProperty(window, '_debugMode', {
                   get: function() {
                       recordTamperingAttempt('debug_access');
                       return false;
                   },
                   configurable: false
               });
               
               // Protect against function overrides (console methods)
               const originalConsoleLog = console.log;
               console.log = function(...args) {
                   // Check for suspicious console activity
                   const joined = args.join(' ').toLowerCase();
                   if (joined.includes('coinbalance') || 
                       joined.includes('updatecoins') || 
                       joined.includes('firebase') || 
                       joined.includes('hack')) {
                       recordTamperingAttempt('console_hack_attempt');
                   }
                   return originalConsoleLog.apply(console, args);
               };
               
               // Monitor for DevTools opening
               window.addEventListener('resize', detectDevTools);
               window.addEventListener('devtoolschange', function(e) {
                   if (e.detail.open) {
                       recordTamperingAttempt('devtools_opened');
                   }
               });
           };
           
           // Detect DevTools opening via window dimensions
           const detectDevTools = () => {
               const widthThreshold = window.outerWidth - window.innerWidth > 160;
               const heightThreshold = window.outerHeight - window.innerHeight > 160;
               
               if (widthThreshold || heightThreshold) {
                   recordTamperingAttempt('devtools_detected');
               }
           };
           
           // Schedule regular security checks
           const scheduleSecurityChecks = () => {
               // Randomize check intervals to make them harder to predict
               const interval = 5000 + Math.random() * 5000;
               
               setInterval(() => {
                   performSecurityChecks();
               }, interval);
               
               // Also check on user interactions like clicks
               document.addEventListener('click', () => {
                   // Only check occasionally (not every click) to avoid performance issues
                   if (Math.random() < 0.2) {
                       performSecurityChecks();
                   }
               }, true);
           };
           
           // Perform comprehensive security checks
           const performSecurityChecks = () => {
               const now = Date.now();
               _securityChecks.lastCheck = now;
               
               // Check DOM integrity
               _securityChecks.domIntegrityPassed = verifyDomIntegrity();
               
               // Check for exposed game objects in window
               _securityChecks.windowObjectsClean = verifyWindowObjects();
               
               // Check if synchronized with server recently
               if (now - _lastServerSync > 60000) { // 1 minute
                   refreshServerData();
               }
               
               // If any check fails, take corrective action
               if (!_securityChecks.domIntegrityPassed || !_securityChecks.windowObjectsClean) {
                   handleSecurityViolation();
               }
           };
           
           // Verify DOM hasn't been tampered with
           const verifyDomIntegrity = () => {
               // Check if essential game elements exist and haven't been modified
               const gameContainer = document.querySelector('.game-container');
               const gameBoard = document.querySelector('.game-board');
               const coinDisplay = document.getElementById('coinDisplay');
               
               if (!gameContainer || !gameBoard || !coinDisplay) {
                   recordTamperingAttempt('dom_elements_missing');
                   return false;
               }
               
               // Check if the structure is as expected
               if (gameContainer.children.length !== 3) {
                   recordTamperingAttempt('dom_structure_modified');
                   return false;
               }
               
               return true;
           };
           
           // Verify window objects haven't been tampered with
           const verifyWindowObjects = () => {
               // Check for exposed sensitive objects
               if (window.coinBalance !== undefined || 
                   window.updateCoins !== undefined || 
                   window.GAME_CONFIG !== undefined) {
                   recordTamperingAttempt('game_objects_exposed');
                   return false;
               }
               
               return true;
           };
           
           // Handle security violations
           const handleSecurityViolation = () => {
               // Record the violation
               recordTamperingAttempt('security_check_failed');
               
               // Take action based on severity and frequency
               const violations = _previousActions.filter(a => a.type === 'security_violation').length;
               
               if (violations > 2) {
                   // Third+ violation: Force page refresh
                   forcePageRefresh();
               } else {
                   // First/second violation: Subtle interference
                   createTechnicalDifficulties();
               }
           };
           
           // Create "technical difficulties" to subtly disrupt potential cheating
           const createTechnicalDifficulties = () => {
               // Make game behavior unpredictable but don't immediately reveal detection
               setTimeout(() => {
                   // Random actions to frustrate cheating attempts
                   const difficultyActions = [
                       () => {
                           // Temporarily freeze UI
                           const overlay = document.createElement('div');
                           overlay.style.position = 'fixed';
                           overlay.style.top = '0';
                           overlay.style.left = '0';
                           overlay.style.width = '100%';
                           overlay.style.height = '100%';
                           overlay.style.background = 'transparent';
                           overlay.style.zIndex = '1000';
                           document.body.appendChild(overlay);
                           setTimeout(() => document.body.removeChild(overlay), 2000 + Math.random() * 3000);
                       },
                       () => {
                           // Force synchronization with server
                           refreshServerData();
                       },
                       () => {
                           // Subtly modify UI without breaking functionality
                           const buttons = document.querySelectorAll('button');
                           buttons.forEach(btn => {
                               const originalOnClick = btn.onclick;
                               btn.onclick = function(e) {
                                   // Add slight delay
                                   setTimeout(() => {
                                       if (originalOnClick) originalOnClick.call(this, e);
                                   }, 200 + Math.random() * 500);
                               };
                           });
                       }
                   ];
                   
                   // Choose a random action
                   const action = difficultyActions[Math.floor(Math.random() * difficultyActions.length)];
                   action();
               }, Math.random() * 5000);
           };
           
           // Force page refresh as last resort against tampering
           const forcePageRefresh = () => {
               // Add random delay to make it harder to predict
               setTimeout(() => {
                   try {
                       window.location.reload();
                   } catch (e) {
                       // If reload is blocked somehow, disable game functionality
                       disableGameFunctionality();
                   }
               }, Math.random() * 3000);
           };
           
           // Disable game functionality as fallback if refresh is blocked
           const disableGameFunctionality = () => {
               const gameElements = document.querySelectorAll('button, .path-circle');
               gameElements.forEach(el => {
                   el.disabled = true;
                   el.style.pointerEvents = 'none';
               });
               
               // Show subtle error message
               const gameBoard = document.querySelector('.game-board');
               if (gameBoard) {
                   const errorMsg = document.createElement('div');
                   errorMsg.style.position = 'absolute';
                   errorMsg.style.top = '50%';
                   errorMsg.style.left = '50%';
                   errorMsg.style.transform = 'translate(-50%, -50%)';
                   errorMsg.style.color = '#f44336';
                   errorMsg.style.textAlign = 'center';
                   errorMsg.innerHTML = 'Connection lost. Please refresh the page.';
                   gameBoard.appendChild(errorMsg);
               }
           };
           
           // Record tampering attempts to Firebase
           const recordTamperingAttempt = async (attemptType) => {
               if (!auth.currentUser) return;
               
               try {
                   // Add to local record for rate limiting responses
                   _previousActions.push({
                       type: 'security_violation',
                       attemptType: attemptType,
                       timestamp: Date.now()
                   });
                   
                   // If too many records, remove oldest
                   if (_previousActions.length > 20) {
                       _previousActions.shift();
                   }
                   
                   // Record to Firebase if not in rapid succession (rate limiting)
                   const recentAttempts = _previousActions.filter(a => 
                       a.type === 'security_violation' && 
                       Date.now() - a.timestamp < 10000
                   ).length;
                   
                   if (recentAttempts <= 3) {
                       const tamperRef = doc(collection(db, 'security_events'));
                       await setDoc(tamperRef, {
                           userId: auth.currentUser.uid,
                           gameId: 'chicken_run_game',
                           attemptType: attemptType,
                           timestamp: serverTimestamp(),
                           userAgent: navigator.userAgent,
                           sessionId: _gameSessionId
                       });
                   }
               } catch (error) {
                   console.error("Error recording security event");
               }
           };
           
           // Load coin balance securely from Firebase
           const loadUserBalance = async () => {
               if (!auth.currentUser) {
                   console.log("No user available to load balance");
                   return 1000; // Default fallback balance
               }

               try {
                   // Perform transaction to ensure data consistency
                   const userRef = doc(db, 'users', auth.currentUser.uid);
                   
                   // Use a transaction for data integrity
                   const newBalance = await runTransaction(db, async (transaction) => {
                       const userDoc = await transaction.get(userRef);
                       
                       if (!userDoc.exists()) {
                           // Create initial user data if doesn't exist
                           transaction.set(userRef, {
                               accountBalance: 1000,
                               username: auth.currentUser.displayName || "Player",
                               email: auth.currentUser.email,
                               createdAt: serverTimestamp(),
                               totalGamesPlayed: 0,
                               totalMoneySpent: 0,
                               totalMoneyEarned: 0,
                               lastActive: serverTimestamp()
                           });
                           return 1000;
                       }
                       
                       // Update last active timestamp
                       transaction.update(userRef, { lastActive: serverTimestamp() });
                       
                       // Return account balance
                       return userDoc.data().accountBalance || 0;
                   });
                   
                   // Update local balance securely (in closure)
                   _coinBalance = newBalance;
                   _lastServerSync = Date.now();
                   
                   // Update UI display without exposing _coinBalance
                   updateDisplayedBalance();
                   
                   return newBalance;
               } catch (error) {
                   console.error("Error in secure balance loading:", error);
                   return 1000; // Default fallback
               }
           };
           
           // Update displayed balance without exposing actual balance
           const updateDisplayedBalance = () => {
               const coinDisplay = document.getElementById('coinDisplay');
               if (coinDisplay) {
                   coinDisplay.textContent = _coinBalance.toLocaleString();
               }
               
               // Also update start button appearance if needed
               updateStartButtonState();
           };
           
           // Update start button state based on selected level and balance
           const updateStartButtonState = () => {
               const startBtn = document.getElementById('start-btn');
               if (!startBtn) return;
               
               // Get the currently selected level
               const selectedLevel = document.querySelector('.level-btn.selected');
               if (!selectedLevel) return;
               
               const level = parseInt(selectedLevel.dataset.level);
               
               // Game configuration is now securely within the closure
               const SECURE_GAME_CONFIG = {
                   levels: {
                       10: { entryFee: 200 },
                       20: { entryFee: 300 },
                       30: { entryFee: 500 }
                   }
               };
               
               const levelConfig = SECURE_GAME_CONFIG.levels[level];
               
               // Update button appearance based on balance
               if (_coinBalance < levelConfig.entryFee) {
                   startBtn.classList.add('insufficient');
               } else {
                   startBtn.classList.remove('insufficient');
               }
           };
           
           // Secure transaction handling
           const secureUpdateCoins = async (amount, reason) => {
               if (!auth.currentUser || _transactionLock) {
                   return false;
               }
               
               // Check for unreasonable amounts (potential hack attempt)
               if (Math.abs(amount) > 1000000 && reason !== 'jackpot') {
                   console.error("Unreasonable transaction amount");
                   recordTamperingAttempt('excessive_transaction');
                   return false;
               }
               
               // Set transaction lock to prevent concurrent updates
               _transactionLock = true;
               
               try {
                   // Generate a transaction security token
                   const transactionToken = await generateSecurityToken(auth.currentUser.uid);
                   
                   // Record transaction timestamp and details for verification
                   const transactionTimestamp = Date.now();
                   const transactionId = `${transactionTimestamp.toString(36)}-${Math.random().toString(36).substr(2, 5)}`;
                   
                   // Track pending transaction
                   _pendingTransactions.push({
                       id: transactionId,
                       amount: amount,
                       reason: reason,
                       timestamp: transactionTimestamp,
                       status: 'pending',
                       token: transactionToken
                   });
                   
                   // Record the action
                   _previousActions.push({
                       type: 'transaction',
                       amount: amount,
                       reason: reason,
                       timestamp: transactionTimestamp
                   });
                   
                   // Perform atomic transaction in Firestore
                   const userRef = doc(db, 'users', auth.currentUser.uid);
                   
                   await runTransaction(db, async (transaction) => {
                       const userDoc = await transaction.get(userRef);
                       
                       if (!userDoc.exists()) {
                           throw new Error("User document does not exist");
                       }
                       
                       const userData = userDoc.data();
                       let currentBalance = userData.accountBalance || 0;
                       let newBalance = currentBalance + amount;
                       
                       // Record stats based on transaction type
                       if (amount > 0 && (reason === 'win' || reason === 'cashout' || reason === 'jackpot')) {
                           // Win transaction
                           transaction.update(userRef, {
                               accountBalance: newBalance,
                               totalMoneyEarned: increment(amount),
                               lastTransaction: serverTimestamp()
                           });
                       } else if (amount < 0 && reason === 'entry_fee') {
                           // Entry fee transaction
                           transaction.update(userRef, {
                               accountBalance: newBalance,
                               totalGamesPlayed: increment(1),
                               totalMoneySpent: increment(Math.abs(amount)),
                               lastTransaction: serverTimestamp()
                           });
                       } else {
                           // Other transactions just update balance
                           transaction.update(userRef, {
                               accountBalance: newBalance,
                               lastTransaction: serverTimestamp()
                           });
                       }
                       
                       // Create transaction record
                       const transactionRef = doc(collection(db, 'transactions'), transactionId);
                       transaction.set(transactionRef, {
                           userId: auth.currentUser.uid,
                           gameId: 'chicken_run_game',
                           transactionType: reason,
                           amount: amount,
                           balanceBefore: currentBalance,
                           balanceAfter: newBalance,
                           timestamp: serverTimestamp(),
                           securityToken: transactionToken,
                           sessionId: _gameSessionId
                       });
                   });
                   
                   // Update local state
                   _coinBalance += amount;
                   _lastServerSync = Date.now();
                   
                   // Update display
                   updateDisplayedBalance();
                   
                   // Update pending transaction status
                   const txIndex = _pendingTransactions.findIndex(tx => tx.id === transactionId);
                   if (txIndex >= 0) {
                       _pendingTransactions[txIndex].status = 'completed';
                   }
                   
                   return true;
               } catch (error) {
                   console.error("Secure transaction failed:", error);
                   return false;
               } finally {
                   // Always release the transaction lock
                   _transactionLock = false;
               }
           };
           
           // Force refresh server data
           const refreshServerData = async () => {
               await loadUserBalance();
           };
           
           // Generate cryptographically secure random value for game logic
           const secureRandom = () => {
               // Use Web Crypto API for true randomness
               const array = new Uint32Array(1);
               window.crypto.getRandomValues(array);
               return array[0] / (0xFFFFFFFF + 1); // Normalize to [0, 1)
           };
           
           // Verify timing to detect speed hacking
           const verifyTiming = (minTime) => {
               // Get the most recent action
               const mostRecentAction = _previousActions.length > 0 ? 
                   _previousActions[_previousActions.length - 1] : 
                   { timestamp: _sessionStartTime };
               
               const now = Date.now();
               const elapsed = now - mostRecentAction.timestamp;
               
               // If actions are happening too quickly, it might be automated
               if (elapsed < minTime) {
                   recordTamperingAttempt('timing_manipulation');
                   return false;
               }
               
               return true;
           };
           
           // Show login prompt if needed
           const showSecureLoginPrompt = () => {
               const overlay = document.createElement('div');
               overlay.style.position = 'fixed';
               overlay.style.top = '0';
               overlay.style.left = '0';
               overlay.style.width = '100%';
               overlay.style.height = '100%';
               overlay.style.background = 'rgba(0,0,0,0.8)';
               overlay.style.display = 'flex';
               overlay.style.justifyContent = 'center';
               overlay.style.alignItems = 'center';
               overlay.style.zIndex = '1000';

               const modalContent = document.createElement('div');
               modalContent.style.background = '#222';
               modalContent.style.padding = '2rem';
               modalContent.style.borderRadius = '10px';
               modalContent.style.textAlign = 'center';
               modalContent.style.color = 'white';

               modalContent.innerHTML = `
                   <h2>Login Required</h2>
                   <p>Please log in to play Chicken Run and track your coins.</p>
                   <div>
                       <button id="loginBtn" style="
                           background: #4CAF50;
                           color: white;
                           border: none;
                           padding: 10px 20px;
                           margin: 10px;
                           border-radius: 5px;
                           cursor: pointer;
                       ">Go to Login</button>
                       <button id="cancelBtn" style="
                           background: #f44336;
                           color: white;
                           border: none;
                           padding: 10px 20px;
                           margin: 10px;
                           border-radius: 5px;
                           cursor: pointer;
                       ">Cancel</button>
                   </div>
               `;

               overlay.appendChild(modalContent);
               document.body.appendChild(overlay);

               // Add event listeners
               document.getElementById('loginBtn').addEventListener('click', () => {
                   window.location.href = '/voidgms.html';
               });

               document.getElementById('cancelBtn').addEventListener('click', () => {
                   document.body.removeChild(overlay);
                   
                   // Set default balance for guest
                   _coinBalance = 1000;
                   updateDisplayedBalance();
               });
           };
           
           // Initialize the secure interface
           const init = async () => {
               if (auth.currentUser) {
                   await initSecurity(auth.currentUser.uid);
                   await loadUserBalance();
               } else {
                   // Default balance for guests
                   _coinBalance = 1000;
                   updateDisplayedBalance();
               }
           };
           
           // Return limited public interface
           return {
               init,
               getCoinBalance: () => _coinBalance,
               updateCoins: secureUpdateCoins,
               showLoginPrompt: showSecureLoginPrompt,
               verifyTiming,
               generateSecureRandom: secureRandom,
               refreshBalance: refreshServerData
           };
       };

       // Create the secure game interface
       const secureGameInterface = createSecureGameInterface();

       // Authentication State Listener
       onAuthStateChanged(auth, async (user) => {
           if (user) {
               // User is signed in
               console.log("User signed in");
               await secureGameInterface.init();
           } else {
               // No user is signed in
               console.log("No user signed in, using guest mode");
               secureGameInterface.showLoginPrompt();
           }
       });
       
       // Create the secure game engine
       const createSecureGameEngine = (secureInterface) => {
           // Game configuration - frozen to prevent modification
           const GAME_CONFIG = Object.freeze({
               gameId: 'chicken_run_game',
               levels: Object.freeze({
                   10: Object.freeze({
                       maxSteps: 10,
                       earnPerStep: 100,
                       endReward: 1000000,
                       deathPenalty: 200,
                       initialSuccessRate: 0.85,
                       finalSuccessRate: 0.65,
                       difficultyIncreasePoint: 0.40,
                       entryFee: 200
                   }),
                   20: Object.freeze({
                       maxSteps: 20,
                       earnPerStep: 200,
                       endReward: 2000000,
                       deathPenalty: 400,
                       initialSuccessRate: 0.87,
                       finalSuccessRate: 0.60,
                       difficultyIncreasePoint: 0.35,
                       entryFee: 300
                   }),
                   30: Object.freeze({
                       maxSteps: 30,
                       earnPerStep: 300,
                       endReward: 3000000,
                       deathPenalty: 600,
                       initialSuccessRate: 0.90,
                       finalSuccessRate: 0.55,
                       difficultyIncreasePoint: 0.30,
                       entryFee: 500
                   })
               }),
               selectedLevel: 10
           });
           
           // Private game state
           let _canvas, _ctx;
           let _canvasWidth, _canvasHeight;
           let _animationFrame;
           let _gameActive = false;
           let _currentPosition = -1;
           let _currentEarnings = 0;
           let _animationInProgress = false;
           let _levelButtons = {};
           let _circles = [];
           let _gameStateHistory = [];
           let _moveTimestamps = [];
           let _gameStartTime = 0;
           let _lastMoveTime = 0;
           
           // DOM elements - will be initialized after DOM is loaded
           let _coinDisplay;
           let _startScreen;
           let _resultScreen;
           let _startBtn;
           let _playAgainBtn;
           let _backBtn;
           let _cashoutBtn;
           let _chickenRunContainer;
           let _gameInfo;
           let _chicken;
           let _bloodSplatter;
           let _chickenPath;
           let _currentEarningDisplay;
           let _resultTitle;
           let _resultMessage;
           
           // Initialize DOM elements securely
           const initDomElements = () => {
               _coinDisplay = document.getElementById('coinDisplay');
               _startScreen = document.getElementById('start-screen');
               _resultScreen = document.getElementById('result-screen');
               _startBtn = document.getElementById('start-btn');
               _playAgainBtn = document.getElementById('play-again-btn');
               _backBtn = document.getElementById('back-btn');
               _cashoutBtn = document.getElementById('cashout-btn');
               _chickenRunContainer = document.getElementById('chicken-run-container');
               _gameInfo = document.getElementById('game-info');
               _chicken = document.getElementById('chicken');
               _bloodSplatter = document.getElementById('blood-splatter');
               _chickenPath = document.getElementById('chicken-path');
               _currentEarningDisplay = document.getElementById('current-earning');
               _resultTitle = document.getElementById('result-title');
               _resultMessage = document.getElementById('result-message');
               
               // Initialize level buttons
               _levelButtons = {
                   10: document.getElementById('level-10'),
                   20: document.getElementById('level-20'),
                   30: document.getElementById('level-30')
               };
           };
           
           // Update current earnings display
           const updateCurrentEarnings = () => {
               if (_currentEarningDisplay) {
                   _currentEarningDisplay.textContent = `Current: ${_currentEarnings.toLocaleString()} coins`;
               }
           };
           
           // Helper function to clear all timeouts
           const clearAllTimeouts = () => {
               // Create a very large number (bigger than any reasonable timeout id)
               const highestTimeoutId = setTimeout(() => {}, 0);
               
               // Clear all timeout IDs from 0 to the highest one
               for (let i = 0; i < highestTimeoutId; i++) {
                   clearTimeout(i);
               }
           };
           
           // Initialize canvas securely
           const initCanvas = () => {
               _canvas = document.getElementById('game-canvas');
               if (!_canvas) {
                   console.error("Canvas element not found!");
                   return false;
               }

               _ctx = _canvas.getContext('2d');

               const gameBoard = document.querySelector('.game-board');
               if (!gameBoard) {
                   console.error("Game board element not found!");
                   return false;
               }

               // Get actual dimensions of the game board
               _canvasWidth = gameBoard.clientWidth;
               _canvasHeight = gameBoard.clientHeight;

               // Set canvas dimensions
               _canvas.width = _canvasWidth;
               _canvas.height = _canvasHeight;
               _canvas.style.width = _canvasWidth + "px";
               _canvas.style.height = _canvasHeight + "px";
               
               return true;
           };
           
           // Create circles for the chicken path with secure positioning
           const createCircles = () => {
               // Clear previous circles
               _chickenPath.innerHTML = '';
               
               // Add chicken and blood splatter back
               _chickenPath.appendChild(_chicken);
               _chickenPath.appendChild(_bloodSplatter);
               
               _circles = [];
               
               const currentLevelConfig = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel];
               const maxSteps = currentLevelConfig.maxSteps;
               
               // Adjust path height based on number of circles
               if (maxSteps > 10) {
                   _chickenPath.style.height = maxSteps > 20 ? '200px' : '170px';
               } else {
                   _chickenPath.style.height = '150px';
               }
               
               // Calculate padding for the first circle
               const leftPadding = 5; // 5% left padding
               const rightPadding = 5; // 5% right padding
               const usableWidth = 100 - leftPadding - rightPadding;
               
               // Create lines and circles
               for (let i = 0; i < maxSteps; i++) {
                   // Create circle
                   const circle = document.createElement('div');
                   circle.className = 'path-circle';
                   circle.dataset.position = i;
                   circle.textContent = i + 1;
                   
                   // Calculate left position with improved spacing
                   let leftPos;
                   if (maxSteps <= 10) {
                       // For 10 circles, use full width with padding
                       leftPos = leftPadding + (i * (usableWidth / (maxSteps - 1)));
                   } else {
                       // For 20 and 30 circles, calculate position differently
                       // We'll only show 10 circles at a time
                       const circleGroup = Math.floor(i / 10);
                       const posInGroup = i % 10;
                       
                       // Position within the current group of 10
                       if (posInGroup === 0) {
                           // Make first circle of each group more accessible
                           leftPos = leftPadding;
                       } else {
                           leftPos = leftPadding + (posInGroup * (usableWidth / 9));
                       }
                       
                       // Hide circles that are not in the current visible group
                       if (circleGroup > 0) {
                           circle.style.display = 'none';
                           circle.dataset.group = circleGroup;
                       }
                   }
                   
                   circle.style.position = 'absolute';
                   circle.style.left = `${leftPos}%`;
                   
                   // Add a z-index to ensure circles are clickable
                   circle.style.zIndex = 10;
                   
                   // Make circle slightly larger for better clickability
                   if (maxSteps > 10) {
                       circle.style.width = '45px';
                       circle.style.height = '45px';
                   }
                   
                   // Add click handler with secure context
                   circle.addEventListener('click', (e) => secureHandleCircleClick(e));
                   
                   _chickenPath.appendChild(circle);
                   _circles.push(circle);
                   
                   // Create connecting line (except for last circle)
                   if (i < maxSteps - 1 && (maxSteps <= 10 || i % 10 < 9)) {
                       const line = document.createElement('div');
                       line.className = 'path-line';
                       _chickenPath.appendChild(line);
                   }
               }
               
               // Add group indicator for games with more than 10 circles
               if (maxSteps > 10) {
                   const groupIndicator = document.createElement('div');
                   groupIndicator.id = 'group-indicator';
                   groupIndicator.className = 'game-info';
                   groupIndicator.style.position = 'absolute';
                   groupIndicator.style.bottom = '-40px';
                   groupIndicator.style.left = '50%';
                   groupIndicator.style.transform = 'translateX(-50%)';
                   groupIndicator.style.padding = '5px 15px';
                   groupIndicator.style.fontSize = '0.9rem';
                   groupIndicator.textContent = 'Group 1 of ' + Math.ceil(maxSteps / 10);
                   _chickenPath.appendChild(groupIndicator);
               }
           };
           
           // Calculate success rate securely with tamper protection
           const calculateSuccessRate = (position) => {
               const levelConfig = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel];
               const maxSteps = levelConfig.maxSteps;
               const initialRate = levelConfig.initialSuccessRate;
               const finalRate = levelConfig.finalSuccessRate;
               const difficultyIncreasePoint = levelConfig.difficultyIncreasePoint;
               
               // Validate position is within expected range
               if (position < 0 || position >= maxSteps) {
                   console.error("Invalid position in success rate calculation");
                   return 0; // Force failure if data is invalid
               }
               
               // If we're before the difficulty increase point, return the initial rate
               if (position < maxSteps * difficultyIncreasePoint) {
                   return initialRate;
               }
               
               // Calculate how far into the difficulty zone we are
               const progressAfterDifficulty = (position - maxSteps * difficultyIncreasePoint) / 
                                             (maxSteps * (1 - difficultyIncreasePoint));
               
               // Linear interpolation between initial and final rates
               return initialRate - progressAfterDifficulty * (initialRate - finalRate);
           };
           
           // Handle circle click with security checks
           const secureHandleCircleClick = (event) => {
               const clickedPosition = parseInt(event.target.dataset.position);
               
               // Verify this is a valid next position
               if (clickedPosition !== _currentPosition + 1 || _animationInProgress) {
                   return;
               }
               
               // Verify timing to prevent automated clicking
               if (!secureInterface.verifyTiming(300)) {
                   console.warn("Click timing manipulation detected");
                   return;
               }
               
               // Set animation flag
               _animationInProgress = true;
               
               // Record move timestamp for pattern analysis
               _moveTimestamps.push(Date.now());
               
               // Store current state for verification
               const preMoveState = {
                   position: _currentPosition,
                   earnings: _currentEarnings,
                   timestamp: Date.now()
               };
               _gameStateHistory.push(preMoveState);
               
               // Calculate current success rate based on position
               const currentSuccessRate = calculateSuccessRate(clickedPosition);
               
               // Use cryptographically secure random for gameplay decisions
               const randomValue = secureInterface.generateSecureRandom();
               const isSuccessful = randomValue < currentSuccessRate;
               
               const levelConfig = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel];
               
               if (isSuccessful) {
                   // Move successful
                   moveChicken(clickedPosition);
                   
                   // Update current position with validation
                   if (clickedPosition !== _currentPosition + 1) {
                       console.error("Position inconsistency detected");
                       endGame(true);
                       return;
                   }
                   _currentPosition = clickedPosition;
                   
                   // Update earnings
                   _currentEarnings += levelConfig.earnPerStep;
                   updateCurrentEarnings();
                   
                   // Mark circle as active
                   for (let i = 0; i < _circles.length; i++) {
                       if (i === clickedPosition) {
                           _circles[i].classList.add('active');
                       } else {
                           _circles[i].classList.remove('active');
                       }
                   }
                   
                   // For games with more than 10 circles, handle circle group visibility
                   if (levelConfig.maxSteps > 10) {
                       // Check if we need to show the next group of circles
                       const currentGroup = Math.floor(clickedPosition / 10);
                       const nextGroup = Math.floor((clickedPosition + 1) / 10);
                       
                       // If moving to next group, update visibility
                       if (nextGroup > currentGroup) {
                           // Hide current group
                           _circles.forEach((circle, index) => {
                               if (Math.floor(index / 10) === currentGroup) {
                                   circle.style.display = 'none';
                               }
                               
                               // Show next group
                               if (Math.floor(index / 10) === nextGroup) {
                                   circle.style.display = '';
                               }
                           });
                           
                           // Update group indicator
                           const groupIndicator = document.getElementById('group-indicator');
                           if (groupIndicator) {
                               groupIndicator.textContent = `Group ${nextGroup + 1} of ${Math.ceil(levelConfig.maxSteps / 10)}`;
                           }
                       }
                   }
                   
                   // Detect suspicious patterns in moves
                   if (_moveTimestamps.length >= 5) {
                       detectSuspiciousPatterns();
                   }
                   
                   // Check if reached the end
                   if (clickedPosition === levelConfig.maxSteps - 1) {
                       // Player reached the end!
                       setTimeout(() => {
                           // Verify game integrity before awarding jackpot
                           if (verifyGameIntegrity()) {
                               // Set earnings to the end reward
                               _currentEarnings = levelConfig.endReward;
                               
                               // Show victory screen
                               showVictoryScreen();
                               
                               // Award jackpot
                               secureInterface.updateCoins(levelConfig.endReward, 'jackpot');
                           } else {
                               // Integrity check failed - forfeit win
                               endGame(true);
                           }
                           
                           // Reset animation flag
                           _animationInProgress = false;
                       }, 500);
                   } else {
                       // Enable cashout button after first successful move
                       if (_cashoutBtn) {
                           _cashoutBtn.disabled = false;
                       }
                       
                       // Update game info without showing the exact percentage
                       if (_gameInfo) {
                           // Determine how far along they are to provide hint about risk
                           const progressPercentage = (clickedPosition + 1) / levelConfig.maxSteps;
                           let riskLevel = "low";
                           
                           if (progressPercentage > 0.7) {
                               riskLevel = "high";
                           } else if (progressPercentage > 0.4) {
                               riskLevel = "moderate";
                           }
                           
                           _gameInfo.textContent = `Success! Move to the next circle or cash out now with ${_currentEarnings.toLocaleString()} coins. Risk level: ${riskLevel}`;
                       }
                       
                       // Reset animation flag
                       _animationInProgress = false;
                       _lastMoveTime = Date.now();
                   }
               } else {
                   // Move failed - chicken dies!
                   killChicken(clickedPosition);
                   
                   // Deduct coins for dying - after validation
                   if (verifyGameIntegrity()) {
                       secureInterface.updateCoins(-levelConfig.deathPenalty, 'death_penalty');
                   }
                   
                   // Update game info
                   if (_gameInfo) {
                       _gameInfo.textContent = `Oh no! The chicken didn't make it... You lost ${levelConfig.deathPenalty} coins!`;
                   }
                   
                   // Show death screen after animation
                   setTimeout(() => {
                       showDeathScreen();
                       _animationInProgress = false;
                   }, 1000);
               }
           };
           
           // Detect suspicious patterns in move timestamps
           const detectSuspiciousPatterns = () => {
               // Check for too-regular timing between clicks (automated play)
               if (_moveTimestamps.length < 5) return;
               
               // Calculate time differences between clicks
               const timeDiffs = [];
               for (let i = 1; i < _moveTimestamps.length; i++) {
                   timeDiffs.push(_moveTimestamps[i] - _moveTimestamps[i-1]);
               }
               
               // Check if timing is suspiciously consistent (bot detection)
               let suspiciouslyConsistent = true;
               const firstDiff = timeDiffs[0];
               
               for (let diff of timeDiffs) {
                   // Allow 100ms variance
                   if (Math.abs(diff - firstDiff) > 100) {
                       suspiciouslyConsistent = false;
                       break;
                   }
               }
               
               if (suspiciouslyConsistent) {
                   console.warn("Suspicious click pattern detected");
                   endGame(true);
                   return;
               }
               
               // Check for impossibly fast clicks
               const minDiff = Math.min(...timeDiffs);
               if (minDiff < 200) {
                   console.warn("Impossibly fast clicks detected");
                   endGame(true);
               }
           };
           
           // Verify game integrity before awarding prizes
           const verifyGameIntegrity = () => {
               // Check if game state history is consistent
               if (_gameStateHistory.length < 2) return true;
               
               for (let i = 1; i < _gameStateHistory.length; i++) {
                   const prevState = _gameStateHistory[i-1];
                   const currState = _gameStateHistory[i];
                   
                   // Position should increment by exactly 1
                   if (currState.position !== prevState.position + 1) {
                       console.warn("Position inconsistency detected");
                       return false;
                   }
                   
                   // Earnings should increase by the correct amount per step
                   const levelConfig = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel];
                   const expectedEarnings = prevState.earnings + levelConfig.earnPerStep;
                   
                   if (currState.earnings !== expectedEarnings) {
                       console.warn("Earnings inconsistency detected");
                       return false;
                   }
                   
                   // Check for suspicious timing
                   const timeDiff = currState.timestamp - prevState.timestamp;
                   if (timeDiff < 200) {
                       console.warn("Suspicious timing between moves");
                       return false;
                   }
               }
               
               return true;
           };
           
           // Move chicken to the specified position
           const moveChicken = (position) => {
               if (!_chicken) return;
               
               const maxSteps = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel].maxSteps;
               const currentGroup = Math.floor(position / 10);
               const posInGroup = position % 10;
               
               // Calculate new left position based on the circle's position
               let leftPos;
               
               if (maxSteps <= 10) {
                   // For 10 circles, use previous calculation
                   const leftPadding = 5;
                   const usableWidth = 90;
                   leftPos = leftPadding + (position * (usableWidth / (maxSteps - 1)));
               } else {
                   // For more than 10 circles, position within current group
                   const leftPadding = 5;
                   const usableWidth = 90;
                   
                   if (posInGroup === 0) {
                       leftPos = leftPadding;
                   } else {
                       leftPos = leftPadding + (posInGroup * (usableWidth / 9));
                   }
               }
               
               _chicken.style.left = `${leftPos}%`;
           };
           
           // Kill the chicken at the specified position
           const killChicken = (position) => {
               if (!_chicken || !_bloodSplatter) return;
               
               const maxSteps = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel].maxSteps;
               const currentGroup = Math.floor(position / 10);
               const posInGroup = position % 10;
               
               // Calculate position for death animation
               let leftPos;
               
               if (maxSteps <= 10) {
                   // For 10 circles, use previous calculation with padding
                   const leftPadding = 5;
                   const usableWidth = 90;
                   leftPos = leftPadding + (position * (usableWidth / (maxSteps - 1)));
               } else {
                   // For more than 10 circles, position within current group
                   const leftPadding = 5;
                   const usableWidth = 90;
                   
                   if (posInGroup === 0) {
                       leftPos = leftPadding;
                   } else {
                       leftPos = leftPadding + (posInGroup * (usableWidth / 9));
                   }
               }
               
               // Move chicken to the position
               _chicken.style.left = `${leftPos}%`;
               
               // Add death class
               _chicken.classList.add('chicken-dead');
               
               // Position and show blood splatter
               _bloodSplatter.style.left = `${leftPos}%`;
               _bloodSplatter.style.top = '50%';
               _bloodSplatter.classList.add('active');
               
               // Mark circle as danger
               if (_circles[position]) {
                   _circles[position].classList.add('danger');
               }
           };
           
           // Cash out the current earnings
           const secureCashout = async () => {
               if (_currentEarnings <= 0 || !_gameActive || _animationInProgress) {
                   return;
               }
               
               // Verify game integrity before paying out
               if (!verifyGameIntegrity()) {
                   console.warn("Game integrity check failed during cashout");
                   endGame(true);
                   return;
               }
               
               // Set animation flag
               _animationInProgress = true;
               
               // Update game info
               if (_gameInfo) {
                   _gameInfo.textContent = `Cashed out with ${_currentEarnings.toLocaleString()} coins. Well played!`;
               }
               
               // Add earnings to balance
               const success = await secureInterface.updateCoins(_currentEarnings, 'cashout');
               
               if (success) {
                   // Show cashout screen
                   showCashoutScreen();
               } else {
                   // Transaction failed, show error
                   if (_gameInfo) {
                       _gameInfo.textContent = `Error processing cashout. Please try again.`;
                   }
                   _animationInProgress = false;
               }
           };
           
           // Show victory screen
           const showVictoryScreen = () => {
               if (!_resultScreen || !_resultTitle || !_resultMessage) {
                   console.error("Result screen elements not found!");
                   return;
               }
               
               const levelConfig = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel];
               
               // Set the result screen content
               _resultTitle.textContent = "Victory!";
               _resultTitle.className = "overlay-title win";
               
               // Update message
               _resultMessage.innerHTML = `You reached the end!<br>
                   You won the jackpot!<br>
                   You won: <span class="win-amount">${_currentEarnings.toLocaleString()}</span> coins`;
               
               // Make result screen visible
               _resultScreen.style.display = 'flex';
               _resultScreen.classList.add('visible');
               
               // End the game
               _gameActive = false;
           };
           
           // Show death screen
           const showDeathScreen = () => {
               if (!_resultScreen || !_resultTitle || !_resultMessage) {
                   console.error("Result screen elements not found!");
                   return;
               }
               
               const levelConfig = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel];
               
               // Set the result screen content
               _resultTitle.textContent = "Chicken Died!";
               _resultTitle.className = "overlay-title lose";
               
               // Update message
               _resultMessage.innerHTML = `The chicken didn't make it!<br>
                   You made it to position ${_currentPosition + 1} of ${levelConfig.maxSteps}.<br>
                   You lost ${levelConfig.deathPenalty} coins.`;
               
               // Make result screen visible
               _resultScreen.style.display = 'flex';
               _resultScreen.classList.add('visible');
               
               // End the game
               _gameActive = false;
           };
           
           // Show cashout screen
           const showCashoutScreen = () => {
               if (!_resultScreen || !_resultTitle || !_resultMessage) {
                   console.error("Result screen elements not found!");
                   return;
               }
               
               const levelConfig = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel];
               
               // Set the result screen content
               _resultTitle.textContent = "Cashed Out!";
               _resultTitle.className = "overlay-title win";
               
               // Update message
               _resultMessage.innerHTML = `Smart move!<br>
                   You made it to position ${_currentPosition + 1} of ${levelConfig.maxSteps}.<br>
                   You won: <span class="win-amount">${_currentEarnings.toLocaleString()}</span> coins`;
               
               // Make result screen visible
               _resultScreen.style.display = 'flex';
               _resultScreen.classList.add('visible');
               
               // End the game
               _gameActive = false;
           };
           
           // End game with optional forced flag
           const endGame = (forced = false) => {
               _gameActive = false;
               _animationInProgress = false;
               
               if (forced) {
                   // Handle security violation ending
                   if (_resultScreen && _resultTitle && _resultMessage) {
                       _resultTitle.textContent = "Game Error";
                       _resultTitle.className = "overlay-title lose";
                       
                       _resultMessage.innerHTML = `An unexpected error occurred.<br>
                           The game has been terminated for security reasons.<br>
                           Please try again later.`;
                       
                       _resultScreen.style.display = 'flex';
                       _resultScreen.classList.add('visible');
                   }
               }
           };
           
           // Complete game reset
           const resetGame = () => {
               // Reset game state
               _gameActive = false;
               _currentPosition = -1;
               _currentEarnings = 0;
               _animationInProgress = false;
               _moveTimestamps = [];
               _gameStateHistory = [];
               
               // Cancel any animation frames
               if (_animationFrame) {
                   cancelAnimationFrame(_animationFrame);
                   _animationFrame = null;
               }
               
               // Reset displays
               updateCurrentEarnings();
               
               // Hide game elements
               if (_chickenRunContainer) {
                   _chickenRunContainer.style.display = 'none';
               }
               
               // Reset chicken
               if (_chicken) {
                   _chicken.style.left = '10px'; // Starting position
                   _chicken.classList.remove('chicken-dead');
               }
               
               // Reset blood splatter
               if (_bloodSplatter) {
                   _bloodSplatter.classList.remove('active');
               }
               
               // Hide result screen if visible
               if (_resultScreen) {
                   _resultScreen.classList.remove('visible');
               }
               
               // Disable cashout button
               if (_cashoutBtn) {
                   _cashoutBtn.disabled = true;
               }
               
               // Show start screen
               if (_startScreen) {
                   _startScreen.classList.add('visible');
               }
               
               try {
                   // Clear any pending timeouts
                   clearAllTimeouts();
               } catch (e) {
                   console.log("Error clearing timeouts:", e);
               }
           };
           
           // Initialize game with security verification
           const initGame = async () => {
               // Verify timing to prevent rapid game starts
               if (!secureInterface.verifyTiming(1000)) {
                   console.warn("Game started too quickly");
                   return;
               }
               
               // Get current level configuration
               const levelConfig = GAME_CONFIG.levels[GAME_CONFIG.selectedLevel];
               
               // Check if player has enough coins for entry fee
               const playerBalance = secureInterface.getCoinBalance();
               
               if (playerBalance < levelConfig.entryFee) {
                   // Show insufficient funds message
                   if (_gameInfo) {
                       _gameInfo.textContent = `Not enough coins to start the game! You need at least ${levelConfig.entryFee} coins.`;
                   }
                   return;
               }
               
               // Record game start time for timing validation
               _gameStartTime = Date.now();
               _lastMoveTime = _gameStartTime;
               
               // Deduct entry fee with transaction verification
               const deductionSuccess = await secureInterface.updateCoins(-levelConfig.entryFee, 'entry_fee');
               
               if (!deductionSuccess) {
                   console.error("Failed to process entry fee");
                   return;
               }
               
               // Reset for new game
               _gameActive = true;
               _currentPosition = -1;
               _currentEarnings = 0;
               _animationInProgress = false;
               _moveTimestamps = [];
               _gameStateHistory = [];
               
               // Update current earnings display
               updateCurrentEarnings();
               
               // Hide start screen
               _startScreen.classList.remove('visible');
               
               // Create circles based on selected level
               createCircles();
               
               // Show game container
               if (_chickenRunContainer) {
                   _chickenRunContainer.style.display = 'flex';
               }
               
               // Reset chicken to starting position
               if (_chicken) {
                   _chicken.style.left = '10px';
                   _chicken.classList.remove('chicken-dead');
               }
               
               // Reset blood splatter
               if (_bloodSplatter) {
                   _bloodSplatter.classList.remove('active');
               }
               
               // Disable cashout button until first move
               if (_cashoutBtn) {
                   _cashoutBtn.disabled = true;
               }
               
               // Update game info
               if (_gameInfo) {
                   _gameInfo.textContent = `Level: ${GAME_CONFIG.selectedLevel} circles. Each step earns ${levelConfig.earnPerStep} coins. Click the first circle to start!`;
               }
               
               // Start game loop for background effects
               window.cancelAnimationFrame(_animationFrame);
               gameLoop();
           };
           
           // Draw stars in background
           const drawStars = () => {
               if (!_ctx || !_canvas) return;
               
               _ctx.clearRect(0, 0, _canvasWidth, _canvasHeight);
               _ctx.fillStyle = '#FFFFFF';
               
               // Use cryptographically secure seed values to avoid predictable patterns
               const timestamp = Date.now();
               const secureRandomValues = new Uint8Array(100);
               window.crypto.getRandomValues(secureRandomValues);
               
               for (let i = 0; i < 100; i++) {
                   // Create a deterministic but varied star pattern using secure values
                   const x = (_canvasWidth * secureRandomValues[i] / 255) % _canvasWidth;
                   const y = (_canvasHeight * ((secureRandomValues[i] + timestamp) % 255) / 255) % _canvasHeight;
                   
                   // Vary the star sizes
                   const size = (secureRandomValues[i] % 3) + 1;
                   
                   // Make stars twinkle with secure randomness
                   const alpha = 0.3 + 0.7 * Math.sin(timestamp * 0.001 + i);
                   
                   _ctx.globalAlpha = alpha;
                   _ctx.beginPath();
                   _ctx.arc(x, y, size, 0, Math.PI * 2);
                   _ctx.fill();
               }
               
               _ctx.globalAlpha = 1.0;
           };
           
           // Game loop
           const gameLoop = () => {
               // Draw background
               drawStars();
               
               // Continue game loop
               _animationFrame = requestAnimationFrame(gameLoop);
           };
           
           // Set the active level button
           const setActiveLevel = (level) => {
               // Verify level is valid
               const numLevel = parseInt(level);
               if (![10, 20, 30].includes(numLevel)) {
                   console.warn("Invalid level selection");
                   return;
               }
               
               // Update selected level in config
               GAME_CONFIG.selectedLevel = numLevel;
               
               // Update UI to show selected level
               for (const [levelKey, button] of Object.entries(_levelButtons)) {
                   if (parseInt(levelKey) === GAME_CONFIG.selectedLevel) {
                       button.classList.add('selected');
                   } else {
                       button.classList.remove('selected');
                   }
               }
           };
           
           // Setup secure event listeners
           const setupEventListeners = () => {
               // Start button
               if (_startBtn) {
                   _startBtn.addEventListener('click', function() {
                       // Verify timing to prevent automated clicking
                       if (!secureInterface.verifyTiming(500)) return;
                       
                       initGame();
                   });
               }
               
               // Play again button
               if (_playAgainBtn) {
                   _playAgainBtn.addEventListener('click', function() {
                       // Verify timing to prevent automated clicking
                       if (!secureInterface.verifyTiming(500)) return;
                       
                       if (_resultScreen) {
                           _resultScreen.classList.remove('visible');
                           setTimeout(() => {
                               resetGame();
                           }, 300); // Give time for fade-out animation
                       } else {
                           resetGame();
                       }
                   });
               }
               
               // Back button
               if (_backBtn) {
                   _backBtn.addEventListener('click', function() {
                       window.location.href = '/voidgms.html';
                   });
               }
               
               // Cashout button
               if (_cashoutBtn) {
                   _cashoutBtn.addEventListener('click', function() {
                       // Verify timing to prevent automated clicking
                       if (!secureInterface.verifyTiming(500)) return;
                       
                       if (!_cashoutBtn.disabled && _gameActive) {
                           secureCashout();
                       }
                   });
               }
               
               // Level selection buttons
               for (const [level, button] of Object.entries(_levelButtons)) {
                   if (button) {
                       button.addEventListener('click', function() {
                           // Verify timing to prevent automated clicking
                           if (!secureInterface.verifyTiming(300)) return;
                           
                           setActiveLevel(level);
                       });
                   }
               }
               
               // Add resize event listener with rate limiting
               let resizeTimeout;
               window.addEventListener('resize', function() {
                   // Clear previous timeout to avoid multiple handlers
                   clearTimeout(resizeTimeout);
                   
                   // Set new timeout with delay to prevent performance issues
                   resizeTimeout = setTimeout(() => {
                       initCanvas();
                       if (_gameActive) {
                           drawStars();
                       }
                   }, 300);
               });
           };
           
           // Initialize the game
           const init = () => {
               // Initialize DOM elements
               initDomElements();
               
               // Initialize canvas
               initCanvas();
               
               // Setup event listeners
               setupEventListeners();
               
               // Initial reset
               resetGame();
               
               // Start game loop for background animation
               gameLoop();
           };
           
           // Return limited public interface to prevent exposing game internals
           return {
               init,
               resetGame,
               getGameState: () => ({
                   level: GAME_CONFIG.selectedLevel,
                   position: _currentPosition,
                   active: _gameActive
               })
           };
       };
       
       // Initialize game when page loads
       document.addEventListener('DOMContentLoaded', function() {
           // Create the game engine with the secure interface
           const chickenGameEngine = createSecureGameEngine(secureGameInterface);
           
           // Initialize the game
           chickenGameEngine.init();
           
           // Make doubly sure the result screen is initially hidden
           const resultScreen = document.getElementById('result-screen');
           if (resultScreen) {
               resultScreen.classList.remove('visible');
           }
           
           // Add extra protection to prevent console API exposure
           const sensitiveTermRegex = /coinBalance|updateCoins|GAME_CONFIG|secureInterface|balance|hack|cheat/i;
           
           // Monitor console input
           const realConsole = { ...console };
           for (const method of ['log', 'warn', 'error', 'info', 'debug']) {
               console[method] = function(...args) {
                   // Check for sensitive information
                   const input = args.join(' ');
                   if (sensitiveTermRegex.test(input)) {
                       // Send alert to security monitoring (silently)
                       try {
                           const securityRef = doc(collection(db, 'security_events'));
                           setDoc(securityRef, {
                               type: 'console_abuse',
                               content: input.substring(0, 100), // Limit content length
                               timestamp: serverTimestamp(),
                               userAgent: navigator.userAgent,
                               page: 'chicken_run'
                           });
                       } catch (e) {} // Silent catch
                   }
                   // Still call original method to avoid detection
                   return realConsole[method](...args);
               };
           }
       });
   </script>
</body>
</html>
