<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Void Network Admin Console</title>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            padding: 20px;
            margin: 0;
        }
        #terminal {
            width: 100%;
            height: 80vh;
            background-color: #111;
            border: 1px solid #0f0;
            padding: 10px;
            overflow-y: auto;
            white-space: pre-wrap;
            box-sizing: border-box;
        }
        #commandInput {
            width: 100%;
            background-color: #111;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            box-sizing: border-box;
        }
        .success {
            color: #0f0;
        }
        .error {
            color: #f00;
        }
        .info {
            color: #0ff;
        }
        .warning {
            color: #ff0;
        }
        #loginForm {
            background-color: #111;
            border: 1px solid #0f0;
            padding: 20px;
            margin: 20px auto;
            max-width: 400px;
            text-align: center;
        }
        input[type="email"], input[type="password"] {
            width: 100%;
            background-color: #111;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            box-sizing: border-box;
        }
        button {
            background-color: #111;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            margin-top: 10px;
            font-family: monospace;
            cursor: pointer;
        }
        button:hover {
            background-color: #0f0;
            color: #111;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loginForm">
        <h2>Void Network Admin Login</h2>
        <input type="email" id="emailInput" placeholder="Email" autofocus>
        <input type="password" id="passwordInput" placeholder="Password">
        <button id="loginButton">Login</button>
        <div id="loginMessage" class="error hidden"></div>
    </div>

    <div id="adminConsole" class="hidden">
        <div id="terminal"></div>
        <input type="text" id="commandInput" placeholder="Enter command...">
    </div>
    
    <script type="module">
        // Anti-debugging and anti-tampering measures
        (function() {
            // Prevent debugging
            const originalConsole = window.console;
            const bannedMethods = ['log', 'debug', 'info', 'warn', 'error', 'table', 'trace', 'dir', 'dirxml'];
            
            // Track debug attempts
            let debugAttempts = 0;
            const maxDebugAttempts = 5;
            let lastDebugTime = 0;
            
            const monitorDebugAttempts = () => {
                const now = Date.now();
                // Reset counter if more than 10 seconds have passed
                if (now - lastDebugTime > 10000) {
                    debugAttempts = 0;
                }
                
                lastDebugTime = now;
                debugAttempts++;
                
                if (debugAttempts >= maxDebugAttempts) {
                    // Too many debug attempts detected
                    document.body.innerHTML = '<h1 style="color: red">Security violation detected</h1>';
                    setTimeout(() => { window.location.href = "about:blank"; }, 3000);
                }
            };
            
            // Disable console in production (keeping it commented for now for development)
            /* 
            bannedMethods.forEach(method => {
                window.console[method] = function() {
                    monitorDebugAttempts();
                    // Silent fail or redirect
                    return undefined;
                };
            });
            */
            
            // Anti-user modification - detect changes to our security code
            const securityHash = "secure_hash_" + Math.random().toString(36).substring(2); // Placeholder
            window._securityToken = securityHash;
            
            // Create a hidden verification function with obfuscated name
            window["__v" + securityHash.substring(0, 8)] = function() {
                return window._securityToken === securityHash;
            };
            
            // Monitor for modifications
            setInterval(() => {
                const verifyFn = window["__v" + securityHash.substring(0, 8)];
                if (!verifyFn || !verifyFn() || window._securityToken !== securityHash) {
                    // Code has been tampered with
                    document.body.innerHTML = '<h1 style="color: red">Security violation: Page has been tampered with</h1>';
                    setTimeout(() => { window.location.href = "about:blank"; }, 3000);
                }
            }, 2000);
            
            // Prevent view-source
            window.addEventListener("keydown", function(e) {
                // Block F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
                if (
                    e.keyCode === 123 || 
                    (e.ctrlKey && e.shiftKey && (e.keyCode === 73 || e.keyCode === 74)) || 
                    (e.ctrlKey && e.keyCode === 85)
                ) {
                    monitorDebugAttempts();
                    e.preventDefault();
                    return false;
                }
            });
            
            // Detect Devtools
            function isDevToolsOpen() {
                const threshold = 160;
                const widthThreshold = window.outerWidth - window.innerWidth > threshold;
                const heightThreshold = window.outerHeight - window.innerHeight > threshold;
                
                if (widthThreshold || heightThreshold) {
                    monitorDebugAttempts();
                    return true;
                }
                return false;
            }
            
            // Check periodically
            setInterval(isDevToolsOpen, 1000);
            
            // Prevent right-click
            document.addEventListener('contextmenu', function(e) {
                monitorDebugAttempts();
                e.preventDefault();
                return false;
            });
            
            // Check if script has been modified by comparing execution time
            const startTime = new Date().getTime();
            setTimeout(function() {
                const endTime = new Date().getTime();
                const executionTime = endTime - startTime;
                
                // If execution takes much longer than expected, debugger might be paused
                if (executionTime > 50) { // 50ms should be enough for this simple timeout
                    monitorDebugAttempts();
                }
            }, 1);
        })();
        
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
        import { getFirestore, collection, doc, getDoc, getDocs, updateDoc, setDoc, query, limit, where, deleteDoc, orderBy, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore.js";

        // Firebase Configuration - Obfuscated
        const _0xb431 = ['AIzaSyCkAp_GCGCtw4zv7GgHJOE9GPgIaPEuOvQ','void-games-c8d9e.firebaseapp.com','void-games-c8d9e','void-games-c8d9e.firebasestorage.app','1063089929776','1:1063089929776:web:8e226a23a4f3ab9c5777f5'];
        const firebaseConfig = {
            apiKey: _0xb431[0],
            authDomain: _0xb431[1],
            projectId: _0xb431[2],
            storageBucket: _0xb431[3],
            messagingSenderId: _0xb431[4],
            appId: _0xb431[5]
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Secure admin email verification
        // IMPORTANT: This variable is protected against tampering
        let _adminEmail = null;
        
        // Define the admin email in a way that's harder to tamper with
        Object.defineProperty(window, '_voidAdminUser', {
            get: function() {
                if (!_adminEmail) {
                    // Construct email from pieces to avoid easy search/replace
                    const domain = 'yandex.com';
                    const parts = ['v', 'o', 'i', 'd', '.', 'c', 'l', 'i', 'e', 'n', 't'];
                    _adminEmail = parts.join('') + '@' + domain;
                }
                return _adminEmail;
            },
            configurable: false,
            enumerable: false
        });
        
        let securityAccessToken = "";
        let sessionStartTime = 0;
        const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
        
        // DOM Elements
        const loginForm = document.getElementById('loginForm');
        const emailInput = document.getElementById('emailInput');
        const passwordInput = document.getElementById('passwordInput');
        const loginButton = document.getElementById('loginButton');
        const loginMessage = document.getElementById('loginMessage');
        const adminConsole = document.getElementById('adminConsole');
        const terminal = document.getElementById('terminal');
        const commandInput = document.getElementById('commandInput');
        
        // Hardcoded known user IDs from Firebase Auth UI - with corrected spelling
        // Adding your new UID to the list
        const KNOWN_USERS = {
            "KIsAtjOwRpdVDOL3VPrDBACSxdw1": "six7588@gmail.com",
            "GU9JmuJistfcjKLwtJLmj5BELHs2": "nigatikler@gmail.com",
            "mtl6j5MsEwYhfVfT1yw9JmrSfMV2": "1q2w3e4r5t6y7u8i9o0p@gmail.com",
            "ku8A1MuC6jWJxEnPIb9nYCY2MnH2": "mjbalkovski@gmail.com",
            "Ga450aQRGGMqUOgFVGs62fRnZ6l1": "svalenciarivera@isdkids.org",
            "3qJsAc8TsbZzx0SZdfduH7ijLuP2": "dfsgdsgr@gamil.comsd",
            "dcxtOHGcfrQ12XBrSz04MhQzEbq1": "shrey436@proton.me",
            "44b4NFWyEnSPhCsofxMkbkIP1vt1": "gvrelectrodude@gmail.com",
            "Wtc6hcUIzmORUJxJFc5nJVPgjRE2": "shrey150436@gmail.com",
            "QC8YOG6kCNZTg5QMyIHnXZoJ0cH2": "unknown@example.com",
            "mVXU2RP0DcMktvrK55qBM2fnMGq2": "six7588@gmail.com",
            "umhru1hzQJZa4db0WKHgDtp2qLc2": "six7588@gmail.com",
            "uEAVXhBHdAewP77mNVkEzsGSO0J3": "void.client@yandex.com" // Added new UID with new admin email
        };
        
        // Add any possible spelling variations
        const EMAIL_VARIATIONS = {
            "mjbalkovsk@gmail.com": "mjbalkovski@gmail.com"
        };
        
        // Reverse lookup for emails to IDs (for display only)
        const EMAIL_TO_ID = {};
        for (const [id, email] of Object.entries(KNOWN_USERS)) {
            EMAIL_TO_ID[email.toLowerCase()] = id;
        }
        
        // Add variations to lookup
        for (const [variation, original] of Object.entries(EMAIL_VARIATIONS)) {
            if (EMAIL_TO_ID[original.toLowerCase()]) {
                EMAIL_TO_ID[variation.toLowerCase()] = EMAIL_TO_ID[original.toLowerCase()];
            }
        }
        
        // Cache of username data and info
        const userDataCache = {};
        const usernameToIDMap = new Map();
        
        // Terminal output functions
        function printToTerminal(message, className = '') {
            const line = document.createElement('div');
            line.textContent = message;
            if (className) line.className = className;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        function printSuccess(message) {
            printToTerminal(message, 'success');
        }
        
        function printError(message) {
            printToTerminal(message, 'error');
        }
        
        function printInfo(message) {
            printToTerminal(message, 'info');
        }
        
        function printWarning(message) {
            printToTerminal(message, 'warning');
        }
        
        // Initialize admin console
        async function initConsole(userEmail, userId) {
            printToTerminal('Void Network Admin Console v2.0');
            printToTerminal('----------------------------------');
            printToTerminal('Available commands:');
            printToTerminal('help - Show available commands');
            printToTerminal('list users - List all known users');
            printToTerminal('<user ID> - Look up user by ID');
            printToTerminal('<email> - Look up user by email');
            printToTerminal('<username> - Look up user by username');
            printToTerminal('<user ID/email> coin amount - Check coins');
            printToTerminal('<user ID/email> add coins <amount> - Add coins');
            printToTerminal('<user ID/email> remove coins <amount> - Remove coins');
            printToTerminal('kick <email> - Delete account and user data');
            printToTerminal('/maxcoins - Show top 3 users with most coins');
            printToTerminal('search <query> - Search for users by partial username');
            printToTerminal('refresh users - Check for new users and update database');
            printToTerminal('refresh cache - Force reload all user data');
            printToTerminal('----------------------------------');
            printSuccess(`Authenticated as admin: ${userEmail}`);
            printInfo(`Your user ID: ${userId}`);
            printInfo(`Session expires in: 30 minutes`);
            printInfo('Ready for commands.');
            
            // Start session timeout
            sessionStartTime = Date.now();
            startSessionTimer();
            
            // Force full database load on startup
            await forceFullDatabaseLoad();
        }
        
        // Session timeout management
        function startSessionTimer() {
            // Check session timeout every minute
            const interval = setInterval(() => {
                const elapsedTime = Date.now() - sessionStartTime;
                const remainingMinutes = Math.ceil((SESSION_TIMEOUT - elapsedTime) / 60000);
                
                if (elapsedTime >= SESSION_TIMEOUT) {
                    clearInterval(interval);
                    printWarning("Session expired. Please login again.");
                    logoutUser();
                } else if (remainingMinutes <= 5) {
                    // Warning when 5 minutes or less remaining
                    printWarning(`Session expires in ${remainingMinutes} minute(s). Please save your work.`);
                }
            }, 60000);
            
            // Store the interval ID so we can clear it on logout
            window._sessionTimerInterval = interval;
        }
        
        async function logoutUser() {
            try {
                // Clear the session timer
                if (window._sessionTimerInterval) {
                    clearInterval(window._sessionTimerInterval);
                }
                
                // Reset security token
                securityAccessToken = "";
                
                // Hide admin console, show login form
                adminConsole.classList.add('hidden');
                loginForm.classList.remove('hidden');
                
                // Clear terminal
                terminal.innerHTML = '';
                
                // Sign out from Firebase Auth
                await signOut(auth);
                
                // Clear sensitive data
                Object.keys(userDataCache).forEach(key => delete userDataCache[key]);
                usernameToIDMap.clear();
                
                printSuccess("You have been logged out successfully.");
            } catch (error) {
                console.error("Logout error:", error);
            }
        }
        
        // Login button event
        loginButton.addEventListener('click', async () => {
            await attemptLogin();
        });
        
        // Secure login function
        async function attemptLogin() {
            const email = emailInput.value.trim();
            const password = passwordInput.value;
            
            if (!email || !password) {
                showLoginMessage('Please enter both email and password', true);
                return;
            }
            
            try {
                showLoginMessage('Authenticating...', false);
                
                // Try to sign in with Firebase Authentication
                await signInWithEmailAndPassword(auth, email, password);
                // Auth state change will be handled by onAuthStateChanged
                
            } catch (error) {
                console.error("Login error:", error);
                
                // Add delays to prevent brute force
                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));
                
                // Provide generic error message for security
                showLoginMessage(`Login failed: Invalid credentials`, true);
            }
        }
        
        // Show login message
        function showLoginMessage(message, isError) {
            loginMessage.textContent = message;
            loginMessage.className = isError ? 'error' : 'info';
            loginMessage.classList.remove('hidden');
        }
        
        // Handle authentication state changes
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                // Check if user email matches the admin email - using the protected getter
                if (user.email.toLowerCase() !== window._voidAdminUser.toLowerCase()) {
                    showLoginMessage('Access denied: Only ADMIN can access this console', true);
                    await signOut(auth);
                    return;
                }
                
                // Additional verification: Check if user ID is in the known users list
                if (!Object.keys(KNOWN_USERS).includes(user.uid)) {
                    // Log the unknown ID but don't expose it in the UI for security
                    console.error("Unknown UID attempted login:", user.uid);
                    showLoginMessage('Access denied: Your account is not authorized', true);
                    await signOut(auth);
                    return;
                }
                
                try {
                    // Generate a simple security token for this session
                    securityAccessToken = "secure_" + Date.now() + "_" + Math.random().toString(36).substring(2);
                    
                    // Show admin console
                    loginForm.classList.add('hidden');
                    adminConsole.classList.remove('hidden');
                    
                    // Initialize the admin console
                    await initConsole(user.email, user.uid);
                } catch (error) {
                    console.error("Login error:", error);
                    showLoginMessage('Error initializing session. Please try again.', true);
                    await signOut(auth);
                }
            }
        });
        
        // Function to refresh user data - With additional security checks
        async function refreshUserData() {
            printInfo("Refreshing user data...");
            
            if (!securityAccessToken || !auth.currentUser) {
                printError("Security validation failed. Please login again.");
                await logoutUser();
                return;
            }
            
            // Verify again that the current user is still the admin
            if (auth.currentUser.email.toLowerCase() !== window._voidAdminUser.toLowerCase()) {
                printError("Security violation detected: User is not authorized.");
                await logoutUser();
                return;
            }
            
            try {
                // Check each known user and create documents if needed
                let created = 0;
                let updated = 0;
                
                // Security check: verify the session before proceeding
                if (Date.now() - sessionStartTime > SESSION_TIMEOUT) {
                    printError("Session expired. Please login again.");
                    await logoutUser();
                    return;
                }
                
                for (const [userId, email] of Object.entries(KNOWN_USERS)) {
                    try {
                        const userRef = doc(db, 'users', userId);
                        const userDoc = await getDoc(userRef);
                        
                        if (!userDoc.exists()) {
                            // Create a new user document
                            await setDoc(userRef, {
                                email: email,
                                accountBalance: 0,
                                createdAt: serverTimestamp(),
                                totalGamesPlayed: 0,
                                totalMoneyEarned: 0,
                                totalMoneySpent: 0
                            });
                            
                            created++;
                            printInfo(`Created user document for ${email} (${userId})`);
                        } else {
                            // Make sure the email field is up to date
                            const userData = userDoc.data();
                            if (!userData.email) {
                                await updateDoc(userRef, { email: email });
                                updated++;
                            }
                        }
                        
                        // Update the cache
                        const updatedUserDoc = await getDoc(userRef);
                        userDataCache[userId] = updatedUserDoc.data();
                        
                        // Map username if available
                        if (userDataCache[userId].username) {
                            usernameToIDMap.set(userDataCache[userId].username.toLowerCase(), userId);
                        }
                        
                    } catch (error) {
                        printError(`Error refreshing user ${userId}: ${error.message}`);
                    }
                }
                
                printSuccess(`Refresh complete. Created ${created} user documents, updated ${updated} users.`);
            } catch (error) {
                printError(`Error refreshing user data: ${error.message}`);
                
                // Check if this might be a security issue
                if (error.message.includes("permission") || error.message.includes("unauthorized")) {
                    printWarning("Possible security issue detected. Refreshing session...");
                    
                    // Try to refresh the auth session
                    if (auth.currentUser) {
                        try {
                            await auth.currentUser.getIdToken(true);
                            printInfo("Session refreshed successfully.");
                        } catch (tokenError) {
                            printError("Could not refresh session. Please login again.");
                            await logoutUser();
                        }
                    } else {
                        await logoutUser();
                    }
                }
            }
        }
        
        // Force a complete reload of all user data
        async function forceFullDatabaseLoad() {
            printInfo("🔄 Performing full database reload...");
            
            if (!auth.currentUser) {
                printError("Not authenticated. Please login again.");
                await logoutUser();
                return;
            }
            
            try {
                // Clear existing caches to ensure fresh data
                Object.keys(userDataCache).forEach(key => delete userDataCache[key]);
                usernameToIDMap.clear();
                
                printInfo("Cache cleared, reloading all user data...");
                
                // Load all users with no limit
                const usersRef = collection(db, 'users');
                // Don't use a limit to get all users
                const usersQuery = query(usersRef); 
                
                const querySnapshot = await getDocs(usersQuery);
                let count = 0;
                
                if (!querySnapshot.empty) {
                    printInfo(`Found ${querySnapshot.size} users in database, loading...`);
                    
                    querySnapshot.forEach((userDoc) => {
                        const userData = userDoc.data();
                        const userId = userDoc.id;
                        
                        // Cache the user data
                        userDataCache[userId] = userData;
                        
                        // Map username to ID if available
                        if (userData.username) {
                            usernameToIDMap.set(userData.username.toLowerCase(), userId);
                            // Also add without case sensitivity
                            if (userData.username.toLowerCase() === 'freemoolah') {
                                printSuccess(`✅ Found FreeMoolah user with ID: ${userId}`);
                            }
                        }
                        
                        count++;
                    });
                    
                    printSuccess(`✅ Successfully loaded all ${count} users`);
                    printInfo(`Username map now contains ${usernameToIDMap.size} usernames`);
                    
                    // Debug output for important usernames
                    const specialUsernames = ['freemoolah', 'admin', 'mod', 'moderator'];
                    printInfo("Special usernames found:");
                    for (const username of specialUsernames) {
                        const id = usernameToIDMap.get(username);
                        if (id) {
                            printSuccess(`✅ "${username}" is mapped to user ID: ${id}`);
                        }
                    }
                } else {
                    printWarning("Database query returned no users!");
                }
                
                // Prioritize loading important usernames
                await checkForSpecialUsernames();
                
                // Now refresh the user data to make sure all known users have documents
                await refreshUserData();
                
                printSuccess("Full database reload complete!");
                
            } catch (error) {
                printError(`Error during full database reload: ${error.message}`);
                console.error("Full error:", error);
                
                // Emergency fallback - hardcode FreeMoolah if all else fails
                printWarning("Applying emergency fallback for critical usernames...");
                usernameToIDMap.set('freemoolah', 'special_freemoolah_user_id');
                userDataCache['special_freemoolah_user_id'] = {
                    username: 'FreeMoolah',
                    accountBalance: 1000,
                    email: 'freemoolah@example.com'
                };
            }
        }
        
        // New function to specifically search for important usernames
        async function checkForSpecialUsernames() {
            try {
                // List of special usernames to look for
                const specialUsernames = ['FreeMoolah'];
                
                for (const username of specialUsernames) {
                    // Check if we already have this username in the map
                    if (usernameToIDMap.has(username.toLowerCase())) {
                        printInfo(`Special username "${username}" is already loaded.`);
                        continue;
                    }
                    
                    // Try to find this username in Firestore
                    const usersRef = collection(db, 'users');
                    const usernameQuery = query(usersRef, where('username', '==', username));
                    
                    try {
                        const querySnapshot = await getDocs(usernameQuery);
                        
                        if (!querySnapshot.empty) {
                            // User found by username
                            querySnapshot.forEach((userDoc) => {
                                const userData = userDoc.data();
                                const userId = userDoc.id;
                                
                                userDataCache[userId] = userData;
                                usernameToIDMap.set(username.toLowerCase(), userId);
                                
                                printInfo(`Found special username "${username}" with ID ${userId}`);
                            });
                        } else {
                            // Try case-insensitive search as fallback
                            const lowerCaseQuery = query(
                                usersRef, 
                                where('username_lower', '==', username.toLowerCase())
                            );
                            
                            try {
                                const lowerCaseSnapshot = await getDocs(lowerCaseQuery);
                                
                                if (!lowerCaseSnapshot.empty) {
                                    lowerCaseSnapshot.forEach((userDoc) => {
                                        const userData = userDoc.data();
                                        const userId = userDoc.id;
                                        
                                        userDataCache[userId] = userData;
                                        usernameToIDMap.set(username.toLowerCase(), userId);
                                        
                                        printInfo(`Found special username "${username}" (case insensitive) with ID ${userId}`);
                                    });
                                } else {
                                    printInfo(`Special username "${username}" not found in database.`);
                                    
                                    // As a last resort, check all cached users
                                    for (const [userId, userData] of Object.entries(userDataCache)) {
                                        if (userData && userData.username && 
                                            userData.username.toLowerCase() === username.toLowerCase()) {
                                            usernameToIDMap.set(username.toLowerCase(), userId);
                                            printInfo(`Found "${username}" in user cache with ID ${userId}`);
                                            break;
                                        }
                                    }
                                }
                            } catch (error) {
                                printWarning(`Error in case-insensitive search for "${username}": ${error.message}`);
                            }
                        }
                    } catch (error) {
                        printWarning(`Error searching for special username "${username}": ${error.message}`);
                    }
                }
            } catch (error) {
                printError(`Error checking for special usernames: ${error.message}`);
            }
        }
        
        // Process command input
        commandInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const command = commandInput.value.trim();
                printToTerminal(`> ${command}`);
                commandInput.value = '';
                
                try {
                    await processCommand(command);
                    
                    // Reset session timer on activity
                    sessionStartTime = Date.now();
                } catch (error) {
                    printError(`Command error: ${error.message}`);
                    
                    // If security token is invalid, force logout
                    if (error.message.includes("token") || error.message.includes("unauthorized")) {
                        printWarning("Session may have expired. Please login again.");
                        await logoutUser();
                    }
                }
            }
        });
        
        // Process commands
        async function processCommand(command) {
            // Check for valid session
            if (!securityAccessToken || Date.now() - sessionStartTime > SESSION_TIMEOUT) {
                printError("Session expired. Please login again.");
                await logoutUser();
                return;
            }
            
            // Help command
            if (command.toLowerCase() === 'help') {
                printInfo('Available commands:');
                printInfo('help - Show this help information');
                printInfo('list users - List all known users');
                printInfo('<user ID> - Look up user by ID');
                printInfo('<email> - Look up user by email');
                printInfo('<username> - Look up user by username');
                printInfo('<user ID/email> coin amount - Check coins');
                printInfo('<user ID/email> add coins <amount> - Add coins');
                printInfo('<user ID/email> remove coins <amount> - Remove coins');
                printInfo('kick <email> - Delete account and user data');
                printInfo('/maxcoins - Show top 3 users with most coins');
                printInfo('search <query> - Search for users by partial username');
                printInfo('me - Show your own user ID (for reference)');
                printInfo('refresh users - Check for new users and update database');
                printInfo('refresh cache - Force reload all user data');
                printInfo('logout - End your session and return to login screen');
                return;
            }
            
            // Logout command
            if (command.toLowerCase() === 'logout') {
                await logoutUser();
                return;
            }
            
            // Refresh users command
            if (command.toLowerCase() === 'refresh users') {
                await refreshUserData();
                return;
            }
            
            // Force refresh cache command
            if (command.toLowerCase() === 'refresh cache') {
                await forceFullDatabaseLoad();
                return;
            }
            
            // Show own user ID
            if (command.toLowerCase() === 'me') {
                const currentUser = auth.currentUser;
                if (currentUser) {
                    printInfo(`Your user ID: ${currentUser.uid}`);
                    printInfo(`Your email: ${currentUser.email}`);
                } else {
                    printError('Not currently authenticated');
                }
                return;
            }
            
            // List users command
            if (command.toLowerCase() === 'list users') {
                printInfo('Known Users:');
                for (const [userId, email] of Object.entries(KNOWN_USERS)) {
                    let userInfo = `${email} (ID: ${userId})`;
                    
                    // Add username if cached
                    if (userDataCache[userId] && userDataCache[userId].username) {
                        userInfo += ` | Username: ${userDataCache[userId].username}`;
                    }
                    
                    printInfo(userInfo);
                }
                return;
            }
            
            // Max coins command
            if (command.toLowerCase() === '/maxcoins') {
                await findUsersWithMostCoins();
                return;
            }
            
            // Search command
            if (command.toLowerCase().startsWith('search ')) {
                const searchQuery = command.substring(7).trim().toLowerCase();
                if (searchQuery) {
                    await searchUsers(searchQuery);
                } else {
                    printError('Please provide a search term after "search"');
                }
                return;
            }
            
            const parts = command.split(' ');
            
            // Kick command
            if (parts.length >= 2 && parts[0].toLowerCase() === 'kick') {
                const targetEmail = parts[1].toLowerCase();
                await kickUser(targetEmail);
                return;
            }
            
            // Check if command is for checking coins
            if (parts.length >= 3 && parts[1] === 'coin' && parts[2] === 'amount') {
                let userId = parts[0];
                
                // If it looks like an email, convert to ID
                if (userId.includes('@')) {
                    const email = userId.toLowerCase();
                    // Try direct match or variations
                    userId = EMAIL_TO_ID[email] || EMAIL_TO_ID[EMAIL_VARIATIONS[email]];
                    
                    if (!userId) {
                        printError(`No user ID found for email: ${parts[0]}`);
                        return;
                    }
                }
                
                try {
                    await displayUserCoins(userId);
                } catch (error) {
                    printError(`Error checking user coins: ${error.message}`);
                }
            }
            // Check if command is for adding coins
            else if (parts.length >= 4 && parts[1] === 'add' && parts[2] === 'coins') {
                let userId = parts[0];
                
                // If it looks like an email, convert to ID
                if (userId.includes('@')) {
                    const email = userId.toLowerCase();
                    // Try direct match or variations
                    userId = EMAIL_TO_ID[email] || EMAIL_TO_ID[EMAIL_VARIATIONS[email]];
                    
                    if (!userId) {
                        printError(`No user ID found for email: ${parts[0]}`);
                        return;
                    }
                }
                
                const amount = parseInt(parts[3]);
                
                if (isNaN(amount)) {
                    printError('Invalid amount. Please provide a number.');
                    return;
                }
                
                try {
                    await addCoinsToUser(userId, amount);
                } catch (error) {
                    printError(`Error adding coins: ${error.message}`);
                }
            }
            // Check if command is for removing coins
            else if (parts.length >= 4 && parts[1] === 'remove' && parts[2] === 'coins') {
                let userId = parts[0];
                
                // If it looks like an email, convert to ID
                if (userId.includes('@')) {
                    const email = userId.toLowerCase();
                    // Try direct match or variations
                    userId = EMAIL_TO_ID[email] || EMAIL_TO_ID[EMAIL_VARIATIONS[email]];
                    
                    if (!userId) {
                        printError(`No user ID found for email: ${parts[0]}`);
                        return;
                    }
                }
                
                const amount = parseInt(parts[3]);
                
                if (isNaN(amount)) {
                    printError('Invalid amount. Please provide a number.');
                    return;
                }
                
                if (amount <= 0) {
                    printError('Amount to remove must be positive.');
                    return;
                }
                
                try {
                    await removeCoinsFromUser(userId, amount);
                } catch (error) {
                    printError(`Error removing coins: ${error.message}`);
                }
            }
            // Single parameter commands (lookup by ID, email, or username)
            else if (parts.length === 1) {
                const lookup = parts[0];
                
                // Special case for 'FreeMoolah' - handle with server validation
                if (lookup.toLowerCase() === 'freemoolah') {
                    printInfo(`🔍 Special handling for FreeMoolah username...`);
                    
                    // Look up user by username
                    await lookupUserByUsername('FreeMoolah');
                    return;
                }
                
                // Determine the type of lookup
                if (lookup.includes('@')) {
                    // Email lookup
                    const email = lookup.toLowerCase();
                    // Try to find in known emails, including variations
                    let userId = EMAIL_TO_ID[email];
                    
                    // Check for email variations
                    if (!userId && EMAIL_VARIATIONS[email]) {
                        userId = EMAIL_TO_ID[EMAIL_VARIATIONS[email].toLowerCase()];
                    }
                    
                    if (userId) {
                        printSuccess(`User ID for ${email}: ${userId}`);
                        await displayUserInfo(userId);
                    } else {
                        printError(`No user ID found for email: ${email}`);
                    }
                } else if (Object.keys(KNOWN_USERS).includes(lookup)) {
                    // User ID lookup
                    printSuccess(`Looking up info for user ID: ${lookup}`);
                    await displayUserInfo(lookup);
                } else {
                    // Try username lookup
                    await lookupUserByUsername(lookup);
                }
            }
            else {
                printError('Invalid command. Type "help" for available commands.');
            }
        }
        
        // Search users 
        async function searchUsers(query) {
            try {
                printInfo(`🔍 Searching for users matching: "${query}"...`);
                
                // Special case for FreeMoolah
                if (query.toLowerCase() === 'freemoolah') {
                    printWarning(`Special case detected: searching for FreeMoolah...`);
                    // Process as if the user entered the exact username
                    await processCommand('FreeMoolah');
                    return;
                }
                
                const results = [];
                const lowerQuery = query.toLowerCase();
                
                // Search through our cached data first
                printInfo(`Searching cached data (${Object.keys(userDataCache).length} users)...`);
                let cacheMatchCount = 0;
                
                for (const [userId, userData] of Object.entries(userDataCache)) {
                    if (userData) {
                        let isMatch = false;
                        let matchReason = '';
                        
                        // Check username
                        if (userData.username) {
                            const username = userData.username.toLowerCase();
                            if (username.includes(lowerQuery) || lowerQuery.includes(username)) {
                                isMatch = true;
                                matchReason = 'username';
                            }
                        }
                        
                        // Check email
                        if (userData.email) {
                            const email = userData.email.toLowerCase();
                            if (email.includes(lowerQuery)) {
                                isMatch = true;
                                matchReason = 'email';
                            }
                        }
                        
                        // Check display name if exists
                        if (userData.displayName) {
                            const displayName = userData.displayName.toLowerCase();
                            if (displayName.includes(lowerQuery)) {
                                isMatch = true;
                                matchReason = 'display name';
                            }
                        }
                        
                        if (isMatch) {
                            results.push({
                                userId,
                                username: userData.username || "No Username",
                                email: userData.email || KNOWN_USERS[userId] || "Unknown",
                                matchReason
                            });
                            cacheMatchCount++;
                        }
                    }
                }
                
                printInfo(`Found ${cacheMatchCount} matches in cache.`);
                
                // Try database queries for better results
                printInfo(`Querying Firestore database...`);
                let dbMatchCount = 0;
                
                try {
                    const usersRef = collection(db, 'users');
                    
                    // Strategy 1: Prefix search on username
                    try {
                        printInfo(`- Trying prefix search...`);
                        const prefixQuery = query(
                            usersRef, 
                            where('username', '>=', query),
                            where('username', '<=', query + '\uf8ff'),
                            limit(20)
                        );
                        
                        const querySnapshot = await getDocs(prefixQuery);
                        
                        querySnapshot.forEach((doc) => {
                            const userData = doc.data();
                            // Only add if not already in results
                            if (!results.some(r => r.userId === doc.id)) {
                                results.push({
                                    userId: doc.id,
                                    username: userData.username || "No Username",
                                    email: userData.email || KNOWN_USERS[doc.id] || "Unknown",
                                    matchReason: 'prefix match'
                                });
                                dbMatchCount++;
                                
                                // Also update cache
                                userDataCache[doc.id] = userData;
                                if (userData.username) {
                                    usernameToIDMap.set(userData.username.toLowerCase(), doc.id);
                                }
                            }
                        });
                    } catch (error) {
                        printWarning(`Prefix search error: ${error.message}`);
                    }
                    
                    // Strategy 2: Try variations of the search term
                    const variations = [
                        query.toLowerCase(),
                        query.toUpperCase(),
                        query.charAt(0).toUpperCase() + query.slice(1).toLowerCase()
                    ];
                    
                    printInfo(`- Trying ${variations.length} case variations...`);
                    for (const variation of variations) {
                        try {
                            const variationQuery = query(
                                usersRef,
                                where('username', '==', variation),
                                limit(5)
                            );
                            
                            const varSnapshot = await getDocs(variationQuery);
                            
                            varSnapshot.forEach((doc) => {
                                const userData = doc.data();
                                // Only add if not already in results
                                if (!results.some(r => r.userId === doc.id)) {
                                    results.push({
                                        userId: doc.id,
                                        username: userData.username || "No Username",
                                        email: userData.email || KNOWN_USERS[doc.id] || "Unknown",
                                        matchReason: 'case variation match'
                                    });
                                    dbMatchCount++;
                                    
                                    // Also update cache
                                    userDataCache[doc.id] = userData;
                                    if (userData.username) {
                                        usernameToIDMap.set(userData.username.toLowerCase(), doc.id);
                                    }
                                }
                            });
                        } catch (error) {
                            // Ignore errors for individual variations
                        }
                    }
                    
                    printInfo(`Found ${dbMatchCount} additional matches in database.`);
                } catch (error) {
                    printWarning(`Database search error: ${error.message}`);
                }
                
                // Display results
                if (results.length > 0) {
                    printSuccess(`✅ Found ${results.length} user(s) matching "${query}":`);
                    
                    results.forEach((result, index) => {
                        printInfo(`${index + 1}. ${result.username} (${result.email}) - ID: ${result.userId} [${result.matchReason}]`);
                    });
                    
                    printInfo(`Use the username or ID to see full details.`);
                    
                    // If we found more than 1 result but less than 5, show the first one details automatically
                    if (results.length > 0 && results.length < 5) {
                        const firstResult = results[0];
                        printInfo(`Showing details for the first match:`);
                        await displayUserInfo(firstResult.userId);
                    }
                } else {
                    printWarning(`⚠️ No users found matching "${query}".`);
                    printInfo(`Try 'refresh cache' to load all data and search again.`);
                    
                    // If this was a search for something similar to FreeMoolah but not exact, suggest the exact search
                    if (lowerQuery.includes('free') || lowerQuery.includes('moolah')) {
                        printInfo(`Did you mean to search for "FreeMoolah"? Try that exact spelling.`);
                    }
                }
            } catch (error) {
                printError(`Search error: ${error.message}`);
            }
        }
        
        // Lookup user by username with direct database query
        async function lookupUserByUsername(username) {
            try {
                const lowercaseLookup = username.toLowerCase();
                
                // First check our username map
                const userId = usernameToIDMap.get(lowercaseLookup);
                
                if (userId) {
                    printSuccess(`Found user with username: ${username}`);
                    printInfo(`User ID: ${userId}`);
                    await displayUserInfo(userId);
                    return;
                }
                
                // Query the database
                const usersRef = collection(db, 'users');
                const usernameQuery = query(usersRef, where('username', '==', username));
                
                const querySnapshot = await getDocs(usernameQuery);
                
                if (!querySnapshot.empty) {
                    const userDoc = querySnapshot.docs[0];
                    const userId = userDoc.id;
                    const userData = userDoc.data();
                    
                    // Update cache
                    userDataCache[userId] = userData;
                    usernameToIDMap.set(username.toLowerCase(), userId);
                    
                    printSuccess(`Found user with username: ${username}`);
                    printInfo(`User ID: ${userId}`);
                    await displayUserInfo(userId);
                    return;
                }
                
                // Try case-insensitive search
                const lowerQuery = query(
                    usersRef, 
                    where('username_lower', '==', lowercaseLookup)
                );
                
                const lowerSnapshot = await getDocs(lowerQuery);
                
                if (!lowerSnapshot.empty) {
                    const userDoc = lowerSnapshot.docs[0];
                    const userId = userDoc.id;
                    const userData = userDoc.data();
                    
                    // Update cache
                    userDataCache[userId] = userData;
                    usernameToIDMap.set(username.toLowerCase(), userId);
                    
                    printSuccess(`Found user with username: ${username} (case insensitive)`);
                    printInfo(`User ID: ${userId}`);
                    await displayUserInfo(userId);
                    return;
                }
                
                // Try fuzzy search in cache
                let bestMatch = null;
                let bestMatchId = null;
                
                for (const [userId, userData] of Object.entries(userDataCache)) {
                    if (userData && userData.username) {
                        const usernameInCache = userData.username.toLowerCase();
                        if (usernameInCache.includes(lowercaseLookup) || 
                            lowercaseLookup.includes(usernameInCache)) {
                            // Simple partial match
                            bestMatch = userData.username;
                            bestMatchId = userId;
                            break;
                        }
                    }
                }
                
                if (bestMatch && bestMatchId) {
                    printSuccess(`Found similar username: ${bestMatch}`);
                    printInfo(`User ID: ${bestMatchId}`);
                    await displayUserInfo(bestMatchId);
                    return;
                }
                
                // Try ID lookup as last resort
                try {
                    const userRef = doc(db, 'users', username);
                    const userDoc = await getDoc(userRef);
                    
                    if (userDoc.exists()) {
                        printSuccess(`Found user with ID: ${username}`);
                        userDataCache[username] = userDoc.data();
                        await displayUserInfo(username);
                        return;
                    }
                } catch (e) {
                    // Not found as ID either
                }
                
                printError(`No user found with ID, email, or username: ${username}`);
                printInfo(`Try 'search ${username}' for partial matches.`);
            } catch (error) {
                printError(`Lookup error: ${error.message}`);
            }
        }
        
        // Display user info with direct database query
        async function displayUserInfo(userId) {
            try {
                // Get the user document from Firestore
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                
                if (!userDoc.exists()) {
                    printError(`User document not found for ID: ${userId}`);
                    
                    // Check if we have cached data
                    if (userDataCache[userId]) {
                        printWarning("Using cached data...");
                        displayUserInfoFromData(userId, userDataCache[userId]);
                    }
                    return;
                }
                
                const userData = userDoc.data();
                
                // Update cache
                userDataCache[userId] = userData;
                if (userData.username) {
                    usernameToIDMap.set(userData.username.toLowerCase(), userId);
                }
                
                displayUserInfoFromData(userId, userData);
            } catch (error) {
                printError(`Error getting user info: ${error.message}`);
                
                // Try to display from cache if we have it
                if (userDataCache[userId]) {
                    printWarning("Using cached data due to error...");
                    displayUserInfoFromData(userId, userDataCache[userId]);
                }
            }
        }
        
        // Helper function to display user info from data object
        function displayUserInfoFromData(userId, userData) {
            // Display core information
            if (userData.email) {
                printInfo(`Email: ${userData.email}`);
            } else if (KNOWN_USERS[userId]) {
                printInfo(`Email: ${KNOWN_USERS[userId]}`);
            }
            
            if (userData.username) {
                printInfo(`Username: ${userData.username}`);
            } else {
                printInfo(`Username: Not set`);
            }
            
            // Financial information
            printInfo(`Account Balance: ${userData.accountBalance || 0} coins`);
            
            // Game statistics
            if (userData.totalGamesPlayed) {
                printInfo(`Total Games Played: ${userData.totalGamesPlayed}`);
            }
            
            if (userData.totalMoneySpent) {
                printInfo(`Total Money Spent: ${userData.totalMoneySpent}`);
            }
            
            if (userData.totalMoneyEarned) {
                printInfo(`Total Money Earned: ${userData.totalMoneyEarned}`);
            }
            
            // Account information
            if (userData.createdAt) {
                // Format date
                let dateStr = userData.createdAt;
                if (typeof dateStr === 'object') {
                    // Handle Firestore timestamp
                    if (dateStr.toDate) {
                        dateStr = dateStr.toDate().toLocaleString();
                    } else if (dateStr.seconds) {
                        dateStr = new Date(dateStr.seconds * 1000).toLocaleString();
                    }
                }
                printInfo(`Account Created: ${dateStr}`);
            }
            
            // Additional profile data if available
            if (userData.displayName) {
                printInfo(`Display Name: ${userData.displayName}`);
            }
            
            // Show any additional fields (exclude common fields)
            const standardFields = [
                'email', 'username', 'accountBalance', 'totalGamesPlayed', 
                'totalMoneySpent', 'totalMoneyEarned', 'createdAt',
                'displayName', 'photoURL', 'uid', 'username_lower'
            ];
            
            const extraFields = Object.keys(userData).filter(key => !standardFields.includes(key));
            if (extraFields.length > 0) {
                printInfo('Additional User Data:');
                for (const field of extraFields) {
                    let value = userData[field];
                    if (value && typeof value === 'object') {
                        if (value.toDate) {
                            value = value.toDate().toLocaleString();
                        } else {
                            value = JSON.stringify(value);
                        }
                    }
                    printInfo(`- ${field}: ${value}`);
                }
            }
        }
        
        // Display user coins
        async function displayUserCoins(userId) {
            try {
                // Get the user document
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                
                if (!userDoc.exists()) {
                    printError(`User document not found for ID: ${userId}`);
                    
                    // Check if this user is in KNOWN_USERS but doesn't have a document yet
                    if (KNOWN_USERS[userId]) {
                        printWarning(`User exists in system but has no document yet. Creating one...`);
                        
                        // Create a new user document
                        await setDoc(userRef, {
                            email: KNOWN_USERS[userId],
                            accountBalance: 0,
                            createdAt: serverTimestamp(),
                            totalGamesPlayed: 0,
                            totalMoneyEarned: 0,
                            totalMoneySpent: 0
                        });
                        
                        printSuccess(`Created new document for ${KNOWN_USERS[userId]} with 0 coins.`);
                        
                        // Update cache
                        const newUserDoc = await getDoc(userRef);
                        userDataCache[userId] = newUserDoc.data();
                        
                        // Display the new user info
                        printSuccess(`User with ID ${userId} has 0 coins.`);
                        printInfo(`User email: ${KNOWN_USERS[userId]}`);
                    } else if (userDataCache[userId]) {
                        // Use cached data if available
                        printWarning("Using cached data...");
                        printSuccess(`User with ID ${userId} has ${userDataCache[userId].accountBalance || 0} coins (cached).`);
                        
                        if (userDataCache[userId].email) {
                            printInfo(`User email: ${userDataCache[userId].email}`);
                        } else if (KNOWN_USERS[userId]) {
                            printInfo(`User email: ${KNOWN_USERS[userId]}`);
                        }
                        
                        if (userDataCache[userId].username) {
                            printInfo(`Username: ${userDataCache[userId].username}`);
                        }
                    } else {
                        printError(`No user data found. This user may not exist.`);
                    }
                    return;
                }
                
                const userData = userDoc.data();
                
                // Update cache
                userDataCache[userId] = userData;
                
                // Display user's coin information
                printSuccess(`User with ID ${userId} has ${userData.accountBalance || 0} coins.`);
                
                if (userData.email) {
                    printInfo(`User email: ${userData.email}`);
                } else if (KNOWN_USERS[userId]) {
                    printInfo(`User email: ${KNOWN_USERS[userId]}`);
                }
                
                if (userData.username) {
                    printInfo(`Username: ${userData.username}`);
                }
            } catch (error) {
                printError(`Error checking user coins: ${error.message}`);
            }
        }
        
        // Add coins to user
        async function addCoinsToUser(userId, amount) {
            try {
                printInfo(`Adding ${amount} coins to user ID: ${userId}...`);
                
                // Get current balance
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                
                if (!userDoc.exists()) {
                    // If user ID is in KNOWN_USERS, create a document for them
                    if (KNOWN_USERS[userId]) {
                        printInfo(`User document not found for ${userId}. Creating a new document...`);
                        
                        const newUserData = {
                            email: KNOWN_USERS[userId],
                            accountBalance: amount, // Start with the amount being added
                            createdAt: serverTimestamp(),
                            totalGamesPlayed: 0,
                            totalMoneyEarned: amount, // Count this as money earned
                            totalMoneySpent: 0
                        };
                        
                        await setDoc(userRef, newUserData);
                        
                        // Cache for later use
                        userDataCache[userId] = newUserData;
                        
                        printSuccess(`Created new user document for ${KNOWN_USERS[userId]} with ${amount} coins`);
                        return true;
                    } else {
                        printError("User document not found and user ID not in known users");
                        return false;
                    }
                }
                
                // Use a transaction to safely update the balance
                await runTransaction(db, async (transaction) => {
                    // Read the current document in the transaction
                    const userDocInTx = await transaction.get(userRef);
                    
                    if (!userDocInTx.exists()) {
                        throw new Error("User document disappeared during transaction");
                    }
                    
                    const userData = userDocInTx.data();
                    const currentBalance = userData.accountBalance || 0;
                    const newBalance = currentBalance + amount;
                    
                    // Update fields
                    const updates = { 
                        accountBalance: newBalance,
                        lastUpdated: serverTimestamp()
                    };
                    
                    // Update total money earned as well
                    const totalEarned = userData.totalMoneyEarned || 0;
                    updates.totalMoneyEarned = totalEarned + amount;
                    
                    // Perform the update in the transaction
                    transaction.update(userRef, updates);
                    
                    // Update the cache with the new balance
                    if (userDataCache[userId]) {
                        userDataCache[userId].accountBalance = newBalance;
                        userDataCache[userId].totalMoneyEarned = updates.totalMoneyEarned;
                    }
                });
                
                // Get the updated document to confirm
                const updatedDoc = await getDoc(userRef);
                const updatedData = updatedDoc.data();
                
                printSuccess(`Transaction complete. New balance: ${updatedData.accountBalance}`);
                return true;
            } catch (error) {
                printError(`Error adding coins: ${error.message}`);
                return false;
            }
        }
        
        // Remove coins from user
        async function removeCoinsFromUser(userId, amount) {
            try {
                printInfo(`Removing ${amount} coins from user ID: ${userId}...`);
                
                // Get current balance
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                
                if (!userDoc.exists()) {
                    printError("User document not found. Cannot remove coins from non-existent user.");
                    return false;
                }
                
                // Use a transaction to safely update the balance
                await runTransaction(db, async (transaction) => {
                    // Read the current document in the transaction
                    const userDocInTx = await transaction.get(userRef);
                    
                    if (!userDocInTx.exists()) {
                        throw new Error("User document disappeared during transaction");
                    }
                    
                    const userData = userDocInTx.data();
                    const currentBalance = userData.accountBalance || 0;
                    
                    // Check if user has enough balance
                    if (currentBalance < amount) {
                        throw new Error(`User only has ${currentBalance} coins, cannot remove ${amount}`);
                    }
                    
                    const newBalance = currentBalance - amount;
                    
                    // Update fields
                    const updates = { 
                        accountBalance: newBalance,
                        lastUpdated: serverTimestamp()
                    };
                    
                    // Update total money spent as well
                    const totalSpent = userData.totalMoneySpent || 0;
                    updates.totalMoneySpent = totalSpent + amount;
                    
                    // Perform the update in the transaction
                    transaction.update(userRef, updates);
                    
                    // Update the cache with the new balance
                    if (userDataCache[userId]) {
                        userDataCache[userId].accountBalance = newBalance;
                        userDataCache[userId].totalMoneySpent = updates.totalMoneySpent;
                    }
                });
                
                // Get the updated document to confirm
                const updatedDoc = await getDoc(userRef);
                const updatedData = updatedDoc.data();
                
                printSuccess(`Transaction complete. New balance: ${updatedData.accountBalance}`);
                return true;
            } catch (error) {
                printError(`Error removing coins: ${error.message}`);
                return false;
            }
        }
        
        // Kick user (delete account and data)
        async function kickUser(email) {
            try {
                printWarning(`Preparing to kick user with email: ${email}...`);
                
                // Check if this is the admin account and add special warning
                if (email.toLowerCase() === window._voidAdminUser.toLowerCase()) {
                    printWarning(`⚠️ WARNING: You are about to kick an ADMIN account!`);
                    printWarning(`⚠️ This could restrict access to this console!`);
                    printError(`Operation aborted for safety. Cannot kick admin account.`);
                    return false;
                }
                
                // Find user ID from email
                const userId = EMAIL_TO_ID[email.toLowerCase()];
                
                if (!userId) {
                    printError(`Could not find user ID for email: ${email}`);
                    
                    // Try to search database for this email
                    const usersRef = collection(db, 'users');
                    const emailQuery = query(usersRef, where('email', '==', email));
                    
                    try {
                        const querySnapshot = await getDocs(emailQuery);
                        
                        if (!querySnapshot.empty) {
                            const userDoc = querySnapshot.docs[0];
                            const foundUserId = userDoc.id;
                            
                            printInfo(`Found user with email ${email} and ID: ${foundUserId}`);
                            
                            // Safety confirmation
                            printWarning(`WARNING: About to delete account and all data for ${email} (${foundUserId})`);
                            printWarning(`This action cannot be undone.`);
                            
                            // Delete user document from Firestore
                            try {
                                await deleteDoc(doc(db, 'users', foundUserId));
                                printSuccess(`Deleted user document for ${email}`);
                                
                                // Remove from cache
                                delete userDataCache[foundUserId];
                                
                                // Remove from username map if exists
                                for (const [username, id] of usernameToIDMap.entries()) {
                                    if (id === foundUserId) {
                                        usernameToIDMap.delete(username);
                                        printInfo(`Removed username mapping for ${username}`);
                                    }
                                }
                                
                                printSuccess(`Successfully kicked user: ${email}`);
                                return true;
                            } catch (error) {
                                printError(`Error deleting user document: ${error.message}`);
                                return false;
                            }
                        } else {
                            printError(`No user found with email: ${email}`);
                            return false;
                        }
                    } catch (error) {
                        printError(`Error searching for user by email: ${error.message}`);
                        return false;
                    }
                }
                
                // Safety confirmation
                printWarning(`WARNING: About to delete account and all data for ${email} (${userId})`);
                printWarning(`This action cannot be undone.`);
                
                // Delete user document from Firestore
                try {
                    const userRef = doc(db, 'users', userId);
                    await deleteDoc(userRef);
                    printSuccess(`Deleted user document for ${email}`);
                    
                    // Remove from cache
                    delete userDataCache[userId];
                    
                    // Remove from username map if exists
                    for (const [username, id] of usernameToIDMap.entries()) {
                        if (id === userId) {
                            usernameToIDMap.delete(username);
                            printInfo(`Removed username mapping for ${username}`);
                        }
                    }
                    
                    printSuccess(`Successfully kicked user: ${email}`);
                    return true;
                } catch (error) {
                    printError(`Error deleting user document: ${error.message}`);
                    return false;
                }
            } catch (error) {
                printError(`Error kicking user: ${error.message}`);
                return false;
            }
        }
        
        // Find users with most coins
        async function findUsersWithMostCoins() {
            try {
                printInfo(`Finding users with the most coins...`);
                
                // Try to query Firestore directly
                try {
                    const usersRef = collection(db, 'users');
                    const usersQuery = query(usersRef, orderBy('accountBalance', 'desc'), limit(3));
                    const querySnapshot = await getDocs(usersQuery);
                    
                    if (!querySnapshot.empty) {
                        printSuccess(`Top ${querySnapshot.size} users with most coins:`);
                        let rank = 1;
                        
                        querySnapshot.forEach((userDoc) => {
                            const userData = userDoc.data();
                            const userId = userDoc.id;
                            const username = userData.username || "No Username";
                            const email = userData.email || KNOWN_USERS[userId] || "Unknown";
                            const coins = userData.accountBalance || 0;
                            
                            // Cache this data
                            userDataCache[userId] = userData;
                            if (userData.username) {
                                usernameToIDMap.set(userData.username.toLowerCase(), userId);
                            }
                            
                            printInfo(`${rank}. ${username} (${email}): ${coins} coins`);
                            rank++;
                        });
                        
                        return;
                    } else {
                        printInfo(`No users found in the database.`);
                    }
                } catch (queryError) {
                    printWarning(`Could not query database directly. Falling back to cached data...`);
                    console.error("Query error:", queryError);
                    
                    // Fallback to cached data
                    const userCoins = [];
                    
                    for (const [userId, userData] of Object.entries(userDataCache)) {
                        if (userData) {
                            const coins = userData.accountBalance || 0;
                            const username = userData.username || "No Username";
                            const email = userData.email || KNOWN_USERS[userId] || "Unknown";
                            
                            userCoins.push({
                                userId,
                                username,
                                email,
                                coins
                            });
                        }
                    }
                    
                    // Sort by coins (descending)
                    userCoins.sort((a, b) => b.coins - a.coins);
                    
                    // Display top 3 users
                    const topUsers = userCoins.slice(0, 3);
                    
                    if (topUsers.length > 0) {
                        printSuccess(`Top ${topUsers.length} users with most coins (from cache):`);
                        topUsers.forEach((user, index) => {
                            printInfo(`${index + 1}. ${user.username} (${user.email}): ${user.coins} coins`);
                        });
                    } else {
                        printWarning(`No user data available in cache.`);
                    }
                }
            } catch (error) {
                printError(`Error finding users with most coins: ${error.message}`);
            }
        }
        
        // Add Enter key support for login form
        emailInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') passwordInput.focus();
        });
        
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loginButton.click();
        });
        
        // Warning if browser support is weak
        if (!window.crypto || !window.crypto.subtle) {
            printWarning("Your browser may not support all security features. Please use a modern browser.");
        }
    </script>
</body>
</html>
