<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Void Network Admin Console</title>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            padding: 20px;
            margin: 0;
        }
        #terminal {
            width: 100%;
            height: 80vh;
            background-color: #111;
            border: 1px solid #0f0;
            padding: 10px;
            overflow-y: auto;
            white-space: pre-wrap;
            box-sizing: border-box;
        }
        #commandInput {
            width: 100%;
            background-color: #111;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            box-sizing: border-box;
        }
        .success {
            color: #0f0;
        }
        .error {
            color: #f00;
        }
        .info {
            color: #0ff;
        }
        .warning {
            color: #ff0;
        }
        #loginForm {
            background-color: #111;
            border: 1px solid #0f0;
            padding: 20px;
            margin: 20px auto;
            max-width: 400px;
            text-align: center;
        }
        input[type="email"], input[type="password"] {
            width: 100%;
            background-color: #111;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            box-sizing: border-box;
        }
        button {
            background-color: #111;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            margin-top: 10px;
            font-family: monospace;
            cursor: pointer;
        }
        button:hover {
            background-color: #0f0;
            color: #111;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loginForm">
        <h2>Void Network Admin Login</h2>
        <input type="email" id="emailInput" placeholder="Email" autofocus>
        <input type="password" id="passwordInput" placeholder="Password">
        <button id="loginButton">Login</button>
        <div id="loginMessage" class="error hidden"></div>
    </div>

    <div id="adminConsole" class="hidden">
        <div id="terminal"></div>
        <input type="text" id="commandInput" placeholder="Enter command...">
    </div>
    
    <script type="module">
        // Anti-debugging and anti-tampering measures
        (function() {
            // Prevent debugging
            const originalConsole = window.console;
            const bannedMethods = ['log', 'debug', 'info', 'warn', 'error', 'table', 'trace', 'dir', 'dirxml'];
            
            // Track debug attempts
            let debugAttempts = 0;
            const maxDebugAttempts = 5;
            let lastDebugTime = 0;
            
            const monitorDebugAttempts = () => {
                const now = Date.now();
                // Reset counter if more than 10 seconds have passed
                if (now - lastDebugTime > 10000) {
                    debugAttempts = 0;
                }
                
                lastDebugTime = now;
                debugAttempts++;
                
                if (debugAttempts >= maxDebugAttempts) {
                    // Too many debug attempts detected
                    document.body.innerHTML = '<h1 style="color: red">Security violation detected</h1>';
                    setTimeout(() => { window.location.href = "about:blank"; }, 3000);
                }
            };
            
            // Disable console in production (keeping it commented for now for development)
            /* 
            bannedMethods.forEach(method => {
                window.console[method] = function() {
                    monitorDebugAttempts();
                    // Silent fail or redirect
                    return undefined;
                };
            });
            */
            
            // Anti-user modification - detect changes to our security code
            const securityHash = "secure_hash_" + Math.random().toString(36).substring(2); // Placeholder
            window._securityToken = securityHash;
            
            // Create a hidden verification function with obfuscated name
            window["__v" + securityHash.substring(0, 8)] = function() {
                return window._securityToken === securityHash;
            };
            
            // Monitor for modifications
            setInterval(() => {
                const verifyFn = window["__v" + securityHash.substring(0, 8)];
                if (!verifyFn || !verifyFn() || window._securityToken !== securityHash) {
                    // Code has been tampered with
                    document.body.innerHTML = '<h1 style="color: red">Security violation: Page has been tampered with</h1>';
                    setTimeout(() => { window.location.href = "about:blank"; }, 3000);
                }
            }, 2000);
            
            // Prevent view-source
            window.addEventListener("keydown", function(e) {
                // Block F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
                if (
                    e.keyCode === 123 || 
                    (e.ctrlKey && e.shiftKey && (e.keyCode === 73 || e.keyCode === 74)) || 
                    (e.ctrlKey && e.keyCode === 85)
                ) {
                    monitorDebugAttempts();
                    e.preventDefault();
                    return false;
                }
            });
            
            // Detect Devtools
            function isDevToolsOpen() {
                const threshold = 160;
                const widthThreshold = window.outerWidth - window.innerWidth > threshold;
                const heightThreshold = window.outerHeight - window.innerHeight > threshold;
                
                if (widthThreshold || heightThreshold) {
                    monitorDebugAttempts();
                    return true;
                }
                return false;
            }
            
            // Check periodically
            setInterval(isDevToolsOpen, 1000);
            
            // Prevent right-click
            document.addEventListener('contextmenu', function(e) {
                monitorDebugAttempts();
                e.preventDefault();
                return false;
            });
            
            // Check if script has been modified by comparing execution time
            const startTime = new Date().getTime();
            setTimeout(function() {
                const endTime = new Date().getTime();
                const executionTime = endTime - startTime;
                
                // If execution takes much longer than expected, debugger might be paused
                if (executionTime > 50) { // 50ms should be enough for this simple timeout
                    monitorDebugAttempts();
                }
            }, 1);
        })();
        
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
        import { getFirestore, collection, doc, getDoc, getDocs, updateDoc, setDoc, query, limit, where, deleteDoc, orderBy, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore.js";

        // Firebase Configuration - Obfuscated
        const _0xb431 = ['AIzaSyCkAp_GCGCtw4zv7GgHJOE9GPgIaPEuOvQ','void-games-c8d9e.firebaseapp.com','void-games-c8d9e','void-games-c8d9e.firebasestorage.app','1063089929776','1:1063089929776:web:8e226a23a4f3ab9c5777f5'];
        const firebaseConfig = {
            apiKey: _0xb431[0],
            authDomain: _0xb431[1],
            projectId: _0xb431[2],
            storageBucket: _0xb431[3],
            messagingSenderId: _0xb431[4],
            appId: _0xb431[5]
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Secure admin email verification
        // IMPORTANT: This variable is protected against tampering
        let _adminEmail = null;
        
        // Define the admin email in a way that's harder to tamper with
        Object.defineProperty(window, '_voidAdminUser', {
            get: function() {
                if (!_adminEmail) {
                    // Construct email from pieces to avoid easy search/replace
                    const domain = 'gmail.com';
                    const parts = ['s', 'i', 'x', '7', '5', '8', '8'];
                    _adminEmail = parts.join('') + '@' + domain;
                }
                return _adminEmail;
            },
            configurable: false,
            enumerable: false
        });
        
        let securityAccessToken = "";
        let sessionStartTime = 0;
        const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
        
        // DOM Elements
        const loginForm = document.getElementById('loginForm');
        const emailInput = document.getElementById('emailInput');
        const passwordInput = document.getElementById('passwordInput');
        const loginButton = document.getElementById('loginButton');
        const loginMessage = document.getElementById('loginMessage');
        const adminConsole = document.getElementById('adminConsole');
        const terminal = document.getElementById('terminal');
        const commandInput = document.getElementById('commandInput');
        
        // Hardcoded known user IDs from Firebase Auth UI - with corrected spelling
        // Adding your new UID to the list
        const KNOWN_USERS = {
            "KIsAtjOwRpdVDOL3VPrDBACSxdw1": "six7588@gmail.com",
            "GU9JmuJistfcjKLwtJLmj5BELHs2": "nigatikler@gmail.com",
            "mtl6j5MsEwYhfVfT1yw9JmrSfMV2": "1q2w3e4r5t6y7u8i9o0p@gmail.com",
            "ku8A1MuC6jWJxEnPIb9nYCY2MnH2": "mjbalkovski@gmail.com",
            "Ga450aQRGGMqUOgFVGs62fRnZ6l1": "svalenciarivera@isdkids.org",
            "3qJsAc8TsbZzx0SZdfduH7ijLuP2": "dfsgdsgr@gamil.comsd",
            "dcxtOHGcfrQ12XBrSz04MhQzEbq1": "shrey436@proton.me",
            "44b4NFWyEnSPhCsofxMkbkIP1vt1": "gvrelectrodude@gmail.com",
            "Wtc6hcUIzmORUJxJFc5nJVPgjRE2": "shrey150436@gmail.com",
            "QC8YOG6kCNZTg5QMyIHnXZoJ0cH2": "unknown@example.com",
            "mVXU2RP0DcMktvrK55qBM2fnMGq2": "six7588@gmail.com",
            "umhru1hzQJZa4db0WKHgDtp2qLc2": "six7588@gmail.com" // Added your new UID
        };
        
        // Add any possible spelling variations
        const EMAIL_VARIATIONS = {
            "mjbalkovsk@gmail.com": "mjbalkovski@gmail.com"
        };
        
        // Reverse lookup for emails to IDs (for display only)
        const EMAIL_TO_ID = {};
        for (const [id, email] of Object.entries(KNOWN_USERS)) {
            EMAIL_TO_ID[email.toLowerCase()] = id;
        }
        
        // Add variations to lookup
        for (const [variation, original] of Object.entries(EMAIL_VARIATIONS)) {
            if (EMAIL_TO_ID[original.toLowerCase()]) {
                EMAIL_TO_ID[variation.toLowerCase()] = EMAIL_TO_ID[original.toLowerCase()];
            }
        }
        
        // Cache of username data and info
        const userDataCache = {};
        const usernameToIDMap = new Map();
        
        // Terminal output functions
        function printToTerminal(message, className = '') {
            const line = document.createElement('div');
            line.textContent = message;
            if (className) line.className = className;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        function printSuccess(message) {
            printToTerminal(message, 'success');
        }
        
        function printError(message) {
            printToTerminal(message, 'error');
        }
        
        function printInfo(message) {
            printToTerminal(message, 'info');
        }
        
        function printWarning(message) {
            printToTerminal(message, 'warning');
        }
        
        // Initialize admin console
        async function initConsole(userEmail, userId) {
            printToTerminal('Void Network Admin Console v2.0');
            printToTerminal('----------------------------------');
            printToTerminal('Available commands:');
            printToTerminal('help - Show available commands');
            printToTerminal('list users - List all known users');
            printToTerminal('<user ID> - Look up user by ID');
            printToTerminal('<email> - Look up user by email');
            printToTerminal('<username> - Look up user by username');
            printToTerminal('<user ID/email> coin amount - Check coins');
            printToTerminal('<user ID/email> add coins <amount> - Add coins');
            printToTerminal('<user ID/email> remove coins <amount> - Remove coins');
            printToTerminal('kick <email> - Delete account and user data');
            printToTerminal('/maxcoins - Show top 3 users with most coins');
            printToTerminal('search <query> - Search for users by partial username');
            printToTerminal('refresh users - Check for new users and update database');
            printToTerminal('refresh cache - Force reload all user data');
            printToTerminal('----------------------------------');
            printSuccess(`Authenticated as admin: ${userEmail}`);
            printInfo(`Your user ID: ${userId}`);
            printInfo(`Session expires in: 30 minutes`);
            printInfo('Ready for commands.');
            
            // Start session timeout
            sessionStartTime = Date.now();
            startSessionTimer();
            
            // Force full database load on startup
            await forceFullDatabaseLoad();
        }
        
        // Session timeout management
        function startSessionTimer() {
            // Check session timeout every minute
            const interval = setInterval(() => {
                const elapsedTime = Date.now() - sessionStartTime;
                const remainingMinutes = Math.ceil((SESSION_TIMEOUT - elapsedTime) / 60000);
                
                if (elapsedTime >= SESSION_TIMEOUT) {
                    clearInterval(interval);
                    printWarning("Session expired. Please login again.");
                    logoutUser();
                } else if (remainingMinutes <= 5) {
                    // Warning when 5 minutes or less remaining
                    printWarning(`Session expires in ${remainingMinutes} minute(s). Please save your work.`);
                }
            }, 60000);
            
            // Store the interval ID so we can clear it on logout
            window._sessionTimerInterval = interval;
        }
        
        async function logoutUser() {
            try {
                // Clear the session timer
                if (window._sessionTimerInterval) {
                    clearInterval(window._sessionTimerInterval);
                }
                
                // Reset security token
                securityAccessToken = "";
                
                // Hide admin console, show login form
                adminConsole.classList.add('hidden');
                loginForm.classList.remove('hidden');
                
                // Clear terminal
                terminal.innerHTML = '';
                
                // Sign out from Firebase Auth
                await signOut(auth);
                
                // Clear sensitive data
                Object.keys(userDataCache).forEach(key => delete userDataCache[key]);
                usernameToIDMap.clear();
                
                printSuccess("You have been logged out successfully.");
            } catch (error) {
                console.error("Logout error:", error);
            }
        }
        
        // Login button event
        loginButton.addEventListener('click', async () => {
            await attemptLogin();
        });
        
        // Secure login function
        async function attemptLogin() {
            const email = emailInput.value.trim();
            const password = passwordInput.value;
            
            if (!email || !password) {
                showLoginMessage('Please enter both email and password', true);
                return;
            }
            
            try {
                showLoginMessage('Authenticating...', false);
                
                // Try to sign in with Firebase Authentication
                await signInWithEmailAndPassword(auth, email, password);
                // Auth state change will be handled by onAuthStateChanged
                
            } catch (error) {
                console.error("Login error:", error);
                
                // Add delays to prevent brute force
                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));
                
                // Provide generic error message for security
                showLoginMessage(`Login failed: Invalid credentials`, true);
                
                // Log failed attempt (could be extended to track and block IP after multiple failures)
                try {
                    const logFailedLogin = httpsCallable(functions, 'logFailedLoginAttempt');
                    await logFailedLogin({ email: email });
                } catch (loggingError) {
                    // Silent fail - don't expose if this call fails
                }
            }
        }
        
        // Show login message
        function showLoginMessage(message, isError) {
            loginMessage.textContent = message;
            loginMessage.className = isError ? 'error' : 'info';
            loginMessage.classList.remove('hidden');
        }
        
        // Handle authentication state changes
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                // Check if user email matches the admin email - using the protected getter
                if (user.email.toLowerCase() !== window._voidAdminUser.toLowerCase()) {
                    showLoginMessage('Access denied: Only ADMIN can access this console', true);
                    await signOut(auth);
                    return;
                }
                
                // Additional verification: Check if user ID is in the known users list
                if (!Object.keys(KNOWN_USERS).includes(user.uid)) {
                    // Log the unknown ID but don't expose it in the UI for security
                    console.error("Unknown UID attempted login:", user.uid);
                    showLoginMessage('Access denied: Your account is not authorized', true);
                    await signOut(auth);
                    return;
                }
                
                try {
                    // Generate a simple security token for this session
                    securityAccessToken = "secure_" + Date.now() + "_" + Math.random().toString(36).substring(2);
                    
                    // Show admin console
                    loginForm.classList.add('hidden');
                    adminConsole.classList.remove('hidden');
                    
                    // Initialize the admin console
                    await initConsole(user.email, user.uid);
                } catch (error) {
                    console.error("Login error:", error);
                    showLoginMessage('Error initializing session. Please try again.', true);
                    await signOut(auth);
                }
            }
        });
        
        // Function to refresh user data - With additional security checks
        async function refreshUserData() {
            printInfo("Refreshing user data...");
            
            if (!securityAccessToken || !auth.currentUser) {
                printError("Security validation failed. Please login again.");
                await logoutUser();
                return;
            }
            
            // Verify again that the current user is still the admin
            if (auth.currentUser.email.toLowerCase() !== window._voidAdminUser.toLowerCase()) {
                printError("Security violation detected: User is not authorized.");
                await logoutUser();
                return;
            }
            
            try {
                // Check each known user and create documents if needed
                let created = 0;
                let updated = 0;
                
                // Security check: verify the session before proceeding
                if (Date.now() - sessionStartTime > SESSION_TIMEOUT) {
                    printError("Session expired. Please login again.");
                    await logoutUser();
                    return;
                }
                
                for (const [userId, email] of Object.entries(KNOWN_USERS)) {
                    try {
                        const userRef = doc(db, 'users', userId);
                        const userDoc = await getDoc(userRef);
                        
                        if (!userDoc.exists()) {
                            // Create a new user document
                            await setDoc(userRef, {
                                email: email,
                                accountBalance: 0,
                                createdAt: serverTimestamp(),
                                totalGamesPlayed: 0,
                                totalMoneyEarned: 0,
                                totalMoneySpent: 0
                            });
                            
                            created++;
                            printInfo(`Created user document for ${email} (${userId})`);
                        } else {
                            // Make sure the email field is up to date
                            const userData = userDoc.data();
                            if (!userData.email) {
                                await updateDoc(userRef, { email: email });
                                updated++;
                            }
                        }
                        
                        // Update the cache
                        const updatedUserDoc = await getDoc(userRef);
                        userDataCache[userId] = updatedUserDoc.data();
                        
                        // Map username if available
                        if (userDataCache[userId].username) {
                            usernameToIDMap.set(userDataCache[userId].username.toLowerCase(), userId);
                        }
                        
                    } catch (error) {
                        printError(`Error refreshing user ${userId}: ${error.message}`);
                    }
                }
                
                printSuccess(`Refresh complete. Created ${created} user documents, updated ${updated} users.`);
            } catch (error) {
                printError(`Error refreshing user data: ${error.message}`);
                
                // Check if this might be a security issue
                if (error.message.includes("permission") || error.message.includes("unauthorized")) {
                    printWarning("Possible security issue detected. Refreshing session...");
                    
                    // Try to refresh the auth session
                    if (auth.currentUser) {
                        try {
                            await auth.currentUser.getIdToken(true);
                            printInfo("Session refreshed successfully.");
                        } catch (tokenError) {
                            printError("Could not refresh session. Please login again.");
                            await logoutUser();
                        }
                    } else {
                        await logoutUser();
                    }
                }
            }
        }
        
        // Force a complete reload of all user data - with server validation
        async function forceFullDatabaseLoad() {
            printInfo("ðŸ”„ Performing full database reload...");
            
            if (!securityAccessToken) {
                printError("Security token missing. Please login again.");
                return;
            }
            
            try {
                // Use a Cloud Function to load all data securely
                const loadAllData = httpsCallable(functions, 'adminLoadAllData');
                const result = await loadAllData({ token: securityAccessToken });
                
                if (result.data && result.data.success) {
                    // Clear existing caches
                    Object.keys(userDataCache).forEach(key => delete userDataCache[key]);
                    usernameToIDMap.clear();
                    
                    // Populate with returned data
                    if (result.data.users) {
                        result.data.users.forEach(user => {
                            userDataCache[user.id] = user.data;
                            
                            if (user.data.username) {
                                usernameToIDMap.set(user.data.username.toLowerCase(), user.id);
                            }
                        });
                        
                        printSuccess(`âœ… Successfully loaded all ${result.data.users.length} users`);
                        printInfo(`Username map now contains ${usernameToIDMap.size} usernames`);
                        
                        // Display special username info
                        if (result.data.specialUsers) {
                            printInfo("Special usernames found:");
                            result.data.specialUsers.forEach(special => {
                                printSuccess(`âœ… "${special.username}" is mapped to user ID: ${special.id}`);
                            });
                        }
                    }
                    
                    printSuccess("Full database reload complete!");
                } else {
                    printError("Failed to load database data");
                }
            } catch (error) {
                printError(`Error during full database reload: ${error.message}`);
                
                // If security token is invalid, force logout
                if (error.message.includes("token") || error.message.includes("unauthorized")) {
                    printWarning("Session may have expired. Please login again.");
                    await logoutUser();
                }
            }
        }
        
        // Process command input
        commandInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const command = commandInput.value.trim();
                printToTerminal(`> ${command}`);
                commandInput.value = '';
                
                try {
                    await processCommand(command);
                    
                    // Reset session timer on activity
                    sessionStartTime = Date.now();
                } catch (error) {
                    printError(`Command error: ${error.message}`);
                    
                    // If security token is invalid, force logout
                    if (error.message.includes("token") || error.message.includes("unauthorized")) {
                        printWarning("Session may have expired. Please login again.");
                        await logoutUser();
                    }
                }
            }
        });
        
        // Process commands
        async function processCommand(command) {
            // Check for valid session
            if (!securityAccessToken || Date.now() - sessionStartTime > SESSION_TIMEOUT) {
                printError("Session expired. Please login again.");
                await logoutUser();
                return;
            }
            
            // Help command
            if (command.toLowerCase() === 'help') {
                printInfo('Available commands:');
                printInfo('help - Show this help information');
                printInfo('list users - List all known users');
                printInfo('<user ID> - Look up user by ID');
                printInfo('<email> - Look up user by email');
                printInfo('<username> - Look up user by username');
                printInfo('<user ID/email> coin amount - Check coins');
                printInfo('<user ID/email> add coins <amount> - Add coins');
                printInfo('<user ID/email> remove coins <amount> - Remove coins');
                printInfo('kick <email> - Delete account and user data');
                printInfo('/maxcoins - Show top 3 users with most coins');
                printInfo('search <query> - Search for users by partial username');
                printInfo('me - Show your own user ID (for reference)');
                printInfo('refresh users - Check for new users and update database');
                printInfo('refresh cache - Force reload all user data');
                printInfo('logout - End your session and return to login screen');
                return;
            }
            
            // Logout command
            if (command.toLowerCase() === 'logout') {
                await logoutUser();
                return;
            }
            
            // Refresh users command
            if (command.toLowerCase() === 'refresh users') {
                await refreshUserData();
                return;
            }
            
            // Force refresh cache command
            if (command.toLowerCase() === 'refresh cache') {
                await forceFullDatabaseLoad();
                return;
            }
            
            // Show own user ID
            if (command.toLowerCase() === 'me') {
                const currentUser = auth.currentUser;
                if (currentUser) {
                    printInfo(`Your user ID: ${currentUser.uid}`);
                    printInfo(`Your email: ${currentUser.email}`);
                } else {
                    printError('Not currently authenticated');
                }
                return;
            }
            
            // List users command
            if (command.toLowerCase() === 'list users') {
                // Use server function for security
                try {
                    const listUsers = httpsCallable(functions, 'adminListUsers');
                    const result = await listUsers({ token: securityAccessToken });
                    
                    if (result.data && result.data.success) {
                        printInfo('Known Users:');
                        result.data.users.forEach(user => {
                            let userInfo = `${user.email} (ID: ${user.id})`;
                            
                            if (user.username) {
                                userInfo += ` | Username: ${user.username}`;
                            }
                            
                            printInfo(userInfo);
                        });
                    } else {
                        printError("Failed to list users");
                    }
                } catch (error) {
                    printError(`Error listing users: ${error.message}`);
                    
                    // Fall back to local cache if server call fails
                    printWarning("Falling back to cached user data...");
                    
                    printInfo('Known Users (from cache):');
                    for (const [userId, email] of Object.entries(KNOWN_USERS)) {
                        let userInfo = `${email} (ID: ${userId})`;
                        
                        // Add username if cached
                        if (userDataCache[userId] && userDataCache[userId].username) {
                            userInfo += ` | Username: ${userDataCache[userId].username}`;
                        }
                        
                        printInfo(userInfo);
                    }
                }
                return;
            }
            
            // Max coins command
            if (command.toLowerCase() === '/maxcoins') {
                await findUsersWithMostCoins();
                return;
            }
            
            // Search command
            if (command.toLowerCase().startsWith('search ')) {
                const searchQuery = command.substring(7).trim().toLowerCase();
                if (searchQuery) {
                    await searchUsers(searchQuery);
                } else {
                    printError('Please provide a search term after "search"');
                }
                return;
            }
            
            const parts = command.split(' ');
            
            // Kick command
            if (parts.length >= 2 && parts[0].toLowerCase() === 'kick') {
                const targetEmail = parts[1].toLowerCase();
                await kickUser(targetEmail);
                return;
            }
            
            // Check if command is for checking coins
            if (parts.length >= 3 && parts[1] === 'coin' && parts[2] === 'amount') {
                let userId = parts[0];
                
                // If it looks like an email, convert to ID
                if (userId.includes('@')) {
                    const email = userId.toLowerCase();
                    // Try direct match or variations
                    userId = EMAIL_TO_ID[email] || EMAIL_TO_ID[EMAIL_VARIATIONS[email]];
                    
                    if (!userId) {
                        printError(`No user ID found for email: ${parts[0]}`);
                        return;
                    }
                }
                
                try {
                    await displayUserCoins(userId);
                } catch (error) {
                    printError(`Error checking user coins: ${error.message}`);
                }
            }
            // Check if command is for adding coins
            else if (parts.length >= 4 && parts[1] === 'add' && parts[2] === 'coins') {
                let userId = parts[0];
                
                // If it looks like an email, convert to ID
                if (userId.includes('@')) {
                    const email = userId.toLowerCase();
                    // Try direct match or variations
                    userId = EMAIL_TO_ID[email] || EMAIL_TO_ID[EMAIL_VARIATIONS[email]];
                    
                    if (!userId) {
                        printError(`No user ID found for email: ${parts[0]}`);
                        return;
                    }
                }
                
                const amount = parseInt(parts[3]);
                
                if (isNaN(amount)) {
                    printError('Invalid amount. Please provide a number.');
                    return;
                }
                
                try {
                    await addCoinsToUser(userId, amount);
                } catch (error) {
                    printError(`Error adding coins: ${error.message}`);
                }
            }
            // Check if command is for removing coins
            else if (parts.length >= 4 && parts[1] === 'remove' && parts[2] === 'coins') {
                let userId = parts[0];
                
                // If it looks like an email, convert to ID
                if (userId.includes('@')) {
                    const email = userId.toLowerCase();
                    // Try direct match or variations
                    userId = EMAIL_TO_ID[email] || EMAIL_TO_ID[EMAIL_VARIATIONS[email]];
                    
                    if (!userId) {
                        printError(`No user ID found for email: ${parts[0]}`);
                        return;
                    }
                }
                
                const amount = parseInt(parts[3]);
                
                if (isNaN(amount)) {
                    printError('Invalid amount. Please provide a number.');
                    return;
                }
                
                if (amount <= 0) {
                    printError('Amount to remove must be positive.');
                    return;
                }
                
                try {
                    await removeCoinsFromUser(userId, amount);
                } catch (error) {
                    printError(`Error removing coins: ${error.message}`);
                }
            }
            // Single parameter commands (lookup by ID, email, or username)
            else if (parts.length === 1) {
                const lookup = parts[0];
                
                // Special case for 'FreeMoolah' - handle with server validation
                if (lookup.toLowerCase() === 'freemoolah') {
                    printInfo(`ðŸ” Special handling for FreeMoolah username...`);
                    
                    try {
                        const findSpecialUser = httpsCallable(functions, 'adminFindSpecialUser');
                        const result = await findSpecialUser({ 
                            token: securityAccessToken,
                            username: 'freemoolah'
                        });
                        
                        if (result.data && result.data.success && result.data.user) {
                            printSuccess(`âœ… Found user with username: FreeMoolah`);
                            printInfo(`User ID: ${result.data.user.id}`);
                            
                            // Update cache
                            userDataCache[result.data.user.id] = result.data.user.data;
                            usernameToIDMap.set('freemoolah', result.data.user.id);
                            
                            await displayUserInfo(result.data.user.id);
                        } else {
                            printError("Could not find FreeMoolah user");
                        }
                    } catch (error) {
                        printError(`Error finding FreeMoolah user: ${error.message}`);
                        
                        // Try fallback to cache
                        let foundUserId = usernameToIDMap.get('freemoolah');
                        
                        if (foundUserId && userDataCache[foundUserId]) {
                            printWarning(`Falling back to cached data for FreeMoolah...`);
                            await displayUserInfo(foundUserId);
                        }
                    }
                    
                    return;
                }
                
                // Determine the type of lookup
                if (lookup.includes('@')) {
                    // Email lookup
                    const email = lookup.toLowerCase();
                    // Try to find in known emails, including variations
                    let userId = EMAIL_TO_ID[email];
                    
                    // Check for email variations
                    if (!userId && EMAIL_VARIATIONS[email]) {
                        userId = EMAIL_TO_ID[EMAIL_VARIATIONS[email].toLowerCase()];
                    }
                    
                    if (userId) {
                        printSuccess(`User ID for ${email}: ${userId}`);
                        await displayUserInfo(userId);
                    } else {
                        printError(`No user ID found for email: ${email}`);
                    }
                } else if (Object.keys(KNOWN_USERS).includes(lookup)) {
                    // User ID lookup
                    printSuccess(`Looking up info for user ID: ${lookup}`);
                    await displayUserInfo(lookup);
                } else {
                    // Try username lookup
                    await lookupUserByUsername(lookup);
                }
            }
            else {
                printError('Invalid command. Type "help" for available commands.');
            }
        }
        
        // Search users with server validation
        async function searchUsers(query) {
            try {
                printInfo(`ðŸ” Searching for users matching: "${query}"...`);
                
                // Use server function for search
                const searchForUsers = httpsCallable(functions, 'adminSearchUsers');
                const result = await searchForUsers({ 
                    token: securityAccessToken,
                    query: query
                });
                
                if (result.data && result.data.success) {
                    if (result.data.users && result.data.users.length > 0) {
                        printSuccess(`âœ… Found ${result.data.users.length} user(s) matching "${query}":`);
                        
                        result.data.users.forEach((user, index) => {
                            printInfo(`${index + 1}. ${user.username || 'No Username'} (${user.email || 'Unknown'}) - ID: ${user.id} [${user.matchReason}]`);
                            
                            // Update cache
                            userDataCache[user.id] = user.data;
                            if (user.data && user.data.username) {
                                usernameToIDMap.set(user.data.username.toLowerCase(), user.id);
                            }
                        });
                        
                        printInfo(`Use the username or ID to see full details.`);
                        
                        // If we found more than 1 result but less than 5, show the first one details automatically
                        if (result.data.users.length > 0 && result.data.users.length < 5) {
                            const firstResult = result.data.users[0];
                            printInfo(`Showing details for the first match:`);
                            await displayUserInfo(firstResult.id);
                        }
                    } else {
                        printWarning(`âš ï¸ No users found matching "${query}".`);
                    }
                } else {
                    printError("Search failed");
                }
            } catch (error) {
                printError(`Search error: ${error.message}`);
                
                // Fallback to cache search if server function fails
                printWarning("Falling back to cached data for search...");
                searchUsersByCache(query);
            }
        }
        
        // Fallback search using local cache
        function searchUsersByCache(query) {
            const results = [];
            const lowerQuery = query.toLowerCase();
            
            printInfo(`Searching cached data (${Object.keys(userDataCache).length} users)...`);
            
            for (const [userId, userData] of Object.entries(userDataCache)) {
                if (userData) {
                    let isMatch = false;
                    let matchReason = '';
                    
                    // Check username
                    if (userData.username) {
                        const username = userData.username.toLowerCase();
                        if (username.includes(lowerQuery) || lowerQuery.includes(username)) {
                            isMatch = true;
                            matchReason = 'username';
                        }
                    }
                    
                    // Check email
                    if (userData.email) {
                        const email = userData.email.toLowerCase();
                        if (email.includes(lowerQuery)) {
                            isMatch = true;
                            matchReason = 'email';
                        }
                    }
                    
                    if (isMatch) {
                        results.push({
                            userId,
                            username: userData.username || "No Username",
                            email: userData.email || KNOWN_USERS[userId] || "Unknown",
                            matchReason
                        });
                    }
                }
            }
            
            // Display results
            if (results.length > 0) {
                printSuccess(`âœ… Found ${results.length} user(s) matching "${query}" in cache:`);
                
                results.forEach((result, index) => {
                    printInfo(`${index + 1}. ${result.username} (${result.email}) - ID: ${result.userId} [${result.matchReason}]`);
                });
                
                printInfo(`Use the username or ID to see full details.`);
                
                // Show first result if there are few
                if (results.length < 5) {
                    const firstResult = results[0];
                    printInfo(`Showing details for the first match:`);
                    displayUserInfo(firstResult.userId);
                }
            } else {
                printWarning(`âš ï¸ No users found matching "${query}" in cache.`);
                printInfo(`Try 'refresh cache' to load all data and search again.`);
            }
        }
        
        // Lookup user by username with server validation
        async function lookupUserByUsername(username) {
            try {
                const lookupUsername = httpsCallable(functions, 'adminLookupUsername');
                const result = await lookupUsername({ 
                    token: securityAccessToken,
                    username: username
                });
                
                if (result.data && result.data.success && result.data.user) {
                    printSuccess(`Found user with username: ${username}`);
                    printInfo(`User ID: ${result.data.user.id}`);
                    
                    // Update cache
                    userDataCache[result.data.user.id] = result.data.user.data;
                    usernameToIDMap.set(username.toLowerCase(), result.data.user.id);
                    
                    await displayUserInfo(result.data.user.id);
                } else {
                    // Fallback to cache
                    lookupUserByUsernameInCache(username);
                }
            } catch (error) {
                printError(`Lookup error: ${error.message}`);
                // Fallback to cache
                lookupUserByUsernameInCache(username);
            }
        }
        
        // Fallback lookup using local cache
        function lookupUserByUsernameInCache(username) {
            const lowercaseLookup = username.toLowerCase();
            const userId = usernameToIDMap.get(lowercaseLookup);
            
            if (userId) {
                printSuccess(`Found user with username: ${username} (from cache)`);
                printInfo(`User ID: ${userId}`);
                displayUserInfo(userId);
                return true;
            }
            
            // Try fuzzy search in cache
            let bestMatch = null;
            let bestMatchId = null;
            
            for (const [userId, userData] of Object.entries(userDataCache)) {
                if (userData && userData.username) {
                    const usernameInCache = userData.username.toLowerCase();
                    if (usernameInCache.includes(lowercaseLookup) || 
                        lowercaseLookup.includes(usernameInCache)) {
                        // Simple partial match
                        bestMatch = userData.username;
                        bestMatchId = userId;
                        break;
                    }
                }
            }
            
            if (bestMatch && bestMatchId) {
                printSuccess(`Found similar username: ${bestMatch} (from cache)`);
                printInfo(`User ID: ${bestMatchId}`);
                displayUserInfo(bestMatchId);
                return true;
            }
            
            // Try ID lookup as last resort
            try {
                if (userDataCache[username]) {
                    printSuccess(`Found user with ID: ${username} (from cache)`);
                    displayUserInfo(username);
                    return true;
                }
            } catch (e) {
                // Not found as ID either
            }
            
            printError(`No user found with ID, email, or username: ${username}`);
            printInfo(`Try 'search ${username}' for partial matches.`);
            return false;
        }
        
        // Display user info with server validation
        async function displayUserInfo(userId) {
            try {
                const getUserInfo = httpsCallable(functions, 'adminGetUserInfo');
                const result = await getUserInfo({ 
                    token: securityAccessToken,
                    userId: userId
                });
                
                if (result.data && result.data.success && result.data.user) {
                    const userData = result.data.user;
                    
                    // Update cache
                    userDataCache[userId] = userData;
                    if (userData.username) {
                        usernameToIDMap.set(userData.username.toLowerCase(), userId);
                    }
                    
                    // Display core information
                    if (userData.email) {
                        printInfo(`Email: ${userData.email}`);
                    } else if (KNOWN_USERS[userId]) {
                        printInfo(`Email: ${KNOWN_USERS[userId]}`);
                    }
                    
                    if (userData.username) {
                        printInfo(`Username: ${userData.username}`);
                    } else {
                        printInfo(`Username: Not set`);
                    }
                    
                    // Financial information
                    printInfo(`Account Balance: ${userData.accountBalance || 0} coins`);
                    
                    // Game statistics
                    if (userData.totalGamesPlayed) {
                        printInfo(`Total Games Played: ${userData.totalGamesPlayed}`);
                    }
                    
                    if (userData.totalMoneySpent) {
                        printInfo(`Total Money Spent: ${userData.totalMoneySpent}`);
                    }
                    
                    if (userData.totalMoneyEarned) {
                        printInfo(`Total Money Earned: ${userData.totalMoneyEarned}`);
                    }
                    
                    // Account information
                    if (userData.createdAt) {
                        // Format date
                        let dateStr = userData.createdAt;
                        if (typeof dateStr === 'object' && dateStr.seconds) {
                            // Handle Firestore timestamp
                            dateStr = new Date(dateStr.seconds * 1000).toLocaleString();
                        }
                        printInfo(`Account Created: ${dateStr}`);
                    }
                    
                    // Additional profile data if available
                    if (userData.displayName) {
                        printInfo(`Display Name: ${userData.displayName}`);
                    }
                    
                    // Show any additional fields (exclude common fields)
                    const standardFields = [
                        'email', 'username', 'accountBalance', 'totalGamesPlayed', 
                        'totalMoneySpent', 'totalMoneyEarned', 'createdAt',
                        'displayName', 'photoURL', 'uid'
                    ];
                    
                    const extraFields = Object.keys(userData).filter(key => !standardFields.includes(key));
                    if (extraFields.length > 0) {
                        printInfo('Additional User Data:');
                        for (const field of extraFields) {
                            let value = userData[field];
                            if (value && typeof value === 'object') {
                                value = JSON.stringify(value);
                            }
                            printInfo(`- ${field}: ${value}`);
                        }
                    }
                } else {
                    // Fallback to cache
                    displayUserInfoFromCache(userId);
                }
            } catch (error) {
                printError(`Error getting user info: ${error.message}`);
                // Fallback to cache
                displayUserInfoFromCache(userId);
            }
        }
        
        // Fallback display user info from cache
        function displayUserInfoFromCache(userId) {
            printWarning("Using cached data for user info...");
            
            try {
                const userData = userDataCache[userId];
                
                if (!userData) {
                    printError("No cached data available for this user");
                    return;
                }
                
                // Display cached user information
                if (userData.email) {
                    printInfo(`Email: ${userData.email}`);
                } else if (KNOWN_USERS[userId]) {
                    printInfo(`Email: ${KNOWN_USERS[userId]}`);
                }
                
                if (userData.username) {
                    printInfo(`Username: ${userData.username}`);
                } else {
                    printInfo(`Username: Not set`);
                }
                
                // Financial information
                printInfo(`Account Balance: ${userData.accountBalance || 0} coins`);
                
                // Game statistics
                if (userData.totalGamesPlayed) {
                    printInfo(`Total Games Played: ${userData.totalGamesPlayed}`);
                }
                
                if (userData.totalMoneySpent) {
                    printInfo(`Total Money Spent: ${userData.totalMoneySpent}`);
                }
                
                if (userData.totalMoneyEarned) {
                    printInfo(`Total Money Earned: ${userData.totalMoneyEarned}`);
                }
                
                // Account information
                if (userData.createdAt) {
                    let dateStr = userData.createdAt;
                    if (userData.createdAt.toDate) {
                        dateStr = userData.createdAt.toDate().toLocaleString();
                    }
                    printInfo(`Account Created: ${dateStr}`);
                }
                
                // Additional fields
                const standardFields = [
                    'email', 'username', 'accountBalance', 'totalGamesPlayed', 
                    'totalMoneySpent', 'totalMoneyEarned', 'createdAt',
                    'displayName', 'photoURL', 'uid'
                ];
                
                const extraFields = Object.keys(userData).filter(key => !standardFields.includes(key));
                if (extraFields.length > 0) {
                    printInfo('Additional User Data (Cached):');
                    for (const field of extraFields) {
                        let value = userData[field];
                        if (value && typeof value === 'object') {
                            if (value.toDate) {
                                value = value.toDate().toLocaleString();
                            } else {
                                value = JSON.stringify(value);
                            }
                        }
                        printInfo(`- ${field}: ${value}`);
                    }
                }
            } catch (error) {
                printError(`Error displaying cached user info: ${error.message}`);
            }
        }
        
        // Display user coins with server validation
        async function displayUserCoins(userId) {
            try {
                const getUserCoins = httpsCallable(functions, 'adminGetUserCoins');
                const result = await getUserCoins({ 
                    token: securityAccessToken,
                    userId: userId
                });
                
                if (result.data && result.data.success) {
                    // Display user's information
                    printSuccess(`User with ID ${userId} has ${result.data.coins || 0} coins.`);
                    
                    if (result.data.email) {
                        printInfo(`User email: ${result.data.email}`);
                    } else if (KNOWN_USERS[userId]) {
                        printInfo(`User email: ${KNOWN_USERS[userId]}`);
                    }
                    
                    if (result.data.username) {
                        printInfo(`Username: ${result.data.username}`);
                    }
                } else {
                    printError("Failed to get user coins");
                    // Try fallback to cached data
                    const userData = userDataCache[userId];
                    if (userData) {
                        printWarning("Using cached data...");
                        printSuccess(`User with ID ${userId} has ${userData.accountBalance || 0} coins (cached).`);
                        
                        if (userData.email) {
                            printInfo(`User email: ${userData.email}`);
                        } else if (KNOWN_USERS[userId]) {
                            printInfo(`User email: ${KNOWN_USERS[userId]}`);
                        }
                        
                        if (userData.username) {
                            printInfo(`Username: ${userData.username}`);
                        }
                    }
                }
            } catch (error) {
                printError(`Error checking user coins: ${error.message}`);
            }
        }
        
        // Add coins to user with server validation
        async function addCoinsToUser(userId, amount) {
            try {
                printInfo(`Adding ${amount} coins to user ID: ${userId}...`);
                
                const modifyCoins = httpsCallable(functions, 'adminModifyUserCoins');
                const result = await modifyCoins({ 
                    token: securityAccessToken,
                    userId: userId,
                    amount: amount,
                    operation: 'add'
                });
                
                if (result.data && result.data.success) {
                    printSuccess(`Successfully added ${amount} coins to user with ID ${userId}.`);
                    printInfo(`New balance: ${result.data.newBalance}`);
                    
                    // Update cache
                    if (userDataCache[userId]) {
                        userDataCache[userId].accountBalance = result.data.newBalance;
                    }
                    
                    return true;
                } else {
                    printError("Failed to add coins: " + (result.data && result.data.error ? result.data.error : "Unknown error"));
                    return false;
                }
            } catch (error) {
                printError(`Error adding coins: ${error.message}`);
                throw error;
            }
        }
        
        // Remove coins from user with server validation
        async function removeCoinsFromUser(userId, amount) {
            try {
                printInfo(`Removing ${amount} coins from user ID: ${userId}...`);
                
                const modifyCoins = httpsCallable(functions, 'adminModifyUserCoins');
                const result = await modifyCoins({ 
                    token: securityAccessToken,
                    userId: userId,
                    amount: amount,
                    operation: 'remove'
                });
                
                if (result.data && result.data.success) {
                    printSuccess(`Successfully removed ${amount} coins from user with ID ${userId}.`);
                    printInfo(`New balance: ${result.data.newBalance}`);
                    
                    // Update cache
                    if (userDataCache[userId]) {
                        userDataCache[userId].accountBalance = result.data.newBalance;
                    }
                    
                    return true;
                } else {
                    printError("Failed to remove coins: " + (result.data && result.data.error ? result.data.error : "Unknown error"));
                    return false;
                }
            } catch (error) {
                printError(`Error removing coins: ${error.message}`);
                throw error;
            }
        }
        
        // Kick user with server validation
        async function kickUser(email) {
            try {
                printWarning(`Preparing to kick user with email: ${email}...`);
                
                const kickUserFunction = httpsCallable(functions, 'adminKickUser');
                const result = await kickUserFunction({ 
                    token: securityAccessToken,
                    email: email
                });
                
                if (result.data && result.data.success) {
                    printSuccess(`Successfully kicked user: ${email}`);
                    
                    // Update local cache
                    if (result.data.userId) {
                        // Remove from cache
                        delete userDataCache[result.data.userId];
                        
                        // Remove from username map if exists
                        for (const [username, id] of usernameToIDMap.entries()) {
                            if (id === result.data.userId) {
                                usernameToIDMap.delete(username);
                            }
                        }
                    }
                    
                    return true;
                } else {
                    printError("Failed to kick user: " + (result.data && result.data.error ? result.data.error : "Unknown error"));
                    return false;
                }
            } catch (error) {
                printError(`Error kicking user: ${error.message}`);
                return false;
            }
        }
        
        // Find users with most coins with server validation
        async function findUsersWithMostCoins() {
            try {
                printInfo(`Finding users with the most coins...`);
                
                const getTopUsers = httpsCallable(functions, 'adminGetTopCoinsUsers');
                const result = await getTopUsers({ token: securityAccessToken });
                
                if (result.data && result.data.success && result.data.users) {
                    printSuccess(`Top ${result.data.users.length} users with most coins:`);
                    
                    result.data.users.forEach((user, index) => {
                        printInfo(`${index + 1}. ${user.username || 'No Username'} (${user.email || 'Unknown'}): ${user.coins} coins`);
                        
                        // Update cache
                        if (user.id) {
                            userDataCache[user.id] = user.data;
                            if (user.data && user.data.username) {
                                usernameToIDMap.set(user.data.username.toLowerCase(), user.id);
                            }
                        }
                    });
                } else {
                    printError("Failed to get top users");
                    // Try fallback to cached data
                    fallbackGetTopCoinsUsers();
                }
            } catch (error) {
                printError(`Error finding users with most coins: ${error.message}`);
                // Try fallback to cached data
                fallbackGetTopCoinsUsers();
            }
        }
        
        // Fallback method for finding users with most coins using local cache
        function fallbackGetTopCoinsUsers() {
            try {
                printWarning("Using cached data for top users...");
                
                // Create an array to store user coin data
                const userCoins = [];
                
                for (const [userId, userData] of Object.entries(userDataCache)) {
                    if (userData) {
                        const coins = userData.accountBalance || 0;
                        const username = userData.username || "No Username";
                        const email = userData.email || KNOWN_USERS[userId] || "Unknown";
                        
                        userCoins.push({
                            userId,
                            username,
                            email,
                            coins
                        });
                    }
                }
                
                // Sort by coins (descending)
                userCoins.sort((a, b) => b.coins - a.coins);
                
                // Display top 3 users
                const topUsers = userCoins.slice(0, 3);
                
                if (topUsers.length > 0) {
                    printSuccess(`Top ${topUsers.length} users with most coins (from cache):`);
                    topUsers.forEach((user, index) => {
                        printInfo(`${index + 1}. ${user.username} (${user.email}): ${user.coins} coins`);
                    });
                } else {
                    printWarning(`No user data available in cache.`);
                }
            } catch (error) {
                printError(`Error with cached top users: ${error.message}`);
            }
        }
        
        // Add Enter key support for login form
        emailInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') passwordInput.focus();
        });
        
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loginButton.click();
        });
        
        // Warning if browser support is weak
        if (!window.crypto || !window.crypto.subtle) {
            printWarning("Your browser may not support all security features. Please use a modern browser.");
        }
    </script>
</body>
</html>
