<!DOCTYPE html>
<html lang="en">
<script>
window.onload=function(){document.body.insertAdjacentHTML("beforeend",'<div id="warningPopup" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#ff0000;color:white;padding:25px;z-index:10000;font-family:Arial;max-width:500px;min-width:300px;text-align:center;border:4px solid #990000;box-shadow:0 0 20px rgba(0,0,0,0.5);animation:pulse 2s infinite;border-radius:10px"><h2 style="font-size:28px;margin-top:0;margin-bottom:20px;color:#ffffff;text-shadow:2px 2px 4px rgba(0,0,0,0.5);font-weight:bold">⚠️ WARNING ⚠️</h2><p style="font-size:18px;line-height:1.5;margin-bottom:20px;font-weight:bold;text-shadow:1px 1px 2px rgba(0,0,0,0.3)">Due to high usage Void Games have been rate limited. The games should start working again at around 1AM EST. All data will be reset. This will be the last time all data gets reset.</p></div><div style="position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);z-index:9999"></div>');const e=document.createElement("style");e.innerHTML="@keyframes pulse{0%{box-shadow:0 0 15px rgba(255,0,0,0.7)}50%{box-shadow:0 0 30px rgba(255,0,0,1)}100%{box-shadow:0 0 15px rgba(255,0,0,0.7)}}",document.head.appendChild(e)};
</script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Void Network Games</title>
    <link rel="shortcut icon" href="./assets/favicon.png" type="image/png">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
        }

        .header-container {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 1rem;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }

        #profile-icon {
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease;
        }

        #profile-icon:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #profile-icon svg {
            width: 24px;
            height: 24px;
            fill: #fff;
        }

        #auth-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 30px;
            width: 350px;
            max-width: 90%;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
            text-align: center;
        }

        #auth-container input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        #auth-container input:focus {
            outline: none;
            border-color: #4a4a4a;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }

        #auth-container button {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        #auth-container button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #user-profile {
            text-align: center;
            margin-bottom: 15px;
        }

        #user-profile h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            position: relative;
            z-index: 1;
        }

        .games-box {
            background: #000;
            border-radius: 10px;
            width: 80%;
            max-width: 1000px;
            height: 70vh;
            display: flex;
            flex-direction: column;
            position: relative;
            padding: 2px;
            box-shadow: 
                0 0 2px #fff,
                0 0 4px #fff,
                0 0 6px #fff,
                0 0 8px #fff,
                inset 0 0 2px rgba(255, 255, 255, 0.2);
        }

        .games-box::before {
            content: '';
            position: absolute;
            inset: -1px;
            background: #fff;
            border-radius: 10px;
            z-index: -1;
            box-shadow: 
                0 0 15px #fff,
                0 0 30px rgba(255, 255, 255, 0.8),
                0 0 40px rgba(255, 255, 255, 0.6),
                0 0 50px rgba(255, 255, 255, 0.4);
            opacity: 0.5;
        }

        .games-header {
            padding: 1.5rem;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 1;
        }

        .site-title {
            font-size: 2.5rem;
            margin: 0 0 0.5rem 0;
            background: linear-gradient(45deg, #fff, #a0a0a0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }

        .games-title {
            font-size: 1.2rem;
            margin: 0.5rem 0;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #searchApps {
            width: 80%;
            max-width: 400px;
            padding: 0.8rem 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-size: 1rem;
            transition: all 0.3s ease;
            margin: 1rem auto 0 auto;
            display: block;
        }

        #searchApps:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        #searchApps::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
            padding: 1.5rem;
            overflow-y: auto;
            flex-grow: 1;
            position: relative;
            z-index: 1;
        }

        .games-grid::-webkit-scrollbar {
            width: 8px;
        }

        .games-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            margin: 4px;
            border-radius: 4px;
        }

        .games-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .games-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .game-item {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.8rem;
        }

        .game-icon {
            width: 64px;
            height: 64px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .game-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .game-title {
            font-size: 0.9rem;
            color: #fff;
            margin: 0;
            font-weight: normal;
            transition: all 0.3s ease;
        }

        .game-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .game-item:hover .game-title {
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .network-status {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            display: none;
            z-index: 1000;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-online {
            background-color: #4caf50;
        }

        .status-offline {
            background-color: #f44336;
        }

        .status-rate-limited {
            background-color: #ff9800;
        }

        @media (max-width: 768px) {
            .games-box {
                width: 95%;
                height: 80vh;
            }
            
            .games-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                padding: 1rem;
            }
            
            .game-icon {
                width: 48px;
                height: 48px;
            }
            
            .game-title {
                font-size: 0.8rem;
            }
            
            .site-title {
                font-size: 2rem;
            }

            #auth-container {
                width: 90%;
                max-width: 350px;
            }
        }
    </style>
</head>
<body>
    <!-- Header with Profile Icon -->
    <div class="header-container">
        <div id="profile-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/>
            </svg>
        </div>
    </div>

    <!-- Network Status Indicator -->
    <div id="network-status" class="network-status">
        <span id="status-indicator" class="status-indicator status-online"></span>
        <span id="status-text">Online</span>
    </div>

    <!-- Authentication Container -->
    <div id="auth-container">
        <div id="user-profile" style="display:none;">
            <h3>Welcome, <span id="username-display"></span>!</h3>
            <p>Coins: <span id="balance-display">0</span></p>
            <button id="logout-btn">Logout</button>
        </div>

        <div id="login-form">
            <h3>Login</h3>
            <input type="email" id="login-email" placeholder="Email">
            <input type="password" id="login-password" placeholder="Password">
            <button id="login-btn">Login</button>
        </div>
        
        <div id="register-form">
            <h3>Register</h3>
            <input type="text" id="register-username" placeholder="Username">
            <input type="email" id="register-email" placeholder="Email">
            <input type="password" id="register-password" placeholder="Password">
            <button id="register-btn">Register</button>
        </div>
    </div>

    <div class="container">
        <div class="games-box">
            <div class="games-header">
                <h1 class="site-title">Void Network</h1>
                <h2 class="games-title">Void Games</h2>
                <input type="text" id="searchApps" placeholder="Search void games...">
            </div>
            <div class="games-grid" id="gamesList"></div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-analytics.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            onAuthStateChanged,
            deleteUser 
        } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            doc, 
            setDoc, 
            updateDoc, 
            getDoc, 
            query, 
            where, 
            getDocs, 
            runTransaction, 
            serverTimestamp,
            deleteDoc,
            writeBatch,
            enableIndexedDbPersistence,
            onSnapshotsInSync
        } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore.js";

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCkAp_GCGCtw4zv7GgHJOE9GPgIaPEuOvQ",
            authDomain: "void-games-c8d9e.firebaseapp.com",
            projectId: "void-games-c8d9e",
            storageBucket: "void-games-c8d9e.firebasestorage.app",
            messagingSenderId: "1063089929776",
            appId: "1:1063089929776:web:8e226a23a4f3ab9c5777f5"
        };

        // ======== Enhanced Cache Manager ========
        const cacheManager = {
            set: function(key, data, expirationMinutes = 60) {
                try {
                    const item = {
                        data: data,
                        timestamp: Date.now(),
                        expiration: Date.now() + (expirationMinutes * 60 * 1000)
                    };
                    localStorage.setItem(key, JSON.stringify(item));
                    return true;
                } catch (error) {
                    console.warn("Cache write failed:", error);
                    return false;
                }
            },
            
            get: function(key, maxAgeMinutes = null) {
                try {
                    const item = localStorage.getItem(key);
                    if (!item) return null;
                    
                    const parsed = JSON.parse(item);
                    
                    // Check if cache has expired
                    if (maxAgeMinutes) {
                        const maxAge = maxAgeMinutes * 60 * 1000;
                        if (Date.now() - parsed.timestamp > maxAge) {
                            return null;
                        }
                    } else if (parsed.expiration && Date.now() > parsed.expiration) {
                        return null;
                    }
                    
                    return parsed.data;
                } catch (error) {
                    console.warn("Cache read failed:", error);
                    return null;
                }
            },
            
            remove: function(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (error) {
                    console.warn("Cache removal failed:", error);
                    return false;
                }
            },
            
            clearExpired: function() {
                try {
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        // Only check our cache items
                        if (key.startsWith('cache:')) {
                            this.get(key); // This will check expiration
                        }
                    }
                } catch (error) {
                    console.warn("Cache cleanup failed:", error);
                }
            }
        };

        // ======== Batch Operation Manager ========
        const batchManager = {
            operations: [],
            timeoutId: null,
            batchSize: 20, // Maximum operations per batch
            
            add: function(operation) {
                this.operations.push(operation);
                
                // If we have enough operations or this is a high-priority one, process immediately
                if (this.operations.length >= this.batchSize || operation.priority === 'high') {
                    this.processNow();
                } else if (!this.timeoutId) {
                    // Otherwise set a timer to process soon
                    this.timeoutId = setTimeout(() => this.processNow(), 3000);
                }
            },
            
            processNow: async function() {
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
                
                if (this.operations.length === 0) return;
                
                console.log(`Processing batch of ${this.operations.length} operations`);
                
                // Group operations by type to optimize processing
                const batches = {};
                const toProcess = [...this.operations];
                this.operations = [];
                
                // Group by batch key
                toProcess.forEach(op => {
                    const key = op.batchKey || 'default';
                    if (!batches[key]) batches[key] = [];
                    batches[key].push(op);
                });
                
                // Process each batch group
                for (const [key, ops] of Object.entries(batches)) {
                    if (!navigator.onLine) {
                        // If offline, queue all operations for later
                        ops.forEach(op => pendingTransactions.add(op.data));
                        continue;
                    }
                    
                    try {
                        if (ops.length === 1 && ops[0].singleFunction) {
                            // If there's just one operation with a custom function, call it directly
                            await ops[0].singleFunction();
                        } else {
                            // Process as a batch using the provided batch processor
                            const batchOps = ops.map(op => ({
                                type: op.type,
                                ref: op.ref,
                                data: op.data
                            }));
                            
                            await voidAccounting.processBatchedOperations(batchOps);
                        }
                    } catch (error) {
                        console.error("Batch processing error:", error);
                        
                        if (error.code === 'resource-exhausted') {
                            rateLimitTracker.markRateLimited();
                            
                            // Queue operations for later retry
                            ops.forEach(op => pendingTransactions.add(op.data));
                        }
                    }
                }
            }
        };

        // ======== Network Status Tracking ========
        const networkStatus = {
            isOnline: navigator.onLine,
            isRateLimited: false,
            statusElement: document.getElementById('network-status'),
            indicatorElement: document.getElementById('status-indicator'),
            textElement: document.getElementById('status-text'),
            
            updateStatus() {
                this.statusElement.style.display = 'block';
                
                if (!this.isOnline) {
                    this.indicatorElement.className = 'status-indicator status-offline';
                    this.textElement.textContent = 'Offline Mode';
                } else if (this.isRateLimited) {
                    this.indicatorElement.className = 'status-indicator status-rate-limited';
                    this.textElement.textContent = 'Rate Limited';
                } else {
                    this.indicatorElement.className = 'status-indicator status-online';
                    this.textElement.textContent = 'Online';
                    
                    // Hide after 5 seconds if everything is normal
                    setTimeout(() => {
                        if (this.isOnline && !this.isRateLimited) {
                            this.statusElement.style.display = 'none';
                        }
                    }, 5000);
                }
                
                // Add pending count if we have pending transactions
                if (pendingTransactions && pendingTransactions.queue && pendingTransactions.queue.length > 0) {
                    this.textElement.textContent = `${this.textElement.textContent} (${pendingTransactions.queue.length} pending)`;
                }
            },
            
            setOnline(isOnline) {
                this.isOnline = isOnline;
                this.updateStatus();
            },
            
            setRateLimited(isLimited) {
                this.isRateLimited = isLimited;
                this.updateStatus();
            }
        };

        // ======== Enhanced Pending Transactions Manager ========
        const pendingTransactions = {
            queue: [],
            isProcessing: false,
            maxBatchSize: 10,
            
            add: function(transaction) {
                this.queue.push({
                    ...transaction,
                    timestamp: Date.now()
                });
                
                // Store in localStorage to persist across page refreshes
                this._saveToStorage();
                
                // Update UI to show pending transaction count
                this._updatePendingIndicator();
            },
            
            _saveToStorage: function() {
                try {
                    localStorage.setItem('pendingTransactions', JSON.stringify(this.queue));
                } catch (e) {
                    console.error("Could not save pending transactions to localStorage", e);
                }
            },
            
            loadFromStorage: function() {
                try {
                    const stored = localStorage.getItem('pendingTransactions');
                    if (stored) {
                        this.queue = JSON.parse(stored);
                        console.log(`Loaded ${this.queue.length} pending transactions from storage`);
                        this._updatePendingIndicator();
                    }
                } catch (e) {
                    console.error("Could not load pending transactions from localStorage", e);
                }
            },
            
            _updatePendingIndicator: function() {
                // Add pending count to the network status indicator
                const status = document.getElementById('status-text');
                if (status && this.queue.length > 0) {
                    status.textContent = `${networkStatus.isOnline ? 'Online' : 'Offline'} (${this.queue.length} pending)`;
                    document.getElementById('network-status').style.display = 'block';
                }
            },
            
            async processQueue(voidAccounting) {
                if (this.isProcessing || this.queue.length === 0 || !navigator.onLine) return;
                
                this.isProcessing = true;
                console.log(`Processing ${this.queue.length} pending transactions`);
                
                // Group by user and game for batching
                const groups = {};
                this.queue.forEach(tx => {
                    const key = `${tx.userId || 'guest'}:${tx.gameId || 'system'}`;
                    if (!groups[key]) groups[key] = [];
                    groups[key].push(tx);
                });
                
                let processedCount = 0;
                
                // Process each group
                for (const [groupKey, transactions] of Object.entries(groups)) {
                    // Skip if we hit rate limit during processing
                    if (rateLimitTracker.isInCooldown()) {
                        break;
                    }
                    
                    // Sort by timestamp (oldest first)
                    const sortedTransactions = [...transactions].sort((a, b) => a.timestamp - b.timestamp);
                    
                    // Process in batches to avoid huge transactions
                    for (let i = 0; i < sortedTransactions.length; i += this.maxBatchSize) {
                        const batch = sortedTransactions.slice(i, i + this.maxBatchSize);
                        
                        // Skip expired transactions (older than 24 hours)
                        const validBatch = batch.filter(tx => Date.now() - tx.timestamp < 86400000);
                        if (validBatch.length === 0) continue;
                        
                        try {
                            // Create batch operations
                            const batchOps = validBatch.map(tx => {
                                // Construct appropriate operation based on transaction type
                                if (tx.type === 'game_play' || tx.type === 'game_visit') {
                                    return {
                                        type: 'set',
                                        ref: doc(collection(db, 'game_visits')),
                                        data: {
                                            userId: tx.userId,
                                            gameId: tx.gameId,
                                            timestamp: serverTimestamp()
                                        }
                                    };
                                } else {
                                    return {
                                        type: 'set',
                                        ref: doc(collection(db, 'transactions')),
                                        data: {
                                            userId: tx.userId,
                                            gameId: tx.gameId,
                                            transactionType: tx.type,
                                            amount: tx.amount || 0,
                                            timestamp: serverTimestamp()
                                        }
                                    };
                                }
                            });
                            
                            // Process batch if there are operations
                            if (batchOps.length > 0) {
                                await voidAccounting.processBatchedOperations(batchOps);
                                
                                // Update user profile if needed (for transactions that affect balance)
                                if (validBatch.some(tx => tx.type !== 'game_visit' && tx.amount > 0)) {
                                    await this._updateUserProfile(validBatch);
                                }
                                
                                // Mark these as processed
                                validBatch.forEach(tx => {
                                    const index = this.queue.findIndex(t => 
                                        t.gameId === tx.gameId && 
                                        t.timestamp === tx.timestamp);
                                    if (index >= 0) this.queue.splice(index, 1);
                                    processedCount++;
                                });
                            }
                        } catch (error) {
                            console.warn("Failed to process batch", error);
                            
                            if (error.code === 'resource-exhausted') {
                                rateLimitTracker.markRateLimited();
                                break; // Stop processing more batches
                            }
                        }
                    }
                }
                
                // Save remaining queue back to storage
                this._saveToStorage();
                this._updatePendingIndicator();
                
                console.log(`Processed ${processedCount} pending transactions, ${this.queue.length} remaining`);
                this.isProcessing = false;
            },
            
            async _updateUserProfile(transactions) {
                // Group by user
                const userUpdates = {};
                
                transactions.forEach(tx => {
                    if (!tx.userId) return;
                    
                    if (!userUpdates[tx.userId]) {
                        userUpdates[tx.userId] = {
                            balanceChange: 0,
                            gamesPlayed: 0,
                            moneySpent: 0,
                            moneyEarned: 0
                        };
                    }
                    
                    // Update metrics based on transaction type
                    const update = userUpdates[tx.userId];
                    const amount = Number(tx.amount) || 0;
                    
                    switch(tx.type) {
                        case 'deposit':
                            update.balanceChange += amount;
                            break;
                        case 'withdrawal':
                            update.balanceChange -= amount;
                            break;
                        case 'game_play':
                            if (amount > 0) {
                                update.balanceChange -= amount;
                                update.moneySpent += amount;
                            }
                            update.gamesPlayed += 1;
                            break;
                        case 'game_win':
                            update.balanceChange += amount;
                            update.moneyEarned += amount;
                            break;
                    }
                });
                
                // Apply updates for each user
                for (const [userId, update] of Object.entries(userUpdates)) {
                    try {
                        // Get current user data
                        const userRef = doc(db, 'users', userId);
                        const userDoc = await getDoc(userRef);
                        
                        if (!userDoc.exists()) continue;
                        
                        const userData = userDoc.data();
                        
                        // Calculate new values
                        const updatedData = {
                            accountBalance: (userData.accountBalance || 0) + update.balanceChange,
                            totalGamesPlayed: (userData.totalGamesPlayed || 0) + update.gamesPlayed,
                            totalMoneySpent: (userData.totalMoneySpent || 0) + update.moneySpent,
                            totalMoneyEarned: (userData.totalMoneyEarned || 0) + update.moneyEarned,
                            lastUpdated: serverTimestamp()
                        };
                        
                        // Apply update
                        await updateDoc(userRef, updatedData);
                        
                        // Update cache
                        const cacheKey = `cache:user:${userId}`;
                        const cachedUser = cacheManager.get(cacheKey);
                        if (cachedUser) {
                            cachedUser.accountBalance = updatedData.accountBalance;
                            cachedUser.totalGamesPlayed = updatedData.totalGamesPlayed;
                            cachedUser.totalMoneySpent = updatedData.totalMoneySpent;
                            cachedUser.totalMoneyEarned = updatedData.totalMoneyEarned;
                            cacheManager.set(cacheKey, cachedUser);
                        }
                    } catch (error) {
                        console.error("Error updating user profile:", error);
                        
                        if (error.code === 'resource-exhausted') {
                            rateLimitTracker.markRateLimited();
                            break;
                        }
                    }
                }
            }
        };

        // ======== Rate Limit Tracking ========
        const rateLimitTracker = {
            lastError: 0,
            cooldownPeriod: 10000, // 10 seconds cooldown after a rate limit hit
            isInCooldown() {
                return Date.now() - this.lastError < this.cooldownPeriod;
            },
            markRateLimited() {
                this.lastError = Date.now();
                // Increase cooldown period if we're getting rate limited frequently
                this.cooldownPeriod = Math.min(300000, this.cooldownPeriod * 1.5); // Max 5 minutes
                console.log(`Rate limit cooldown set to ${this.cooldownPeriod/1000} seconds`);
                networkStatus.setRateLimited(true);
            },
            reset() {
                // If we haven't had an error in a while, gradually reduce the cooldown
                if (Date.now() - this.lastError > 60000) { // After a minute with no errors
                    this.cooldownPeriod = Math.max(10000, this.cooldownPeriod * 0.8);
                    networkStatus.setRateLimited(false);
                }
            }
        };

        // ======== Pagination for Firestore Queries ========
        const paginatedQuery = {
            execute: async function(queryRef, pageSize = 10, startAfterDoc = null) {
                try {
                    let finalQuery = queryRef.limit(pageSize);
                    
                    if (startAfterDoc) {
                        finalQuery = finalQuery.startAfter(startAfterDoc);
                    }
                    
                    const snapshot = await getDocs(finalQuery);
                    
                    return {
                        docs: snapshot.docs,
                        data: snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        })),
                        lastDoc: snapshot.docs.length > 0 ? snapshot.docs[snapshot.docs.length - 1] : null,
                        hasMore: snapshot.docs.length === pageSize
                    };
                } catch (error) {
                    console.error("Paginated query error:", error);
                    
                    if (error.code === 'resource-exhausted') {
                        rateLimitTracker.markRateLimited();
                    }
                    
                    throw error;
                }
            }
        };

        // ======== Throttling for User Operations ========
        const userOperationThrottling = {
            operations: {},
            minInterval: 5000, // Minimum 5 seconds between identical operations
            
            canExecute(userId, operation) {
                const key = `${userId}:${operation}`;
                const now = Date.now();
                const lastTime = this.operations[key] || 0;
                
                if (now - lastTime < this.minInterval) {
                    return false;
                }
                
                this.operations[key] = now;
                return true;
            }
        };

        // ======== Setup Firebase ========
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Try to enable offline persistence
        try {
            enableIndexedDbPersistence(db).catch((err) => {
                if (err.code === 'failed-precondition') {
                    console.warn('Multiple tabs open, persistence can only be enabled in one tab at a time.');
                } else if (err.code === 'unimplemented') {
                    console.warn('The current browser does not support offline persistence');
                }
            });
            
            // Monitor sync status with server if available
            if (typeof onSnapshotsInSync === 'function') {
                onSnapshotsInSync(db, () => {
                    console.log("Firestore data synced with server");
                    networkStatus.setOnline(true);
                    networkStatus.setRateLimited(false);
                });
            }
        } catch (error) {
            console.warn("Error setting up Firestore:", error);
        }
        
        // ======== Improved getCachedUserData Function ========
        const getCachedUserData = async (userId) => {
            const cacheKey = `cache:user:${userId}`;
            
            // Try to get from memory cache first
            const cachedData = cacheManager.get(cacheKey);
            if (cachedData) {
                console.log("Retrieved user data from memory cache");
                return cachedData;
            }
            
            try {
                // Try to get from Firestore cache
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef, { source: 'cache' });
                
                if (userDoc.exists()) {
                    console.log("Retrieved user data from Firestore cache");
                    const userData = userDoc.data();
                    
                    // Save to memory cache for faster access next time
                    cacheManager.set(cacheKey, userData, 30); // 30 minutes expiration
                    
                    return userData;
                }
                return null;
            } catch (error) {
                console.error("Error getting cached user data:", error);
                return null;
            }
        };

        // Profile Icon Toggle Functionality
        const profileIcon = document.getElementById('profile-icon');
        const authContainer = document.getElementById('auth-container');
        
        profileIcon.addEventListener('click', () => {
            // Toggle visibility of auth container
            if (authContainer.style.display === 'block') {
                authContainer.style.display = 'none';
            } else {
                authContainer.style.display = 'block';
                
                // If user is logged in, refresh balance display
                if (auth.currentUser) {
                    voidAccounting.getUserAccountDetails(auth.currentUser.uid)
                        .then(userDetails => {
                            if (userDetails) {
                                document.getElementById('username-display').textContent = userDetails.username || 'User';
                                document.getElementById('balance-display').textContent = userDetails.accountBalance.toLocaleString();
                            }
                        })
                        .catch(error => {
                            console.error("Error refreshing balance:", error);
                            // Try to get from cache
                            getCachedUserData(auth.currentUser.uid).then(cachedData => {
                                if (cachedData) {
                                    document.getElementById('username-display').textContent = cachedData.username || 'User';
                                    document.getElementById('balance-display').textContent = cachedData.accountBalance.toLocaleString();
                                }
                            });
                        });
                }
            }
        });

        // Close auth container when clicking outside
        document.addEventListener('click', (event) => {
            if (!profileIcon.contains(event.target) && 
                !authContainer.contains(event.target)) {
                authContainer.style.display = 'none';
            }
        });

        // Network status listeners
        window.addEventListener('online', () => {
            console.log("App is online");
            networkStatus.setOnline(true);
            // Try to process pending transactions
            pendingTransactions.processQueue(voidAccounting);
        });
        
        window.addEventListener('offline', () => {
            console.log("App is offline");
            networkStatus.setOnline(false);
        });

// IMPROVED: Void Network Accounting Class
class VoidNetworkAccounting {
    constructor() {
        this.auth = auth;
        this.db = db;
        console.log("VoidNetworkAccounting initialized");
    }

    // User Registration - IMPROVED
    async registerUser(email, password, username) {
        try {
            console.log("Registering new user:", email);
            
            if (!navigator.onLine) {
                throw new Error('Cannot register new users while offline');
            }
            
            const userCredential = await createUserWithEmailAndPassword(this.auth, email, password);
            const user = userCredential.user;

            // Create user profile in Firestore
            await setDoc(doc(this.db, 'users', user.uid), {
                username: username,
                email: email,
                createdAt: serverTimestamp(),
                accountBalance: 1000, // Starting balance
                totalGamesPlayed: 0,
                totalMoneySpent: 0,
                totalMoneyEarned: 0,
                active: true,
                status: 'active',
                lastLogin: serverTimestamp()
            });

            // Cache the user data immediately 
            const userData = {
                username: username,
                email: email,
                accountBalance: 1000,
                totalGamesPlayed: 0,
                totalMoneySpent: 0,
                totalMoneyEarned: 0,
                active: true,
                status: 'active'
            };
            
            cacheManager.set(`cache:user:${user.uid}`, userData, 60);

            console.log("User registered successfully:", user.uid);
            return user;
        } catch (error) {
            console.error("Registration Error:", error);
            throw error;
        }
    }

    // User Login - IMPROVED with account validation
    async loginUser(email, password) {
        try {
            console.log("Attempting to log in user:", email);
            
            if (!navigator.onLine) {
                throw new Error('Cannot log in while offline. Please check your connection and try again.');
            }
            
            // First attempt to authenticate with Firebase Auth
            const userCredential = await signInWithEmailAndPassword(this.auth, email, password);
            const user = userCredential.user;
            
            if (!user) {
                throw new Error("Authentication failed - no user returned");
            }
            
            console.log("Auth successful, checking if user exists in Firestore:", user.uid);
            
            // Next, verify the user exists in Firestore
            const userRef = doc(this.db, 'users', user.uid);
            const userDoc = await getDoc(userRef);
            
            // If user doesn't exist in Firestore, sign them out and throw error
            if (!userDoc.exists()) {
                console.error("User authenticated but no Firestore record found - logging out");
                await this.auth.signOut();
                throw new Error('Account not found in database. Please contact support.');
            }
            
            // Check if account is marked as deleted or inactive
            const userData = userDoc.data();
            if (userData.status === 'deleted' || userData.active === false) {
                console.error("User account is marked as deleted or inactive - logging out");
                await this.auth.signOut();
                throw new Error('This account has been deleted or deactivated. Please contact support.');
            }
            
            // Update last login time
            try {
                await updateDoc(userRef, {
                    lastLogin: serverTimestamp()
                });
            } catch (updateError) {
                console.warn("Could not update last login time", updateError);
                // Non-critical, continue without failing
            }
            
            // Cache the user data for faster access
            cacheManager.set(`cache:user:${user.uid}`, userData, 60);
            
            console.log("User verified in both Auth and Firestore:", user.uid);
            return user;
        } catch (error) {
            console.error("Login Error:", error);
            
            // Check for specific Firebase Auth errors and provide clearer messages
            if (error.code === 'auth/user-not-found' || error.code === 'auth/user-disabled') {
                throw new Error('Account not found or disabled. Please contact support.');
            } else if (error.code === 'auth/wrong-password') {
                throw new Error('Incorrect password. Please try again.');
            } else if (error.code === 'auth/too-many-requests') {
                throw new Error('Too many login attempts. Please try again later.');
            } else if (error.code === 'auth/invalid-credential') {
                throw new Error('Invalid login credentials. Please try again.');
            } else if (error.code === 'auth/network-request-failed') {
                throw new Error('Network error. Please check your connection and try again.');
            }
            
            throw error;
        }
    }

    // Logout - IMPROVED
    async logout() {
        try {
            console.log("Logging out user");
            
            // Remove cached user data
            const userId = this.auth.currentUser?.uid;
            if (userId) {
                cacheManager.remove(`cache:user:${userId}`);
            }
            
            await this.auth.signOut();
            console.log("User logged out successfully");
        } catch (error) {
            console.error("Logout Error:", error);
            throw error;
        }
    }

    // Get Current User
    getCurrentUser() {
        return this.auth.currentUser;
    }

    // Handle account deletion and validation
    async handleAccountDeletion(userId) {
        try {
            console.log("Checking account status for user:", userId);
            
            // If offline or in rate limit cooldown, skip validation
            if (!navigator.onLine || rateLimitTracker.isInCooldown()) {
                console.log("Skipping account validation - offline or rate limited");
                return true; // Assume valid in offline/rate-limited mode
            }
            
            // Don't check too frequently for the same user
            if (!userOperationThrottling.canExecute(userId, 'account-check')) {
                return true; // Skip excessive checks
            }
            
            // Check if user exists in Firestore
            const userRef = doc(this.db, 'users', userId);
            
            try {
                const userDoc = await getDoc(userRef);
                
                if (!userDoc.exists()) {
                    console.error("User doesn't exist in Firestore");
                    
                    // Remove cached data
                    cacheManager.remove(`cache:user:${userId}`);
                    
                    // Force sign out
                    await this.auth.signOut();
                    return false;
                }
                
                // Check if user is marked as deleted in Firestore
                const userData = userDoc.data();
                if (userData.status === 'deleted' || userData.active === false) {
                    console.warn("User account is marked as deleted or inactive");
                    
                    // Remove cached data
                    cacheManager.remove(`cache:user:${userId}`);
                    
                    // Force sign out
                    await this.auth.signOut();
                    return false;
                }
            } catch (error) {
                // If we get a rate limit error during check, assume account is valid
                if (error.code === 'resource-exhausted') {
                    rateLimitTracker.markRateLimited();
                    return true;
                }
                throw error;
            }
            
            return true;
        } catch (error) {
            console.error("Error checking account status:", error);
            
            // In case of network errors, don't block the user
            if (error.code === 'unavailable' || error.code === 'network-request-failed') {
                return true;
            }
            
            // If there's any other error, default to logging the user out for safety
            try {
                await this.auth.signOut();
            } catch (signOutError) {
                console.error("Error signing out:", signOutError);
            }
            
            return false;
        }
    }

    // Get User Account Details - IMPROVED with proper caching
    async getUserAccountDetails(userId) {
        try {
            console.log("Getting account details for user:", userId);
            
            const cacheKey = `cache:user:${userId}`;
            
            // First check if account is valid and active (unless in rate limit cooldown)
            if (!rateLimitTracker.isInCooldown()) {
                const isValid = await this.handleAccountDeletion(userId);
                if (!isValid) {
                    console.error("Account is no longer valid");
                    return null;
                }
            }
            
            // Check memory cache first for ultra-fast response
            const memoryCache = cacheManager.get(cacheKey, 5); // 5 minute max age
            if (memoryCache) {
                console.log("Using cached user data from memory");
                return memoryCache;
            }
            
            // Try getting data from server if online and not rate limited
            let userData = null;
            let shouldUpdateCache = false;
            
            if (navigator.onLine && !rateLimitTracker.isInCooldown()) {
                try {
                    const userRef = doc(this.db, 'users', userId);
                    const userDoc = await getDoc(userRef);
                    
                    if (userDoc.exists()) {
                        userData = userDoc.data();
                        shouldUpdateCache = true;
                        console.log("Retrieved fresh user data from server");
                    }
                } catch (error) {
                    console.warn("Error getting data from server:", error);
                    
                    if (error.code === 'resource-exhausted') {
                        rateLimitTracker.markRateLimited();
                    }
                }
            }
            
            // If server failed or we're offline/rate-limited, try Firestore cache
            if (!userData) {
                const cachedData = await getCachedUserData(userId);
                if (cachedData) {
                    userData = cachedData;
                    console.log("Using cached user data from Firestore cache");
                }
            }
            
            // If we found data and need to update our cache, do so
            if (userData && shouldUpdateCache) {
                cacheManager.set(cacheKey, userData, 30); // 30 minutes cache
            }
            
            if (!userData) {
                console.error("User document not found in server or cache");
            }
            
            return userData;
        } catch (error) {
            console.error("Account Details Error:", error);
            
            // For network errors, try cache
            if (error.code === 'unavailable' || error.code === 'network-request-failed') {
                return await getCachedUserData(userId);
            }
            
            throw error;
        }
    }

    // Record Game Transaction - IMPROVED with batching
    async recordGameTransaction(gameId, userId, transactionType, amount) {
        try {
            // Check for rate limiting
            if (rateLimitTracker.isInCooldown()) {
                console.log("In rate limit cooldown, skipping transaction recording");
                pendingTransactions.add({
                    gameId,
                    userId,
                    type: transactionType,
                    amount
                });
                
                return {
                    transactionId: "rate-limited-" + Date.now(),
                    newBalance: -1,
                    wasRateLimited: true
                };
            }
            
            // If we're offline, queue for later
            if (!navigator.onLine) {
                console.log(`Offline: Queueing transaction: ${transactionType} for ${amount} coins in ${gameId}`);
                pendingTransactions.add({
                    gameId,
                    userId,
                    type: transactionType,
                    amount
                });
                
                return {
                    transactionId: "offline-" + Date.now(),
                    newBalance: -1,
                    wasOffline: true
                };
            }
            
            console.log(`Recording transaction: ${transactionType} for ${amount} coins in ${gameId}`);
            
            // Convert amount to number
            amount = Number(amount) || 0;
            
            // Zero-amount game plays don't need to update the user document
            if (transactionType === 'game_play' && amount === 0) {
                // Use the batch manager to potentially combine with other operations
                const transactionId = "visit-" + Date.now();
                
                batchManager.add({
                    type: 'set',
                    ref: doc(collection(this.db, 'game_visits')),
                    data: {
                        userId: userId,
                        gameId: gameId,
                        timestamp: serverTimestamp()
                    },
                    batchKey: 'game_visits'
                });
                
                return {
                    transactionId: transactionId,
                    newBalance: -1 // Unknown without reading user doc
                };
            }
            
            // For transactions that affect balance, use a transaction
            try {
                // Get current user data first
                const userRef = doc(this.db, 'users', userId);
                const userDoc = await getDoc(userRef);
                
                if (!userDoc.exists()) {
                    throw new Error('User document not found');
                }
                
                const userData = userDoc.data();
                let updatedBalance = userData.accountBalance || 0;
                let totalGamesPlayed = userData.totalGamesPlayed || 0;
                let totalMoneySpent = userData.totalMoneySpent || 0;
                let totalMoneyEarned = userData.totalMoneyEarned || 0;
                
                // Update metrics based on transaction type
                switch(transactionType) {
                    case 'deposit':
                        updatedBalance += amount;
                        break;
                    case 'withdrawal':
                        if (updatedBalance < amount) {
                            throw new Error('Insufficient balance');
                        }
                        updatedBalance -= amount;
                        break;
                    case 'game_play':
                        if (amount > 0 && updatedBalance < amount) {
                            throw new Error('Insufficient balance to play game');
                        }
                        updatedBalance -= amount;
                        totalGamesPlayed += 1;
                        totalMoneySpent += amount;
                        break;
                    case 'game_win':
                        updatedBalance += amount;
                        totalMoneyEarned += amount;
                        break;
                    default:
                        console.warn(`Unknown transaction type: ${transactionType}`);
                }
                
                // Use batch operations for efficiency
                const transactionId = Date.now().toString(36) + Math.random().toString(36).substring(2, 5);
                
                // Create batch with both operations
                const batchOperations = [
                    {
                        type: 'set',
                        ref: doc(collection(this.db, 'transactions'), transactionId),
                        data: {
                            userId: userId,
                            gameId: gameId,
                            transactionType: transactionType,
                            amount: amount,
                            timestamp: serverTimestamp()
                        }
                    },
                    {
                        type: 'update',
                        ref: userRef,
                        data: {
                            accountBalance: updatedBalance,
                            totalGamesPlayed: totalGamesPlayed,
                            totalMoneySpent: totalMoneySpent,
                            totalMoneyEarned: totalMoneyEarned,
                            lastUpdated: serverTimestamp()
                        }
                    }
                ];
                
                await this.processBatchedOperations(batchOperations);
                
                // Update memory cache with new balance
                const cacheKey = `cache:user:${userId}`;
                const cachedUser = cacheManager.get(cacheKey);
                if (cachedUser) {
                    cachedUser.accountBalance = updatedBalance;
                    cachedUser.totalGamesPlayed = totalGamesPlayed;
                    cachedUser.totalMoneySpent = totalMoneySpent;
                    cachedUser.totalMoneyEarned = totalMoneyEarned;
                    cacheManager.set(cacheKey, cachedUser);
                }
                
                console.log(`Transaction completed. New balance: ${updatedBalance}`);
                return {
                    transactionId: transactionId,
                    newBalance: updatedBalance
                };
            } catch (error) {
                if (error.code === 'resource-exhausted') {
                    rateLimitTracker.markRateLimited();
                    // Queue for later
                    pendingTransactions.add({
                        gameId,
                        userId,
                        type: transactionType,
                        amount
                    });
                    
                    return {
                        transactionId: "rate-limited-" + Date.now(),
                        newBalance: -1,
                        wasRateLimited: true
                    };
                }
                throw error;
            }
        } catch (error) {
            console.error("Transaction Error:", error);
            throw error;
        }
    }
    
    // Batch processing for multiple operations
    async processBatchedOperations(operations) {
        try {
            if (!navigator.onLine) {
                console.log("Offline: Cannot process batched operations");
                return false;
            }
            
            if (operations.length === 0) {
                return true;
            }
            
            // Create a batch
            const batch = writeBatch(this.db);
            
            // Add all operations to the batch
            operations.forEach(op => {
                if (op.type === 'set') {
                    batch.set(op.ref, op.data);
                } else if (op.type === 'update') {
                    batch.update(op.ref, op.data);
                } else if (op.type === 'delete') {
                    batch.delete(op.ref);
                }
            });
            
            // Commit the batch
            await batch.commit();
            return true;
        } catch (error) {
            console.error("Batch operation failed:", error);
            
            if (error.code === 'resource-exhausted') {
                rateLimitTracker.markRateLimited();
            }
            
            return false;
        }
    }
}

// Initialize Accounting System
const voidAccounting = new VoidNetworkAccounting();

// Authentication Event Listeners
document.getElementById('login-btn')?.addEventListener('click', async () => {
    const email = document.getElementById('login-email').value;
    const password = document.getElementById('login-password').value;
    
    if (!email || !password) {
        alert('Please enter both email and password');
        return;
    }
    
    try {
        // Disable login button to prevent multiple clicks
        const loginBtn = document.getElementById('login-btn');
        loginBtn.disabled = true;
        loginBtn.textContent = 'Logging in...';
        
        const user = await voidAccounting.loginUser(email, password);
        console.log('Logged in user:', user);
        await updateUIForLoggedInUser(user);
        authContainer.style.display = 'none'; // Hide auth container after login
    } catch (error) {
        alert('Login failed: ' + error.message);
    } finally {
        // Re-enable login button
        const loginBtn = document.getElementById('login-btn');
        loginBtn.disabled = false;
        loginBtn.textContent = 'Login';
    }
});

document.getElementById('register-btn')?.addEventListener('click', async () => {
    const username = document.getElementById('register-username').value;
    const email = document.getElementById('register-email').value;
    const password = document.getElementById('register-password').value;
    
    if (!username || !email || !password) {
        alert('Please fill in all fields');
        return;
    }
    
    try {
        // Disable register button to prevent multiple clicks
        const registerBtn = document.getElementById('register-btn');
        registerBtn.disabled = true;
        registerBtn.textContent = 'Creating account...';
        
        const user = await voidAccounting.registerUser(email, password, username);
        console.log('Registered user:', user);
        await updateUIForLoggedInUser(user);
        authContainer.style.display = 'none'; // Hide auth container after registration
    } catch (error) {
        alert('Registration failed: ' + error.message);
    } finally {
        // Re-enable register button
        const registerBtn = document.getElementById('register-btn');
        registerBtn.disabled = false;
        registerBtn.textContent = 'Register';
    }
});

document.getElementById('logout-btn')?.addEventListener('click', async () => {
    try {
        await voidAccounting.logout();
        updateUIForLoggedOutUser();
    } catch (error) {
        alert('Logout failed: ' + error.message);
    }
});

// IMPROVED: Update UI based on authentication state - with fresh data
async function updateUIForLoggedInUser(user) {
    document.getElementById('login-form').style.display = 'none';
    document.getElementById('register-form').style.display = 'none';
    document.getElementById('user-profile').style.display = 'block';
    
    try {
        // Fetch fresh user details from server
        const userDetails = await voidAccounting.getUserAccountDetails(user.uid);
        if (!userDetails) {
            // Account no longer valid
            updateUIForLoggedOutUser();
            alert('Your account was not found or has been deactivated. Please contact support.');
            return;
        }
        
        document.getElementById('username-display').textContent = userDetails.username || 'User';
        document.getElementById('balance-display').textContent = userDetails.accountBalance.toLocaleString();
        console.log("Updated UI with balance:", userDetails.accountBalance);
    } catch (error) {
        console.error("Error updating UI:", error);
        
        // Try to get from cache
        const cachedData = await getCachedUserData(user.uid);
        if (cachedData) {
            document.getElementById('username-display').textContent = cachedData.username || 'User';
            document.getElementById('balance-display').textContent = cachedData.accountBalance.toLocaleString();
            console.log("Updated UI with cached balance:", cachedData.accountBalance);
        } else {
            alert('Could not load user details. Please try again.');
            // If there's an error loading details, best to log out
            await voidAccounting.logout();
            updateUIForLoggedOutUser();
        }
    }
}

function updateUIForLoggedOutUser() {
    document.getElementById('login-form').style.display = 'block';
    document.getElementById('register-form').style.display = 'block';
    document.getElementById('user-profile').style.display = 'none';
}

// IMPROVED: Enhanced auth state change listener with verification
onAuthStateChanged(auth, async (user) => {
    if (user) {
        console.log("Auth state changed: User is signed in", user.uid);
        
        try {
            // Skip detailed verification if we're offline or rate-limited
            if (!navigator.onLine || rateLimitTracker.isInCooldown()) {
                console.log("Skipping detailed verification - offline or rate limited");
                await updateUIForLoggedInUser(user);
                return;
            }
            
            // Verify the user still exists in Firestore
            const userRef = doc(db, 'users', user.uid);
            
            try {
                const userDoc = await getDoc(userRef);
                
                if (!userDoc.exists()) {
                    console.error("User authenticated but no Firestore record found - logging out");
                    await auth.signOut();
                    alert('Your account data could not be found. Please contact support.');
                    updateUIForLoggedOutUser();
                    return;
                }
                
                // Check if account is marked as deleted or inactive
                const userData = userDoc.data();
                if (userData.status === 'deleted' || userData.active === false) {
                    console.error("User account is marked as deleted or inactive - logging out");
                    await auth.signOut();
                    alert('Your account has been deleted or deactivated. Please contact support if this is unexpected.');
                    updateUIForLoggedOutUser();
                    return;
                }
            } catch (error) {
                // If we hit a rate limit, just continue
                if (error.code === 'resource-exhausted') {
                    rateLimitTracker.markRateLimited();
                } else if (error.code === 'unavailable' || error.code === 'network-request-failed') {
                    // Network issues, continue with cached data
                    console.warn("Network issue during verification, continuing with cached data");
                } else {
                    throw error;
                }
            }
            
            // User exists in both Auth and Firestore, update UI
            await updateUIForLoggedInUser(user);
        } catch (error) {
            console.error("Error verifying user in Firestore:", error);
            // Handle any other errors that might occur during verification
            
            // For critical errors, log out
            if (error.code !== 'unavailable' && error.code !== 'network-request-failed' && 
                error.code !== 'resource-exhausted') {
                alert('There was a problem verifying your account. Please try signing in again.');
                await auth.signOut();
                updateUIForLoggedOutUser();
            } else {
                // For network issues, still try to update UI with cached data
                await updateUIForLoggedInUser(user);
            }
        }
    } else {
        console.log("Auth state changed: User is signed out");
        updateUIForLoggedOutUser();
    }
});

// IMPROVED: Updated renderAppsList function with pagination
function renderAppsList(pageSize = 12, page = 1) {
    const gamesList = document.getElementById("gamesList");
    
    if (!gamesList) {
        console.error("Games list element not found");
        return;
    }
    
    // Only clear if this is the first page
    if (page === 1) {
        gamesList.innerHTML = '';
    }
    
    console.log(`Rendering games list (page ${page})`);
    
    // Try to load cached game data first (in case we're offline)
    try {
        const cachedApps = cacheManager.get('cache:games');
        if (cachedApps) {
            renderGames(cachedApps, page, pageSize);
            return;
        }
    } catch (error) {
        console.warn("Error reading cached games:", error);
    }
    
    // Fall back to default games if cache is unavailable
    renderGames(defaultApps, page, pageSize);
    
    // Cache the default apps for future offline use
    try {
        cacheManager.set('cache:games', defaultApps, 720); // 12 hour cache
    } catch (error) {
        console.warn("Failed to cache games:", error);
    }
    
    // Helper function to actually render the games with pagination
    function renderGames(apps, currentPage, itemsPerPage) {
        // Calculate pagination
        const startIndex = (currentPage - 1) * itemsPerPage;
        const endIndex = startIndex + itemsPerPage;
        const appsToRender = apps.slice(startIndex, endIndex);
        
        // Add a "load more" button if needed
        const hasMorePages = endIndex < apps.length;
        
        appsToRender.forEach(app => {
            const appElement = document.createElement("div");
            appElement.className = "game-item";
            
            appElement.innerHTML = `
                <div class="game-icon">
                    <img src="${app.imgSrc}" alt="${app.title} icon" onerror="this.src='/assets/placeholder.png'">
                </div>
                <h3 class="game-title">${app.title}</h3>
            `;

            appElement.onclick = async () => {
                // Log the navigation attempt regardless of login status
                console.log("Navigating to game:", app.title);
                
                // Show loading indicator
                appElement.style.opacity = "0.7";
                appElement.style.pointerEvents = "none";
                
                try {
                    // Check if user is logged in
                    const currentUser = voidAccounting.getCurrentUser();
                    
                    // If user is logged in, try to record the visit, but don't block on failure
                    if (currentUser) {
                        try {
                            // Add to batch manager instead of immediately calling
                            batchManager.add({
                                type: 'set',
                                ref: doc(collection(db, 'game_visits')),
                                data: {
                                    userId: currentUser.uid,
                                    gameId: app.title.toLowerCase().replace(/\s+/g, '_'),
                                    timestamp: serverTimestamp()
                                },
                                batchKey: 'game_visits'
                            });
                        } catch (error) {
                            // Just log errors, don't block the game
                            console.warn("Error recording game visit:", error);
                        }
                    } else {
                        // For non-logged in users, track locally using localStorage
                        try {
                            const gamesPlayed = JSON.parse(localStorage.getItem('gamesPlayed') || '[]');
                            gamesPlayed.push({
                                game: app.title,
                                timestamp: Date.now()
                            });
                            localStorage.setItem('gamesPlayed', JSON.stringify(gamesPlayed));
                        } catch (e) {
                            console.warn("Could not track game in localStorage:", e);
                        }
                    }
                    
                    // Navigate to the game
                    window.location.href = app.link;
                } catch (error) {
                    // Reset the button state if something unexpected happens
                    appElement.style.opacity = "1";
                    appElement.style.pointerEvents = "auto";
                    console.error("Unexpected error accessing game:", error);
                    alert(`There was a problem: ${error.message || 'Could not access game'}`);
                }
            };

            gamesList.appendChild(appElement);
        });
        
        // Add "Load More" button if more games are available
        if (hasMorePages) {
            const loadMoreRow = document.createElement("div");
            loadMoreRow.style.gridColumn = "1 / -1"; // Span all columns
            loadMoreRow.style.textAlign = "center";
            loadMoreRow.style.margin = "20px 0";
            
            const loadMoreBtn = document.createElement("button");
            loadMoreBtn.textContent = "Load More Games";
            loadMoreBtn.style.background = "rgba(255, 255, 255, 0.2)";
            loadMoreBtn.style.color = "#fff";
            loadMoreBtn.style.border = "none";
            loadMoreBtn.style.borderRadius = "5px";
            loadMoreBtn.style.padding = "10px 20px";
            loadMoreBtn.style.cursor = "pointer";
            
            loadMoreBtn.addEventListener("click", () => {
                renderAppsList(pageSize, currentPage + 1);
                loadMoreRow.remove(); // Remove this button after clicking
            });
            
            loadMoreRow.appendChild(loadMoreBtn);
            gamesList.appendChild(loadMoreRow);
        }
    }
}

// Updated search function that works without requiring Firebase
document.getElementById("searchApps")?.addEventListener("keyup", function(e) {
    const gamesList = document.getElementById("gamesList");
    const searchTerm = this.value.toLowerCase();
    
    if (!gamesList) return;
    
    gamesList.innerHTML = '';
    
    // Try to get cached games first
    let appsToSearch = defaultApps;
    try {
        const cachedApps = cacheManager.get('cache:games');
        if (cachedApps) {
            appsToSearch = cachedApps;
        }
    } catch (error) {
        console.warn("Error reading cached games for search:", error);
    }
    
    // Filter and display games
    const filteredApps = appsToSearch.filter(app => 
        app.title.toLowerCase().includes(searchTerm)
    );
    
    renderGames(filteredApps, 1, 100); // Show all filtered results on one page
    
    function renderGames(apps) {
        apps.forEach(app => {
            const appElement = document.createElement("div");
            appElement.className = "game-item";
            
            appElement.innerHTML = `
                <div class="game-icon">
                    <img src="${app.imgSrc}" alt="${app.title} icon" onerror="this.src='/assets/placeholder.png'">
                </div>
                <h3 class="game-title">${app.title}</h3>
            `;

            appElement.onclick = async () => {
                // Log the navigation attempt regardless of login status
                console.log("Navigating to game:", app.title);
                
                // Show loading indicator
                appElement.style.opacity = "0.7";
                appElement.style.pointerEvents = "none";
                
                try {
                    // Check if user is logged in
                    const currentUser = voidAccounting.getCurrentUser();
                    
                    // If user is logged in, try to record the visit, but don't block on failure
                    if (currentUser) {
                        try {
                            // Use batch manager for better efficiency
                            batchManager.add({
                                type: 'set',
                                ref: doc(collection(db, 'game_visits')),
                                data: {
                                    userId: currentUser.uid,
                                    gameId: app.title.toLowerCase().replace(/\s+/g, '_'),
                                    timestamp: serverTimestamp()
                                },
                                batchKey: 'game_visits'
                            });
                        } catch (error) {
                            // Just log errors, don't block the game
                            console.warn("Error recording game visit:", error);
                        }
                    } else {
                        // For non-logged in users, track locally using localStorage
                        try {
                            const gamesPlayed = JSON.parse(localStorage.getItem('gamesPlayed') || '[]');
                            gamesPlayed.push({
                                game: app.title,
                                timestamp: Date.now()
                            });
                            localStorage.setItem('gamesPlayed', JSON.stringify(gamesPlayed));
                        } catch (e) {
                            console.warn("Could not track game in localStorage:", e);
                        }
                    }
                    
                    // Navigate to the game
                    window.location.href = app.link;
                } catch (error) {
                    // Reset the button state if something unexpected happens
                    appElement.style.opacity = "1";
                    appElement.style.pointerEvents = "auto";
                    console.error("Unexpected error accessing game:", error);
                    alert(`There was a problem: ${error.message || 'Could not access game'}`);
                }
            };

            gamesList.appendChild(appElement);
        });
        
        // Show "no results" message if needed
        if (apps.length === 0) {
            const noResults = document.createElement("div");
            noResults.style.gridColumn = "1 / -1";
            noResults.style.textAlign = "center";
            noResults.style.padding = "40px";
            noResults.style.color = "rgba(255, 255, 255, 0.6)";
            noResults.innerHTML = `No games found matching "${searchTerm}"`;
            gamesList.appendChild(noResults);
        }
    }
});

// IMPROVED: Game loading logic
const defaultApps = [
    {
        title: "Ball Dropper",
        imgSrc: "/gameimg/plinko.webp",
        link: "/local games/Plinko/plinko.html"
    },
    {
        title: "MineFeild",
        imgSrc: "https://lh7-us.googleusercontent.com/l5WNtVYD2uSCuW7SUmGyRW0FWMFO7tqCeMGB7ead4D2KFDJ4IAG8xJCBH_wb-SpSk3KJXVRprq4S_EWOGYz6AgUqlp3npUJqKxRv-7D2daZgYClP8v3c0bif7ASVX9DGjruCZ58fC_SIkOuuAx9z6cX4mG6BQw",
        link: "/local games/CrossyRoad/crossy.html"
    },
    {
        title: "Memory Squares",
        imgSrc: "https://lh7-us.googleusercontent.com/yENXqWmbn3J2WcN7F1X9vTr-k27zTxo2baieHA-SCSXmxL9l73cznC8mo2FWBmplmitbY8jzQgMFSSLV2XQxxpNISyBURgNR8OEapSZm2BG05cjNf7LctQEncsCaBGqEHv0tFB6vyurZnp5WxLIUd7qRQE49Aw",
        link: "/local games/memory-square/mem.html"
    },
    {
        title: "VoidSnake",
        imgSrc: "https://lh7-us.googleusercontent.com/JXLJJ1ZqQHDqJ90qNvpFxyOwilnfISN4XXZvqMiWVwTnG-JMoCxjvY47ARbAMZ5eERwf04Vul58noJIIo-kI5JkOB8O0AsjL4fz5_LffoekV7d-bDrwJiyEX5n2a_TYzXBv6hk4hVyQpn1BFqRkZ75rLboVB5w",
        link: "/local games/Void Snake/Voidsnake.html"
    },
];

// Load apps on page load
window.addEventListener('load', async () => {
    try {
        console.log("Page loaded, initializing app");
        
        // Update network status
        networkStatus.setOnline(navigator.onLine);
        networkStatus.updateStatus();
        
        // Clear expired cache items
        cacheManager.clearExpired();
        
        // Load any pending transactions
        pendingTransactions.loadFromStorage();
        
        // Process queue periodically with exponential backoff
        let queueProcessInterval = 60000; // Start with 1 minute
        
        const processQueue = () => {
            if (navigator.onLine && !rateLimitTracker.isInCooldown()) {
                pendingTransactions.processQueue(voidAccounting);
                
                // If successful and no errors, gradually reduce interval
                if (!rateLimitTracker.isInCooldown()) {
                    queueProcessInterval = Math.max(30000, queueProcessInterval * 0.8);
                } else {
                    // If rate limited, increase interval
                    queueProcessInterval = Math.min(300000, queueProcessInterval * 1.5);
                }
            }
            
            setTimeout(processQueue, queueProcessInterval);
        };
        
        // Start processing after initial delay
        setTimeout(processQueue, 30000);
        
        // Check rate limit status periodically
        setInterval(() => {
            rateLimitTracker.reset();
        }, 60000);
        
        renderAppsList();
        
        // Check if user is already logged in
        const user = auth.currentUser;
        if (user) {
            console.log("User already logged in:", user.uid);
            await updateUIForLoggedInUser(user);
        }
    } catch (err) {
        console.error('Error during initialization:', err);
        
        // Even if there's an error, still render the games list
        renderAppsList();
    }
});
</script>
</body>
</html>
